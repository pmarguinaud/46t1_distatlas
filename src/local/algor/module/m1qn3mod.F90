MODULE M1QN3MOD

!
! From M1QN3, parallel version
!

USE PARKIND1, ONLY : JPRB, JPIM

IMPLICIT NONE

TYPE, PUBLIC :: M1QN3CTX
  INTEGER (KIND=JPIM) :: REENTRY = 0
  INTEGER (KIND=JPIM) :: MYPROC = -1        ! Current task rank
  INTEGER (KIND=JPIM) :: NPROC = -1         ! Number of tasks
  INTEGER (KIND=JPIM) :: IOOUT =  6
  INTEGER (KIND=JPIM), ALLOCATABLE :: N (:) ! size of the problem on each task
  LOGICAL             :: LREPRO = .FALSE.

  CONTAINS
    PROCEDURE :: M1QN3          => M1QN3
    PROCEDURE :: SIMUL          => SIMUL
    PROCEDURE :: PROSCA         => EUCLID
    PROCEDURE :: EUCLID         => EUCLID
    PROCEDURE :: CTONB          => CTONBE
    PROCEDURE :: CTCAB          => CTCABE
    PROCEDURE :: REDUCER        => REDUCER
    PROCEDURE :: REDUCEI        => REDUCEI
    PROCEDURE :: P1             => P1
    PROCEDURE :: P2             => P2
    PROCEDURE :: DO_TEST_TAYLOR => DO_TEST_TAYLOR
   
END TYPE

CONTAINS

SUBROUTINE DO_TEST_TAYLOR (YDCTX, X0, N)

CLASS (M1QN3CTX),    INTENT (INOUT) :: YDCTX
REAL (KIND=JPRB),    INTENT (IN)    :: X0 (N)
INTEGER (KIND=JPIM), INTENT (IN)    :: N

REAL (KIND=JPRB) :: G0 (YDCTX%N (YDCTX%MYPROC))
REAL (KIND=JPRB) :: X (YDCTX%N (YDCTX%MYPROC))
REAL (KIND=JPRB) :: ZDUM (1), ZF0, ZF, ZDX, ZDF, ZG, ZGRADFDX, ZZ
INTEGER (KIND=JPIM) :: IGLO, ILOC, IOFF (YDCTX%NPROC+1), IPROC, ITOTL, ITOTG
LOGICAL :: LME

IOFF (1) = 0
DO IPROC = 2, YDCTX%NPROC+1
  IOFF (IPROC) = IOFF (IPROC-1) + YDCTX%N (IPROC-1)
ENDDO

ITOTL = YDCTX%N (YDCTX%MYPROC)
ITOTG = SUM (YDCTX%N)

CALL YDCTX%SIMUL (0_JPIM, ITOTL, X0, ZF0, G0)

X = X0

WRITE (YDCTX%IOOUT, '(A5," ",A12," ",A12)') "", "F(X+DX)-F(X)", "GRAD(F).DX"

DO IGLO = 1, ITOTG
  
  LME = (IOFF (YDCTX%MYPROC) + 1 <= IGLO) .AND. (IGLO <= IOFF (YDCTX%MYPROC+1))

  IF (LME) THEN
    ILOC = IGLO - IOFF (YDCTX%MYPROC)
    ZDX = X0 (ILOC) * 1E-3_JPRB
    IF (ABS (ZDX) == 0._JPRB) ZDX = 1E-4_JPRB
    X (ILOC) = X0 (ILOC) + ZDX
  ENDIF

  CALL YDCTX%SIMUL (0_JPIM, ITOTL, X, ZF, ZDUM, LGRAD=.FALSE.)
  CALL YDCTX%PROSCA (N, X-X0, G0, ZGRADFDX)

  IF (LME) THEN

    ZDF = ZF - ZF0

    IF (ABS (ZGRADFDX) == 0._JPRB) THEN
      ZZ = 1._JPRB
    ELSE
      ZZ = ZGRADFDX
    ENDIF

    WRITE (YDCTX%IOOUT, '(I5," ",E12.4," ",E12.4," ",E12.4)') &
   & IGLO, ZDF, ZGRADFDX, ZDF / ZZ

    X (ILOC) = X0 (ILOC)
  ENDIF

ENDDO

END SUBROUTINE 

SUBROUTINE P1 (YDCTX, X)

USE MPL_ALLGATHERV_MOD, ONLY : MPL_ALLGATHERV

IMPLICIT NONE

CLASS (M1QN3CTX) YDCTX
REAL (KIND=JPRB) :: X 
REAL (KIND=JPRB) :: XX (YDCTX%NPROC)
INTEGER (KIND=JPIM) :: I

CALL MPL_ALLGATHERV (PSENDBUF=(/X/), PRECVBUF=XX, KRECVCOUNTS=(/(1, I=1, YDCTX%NPROC)/), &
                   & CDSTRING='M1QN3MOD:P1')

IF (YDCTX%MYPROC == 1) THEN
  WRITE (YDCTX%IOOUT, '(100E25.17)') XX
ENDIF

END SUBROUTINE


SUBROUTINE P2 (YDCTX, X, N)

USE MPL_ALLGATHERV_MOD, ONLY : MPL_ALLGATHERV
IMPLICIT NONE

CLASS (M1QN3CTX) YDCTX
INTEGER (KIND=JPIM) :: N
REAL (KIND=JPRB) :: X (N)
REAL (KIND=JPRB) :: XX (SUM (YDCTX%N))

CALL MPL_ALLGATHERV (PSENDBUF=X, PRECVBUF=XX, KRECVCOUNTS=YDCTX%N, &
                   & CDSTRING='M1QN3MOD:P1')

IF (YDCTX%MYPROC == 1) THEN
  WRITE (YDCTX%IOOUT, '(E25.17)') XX
ENDIF

END SUBROUTINE


SUBROUTINE REDUCEI (YDCTX, N, X, OP, V)

USE MPL_ALLREDUCE_MOD, ONLY : MPL_ALLREDUCE
IMPLICIT NONE

CLASS (M1QN3CTX) YDCTX
INTEGER (KIND=JPIM) X (N), V
CHARACTER (LEN=*) OP
INTEGER (KIND=JPIM) N

SELECT CASE (OP)
  CASE ('MAX')
    V = MAXVAL (X)
    CALL MPL_ALLREDUCE (V, 'MAX', CDSTRING='M1QN3MOD:REDUCEI')
  CASE ('SUM')
    V = SUM (X)
    CALL MPL_ALLREDUCE (V, 'SUM', CDSTRING='M1QN3MOD:REDUCEI')
  CASE ('AVG')
    V = SUM (X)
    CALL MPL_ALLREDUCE (V, 'SUM', CDSTRING='M1QN3MOD:REDUCEI')
    V = V / SUM (YDCTX%N)
  CASE DEFAULT
    CALL ABORT
END SELECT

END SUBROUTINE

SUBROUTINE REDUCER (YDCTX, N, X, OP, V)
USE MPL_ALLREDUCE_MOD, ONLY : MPL_ALLREDUCE
IMPLICIT NONE

CLASS (M1QN3CTX) YDCTX
REAL (KIND=JPRB) X (N), V
CHARACTER (LEN=*) OP
INTEGER (KIND=JPIM) N

SELECT CASE (OP)
  CASE ('MAX')
    V = MAXVAL (X)
    CALL MPL_ALLREDUCE (V, 'MAX', CDSTRING='M1QN3MOD:REDUCER')
  CASE ('SUM')
    CALL DO_SUM
  CASE ('AVG')
    CALL DO_SUM
    V = V / SUM (YDCTX%N)
  CASE DEFAULT
    CALL ABORT
END SELECT

CONTAINS

SUBROUTINE DO_SUM 

USE MPL_ALLGATHERV_MOD, ONLY : MPL_ALLGATHERV

REAL (KIND=JPRB), ALLOCATABLE :: XALL (:)

IF (YDCTX%LREPRO) THEN
  ALLOCATE (XALL (SUM (YDCTX%N)))
  CALL MPL_ALLGATHERV (X, XALL, KRECVCOUNTS=YDCTX%N, CDSTRING='M1QN3MOD:REDUCER:DO_SUM')
  V = SUM (XALL)
ELSE
  V = SUM (X)
  CALL MPL_ALLREDUCE (V, 'SUM', CDSTRING='M1QN3MOD:REDUCER', LDREPROD=.FALSE.)
ENDIF

END SUBROUTINE

END SUBROUTINE

SUBROUTINE EUCLID (YDCTX,N,X,Y,PS)

IMPLICIT NONE

CLASS (M1QN3CTX) :: YDCTX
INTEGER (KIND=JPIM) N, I
REAL (KIND=JPRB) X(N),Y(N),PS
REAL (KIND=JPRB) ZZ(N)
!

PS=0.D0
DO I=1,N
    ZZ(I)=X(I)*Y(I)
ENDDO

CALL YDCTX%REDUCER (N, ZZ, 'SUM', PS)

END SUBROUTINE

SUBROUTINE SIMUL(YDCTX,INDIC,N,X,F,G,LGRAD)
IMPLICIT NONE
CLASS (M1QN3CTX) :: YDCTX
INTEGER (KIND=JPIM) :: INDIC, N
REAL (KIND=JPRB) :: X (N), F, G (N)
LOGICAL, OPTIONAL :: LGRAD
RETURN
END SUBROUTINE

SUBROUTINE M1QN3 (YDCTX,N,X,F,G,DXMIN,DF1, &
&  EPSG,NORMTYPE,IMPRES,IO,IMODE,OMODE,NITER,NSIM, &
&  IZ,DZ,NDZ,REVERSE,INDIC)
!
!-----------------------------------------------------------------------
!
!     M1QN3 HAS TWO RUNNING MODES: THE SID (SCALAR INITIAL SCALING) MODE
!     AND THE DIS (DIAGONAL INITIAL SCALING) MODE. BOTH DO NOT REQUIRE
!     THE SAME AMOUNT OF STORAGE, THE SAME SUBROUTINES, ...
!     IN THE DESCRIPTION BELOW, ITEMS THAT DIFFER IN THE DIS MODE WITH
!     RESPECT TO THE SIS MODE ARE GIVEN IN BRAKETS.
!
!     USE THE FOLLOWING SUBROUTINES:
!         M1QN3A
!         DDD, DDDS
!         NLIS0 + DCUBE (DEC 88)
!         MUPDTS, DYSTBL.
!
!     THE FOLLOWING ROUTINES ARE PROPOSED TO THE USER IN CASE THE
!     EUCLIDEAN SCALAR PRODUCT IS USED:
!         DUCLID, DTONBE, DTCABE.
!
!     LA SOUS-ROUTINE M1QN3 EST UNE INTERFACE ENTRE LE PROGRAMME
!     APPELANT ET LA SOUS-ROUTINE M1QN3A, LE MINIMISEUR PROPREMENT DIT.
!
!     LE MODULE PROSCA EST SENSE REALISER LE PRODUIT SCALAIRE DE DEUX
!     VECTEURS DE RN; LE MODULE DTONB EST SENSE REALISER LE CHANGEMENT
!     DE COORDONNEES CORRESPONDANT AU CHANGEMENT DE BASES: BASE
!     EUCLIDIENNE -> BASE ORTHONORMALE (POUR LE PRODUIT SCALAIRE
!     PROSCA); LE MODULE CTBAB FAIT LA TRANSFORMATION INVERSE: BASE
!     ORTHONORMALE -> BASE EUCLIDIENNE.
!
!     IZ IS AN INTEGER WORKING ZONE FOR M1QN3A, ITS DIMENSION IS 5.
!     IT IS FORMED OF 5 SCALARS THAT ARE SET BY THE OPTIMIZER:
!         - THE DIMENSION OF THE PROBLEM,
!         - AN IDENTIFIER OF THE SCALING MODE,
!         - THE NUMBER OF UPDATES,
!         - TWO POINTERS.
!
!     DZ EST LA ZONE DE TRAVAIL POUR M1QN3A, DE DIMENSION NDZ.
!     ELLE EST SUBDIVISEE EN
!         3 [OU 4] VECTEURS DE DIMENSION N: D,GG,[DIAG,]AUX
!         M SCALAIRES: ALPHA
!         M VECTEURS DE DIMENSION N: YBAR
!         M VECTEURS DE DIMENSION N: SBAR
!
!     M EST ALORS LE PLUS GRAND ENTIER TEL QUE
!         M*(2*N+1)+3*N .LE. NDZ [M*(2*N+1)+4*N .LE. NDZ)]
!     SOIT M := (NDZ-3*N) / (2*N+1) [M := (NDZ-4*N) / (2*N+1)].
!     IL FAUT AVOIR M >= 1, DONC NDZ >= 5N+1 [NDZ >= 6N+1].
!
!     A CHAQUE ITERATION LA METRIQUE EST FORMEE A PARTIR D UN MULTIPLE
!     DE L'IDENTITE [D'UNE MATRICE DIAGONALE] D QUI EST MISE A JOUR M
!     FOIS PAR LA FORMULE DE BFGS EN UTILISANT LES M COUPLES {Y,S} LES
!     PLUS RECENTS.
!
!-----------------------------------------------------------------------
!
IMPLICIT NONE
!
!     ARGUMENTS
!
CHARACTER (LEN=3) NORMTYPE
INTEGER (KIND=JPIM) :: N,IMPRES,IO,IMODE(3),OMODE,NITER,NSIM,IZ(5),NDZ,INDIC, REVERSE
REAL (KIND=JPRB) :: X(N),F,G(N),DXMIN,DF1,EPSG,DZ(NDZ)
CLASS (M1QN3CTX) :: YDCTX
!
! --- LOCAL VARIABLES
!
!     THE VARIABLE 'REENTRY' IS USED TO KNOW WHERE TO JUMP WHEN ENTERING
!     THE SUBROUTINE IN REVERSE COMMNUNICATION (IT IS BETTER THAN USING
!     'REVERSE', WHICH IS KNOWN OUTSIDE M1QN3 AND COULD BE CHANGED BY
!     THE USER):
!     = 0: NO JUMP, START AT THE BEGINING OF THE SUBROUTINE
!     = 1: JUMP INSIDE M1QN3A, WHERE THE SIMULATOR WAS CALLED WITH
!          INDIC=1
!     = 2: JUMP INSIDE M1QN3A/MLIS3, WHERE THE SIMULATOR WAS CALLED WITH
!          INDIC=4
!     THE VARIABLE 'REENTRY' IS SET TO 0 BY THE COMPILER AND WHEN M1QN3
!     HAS COMPLETED ITS JOB (SEE BELOW); SINCE THE VALUE IS SAVED, IT
!     HAS ALWAYS THE VALUE 0 WHEN ENTERING THE SOLVER FOR THE FIRST
!     TIME WHEN SOLVING A NEW PROBLEM, EVEN IF IT IS IN THE SAME
!     PROGRAM.
!
LOGICAL INMEMO,SSCALE
INTEGER (KIND=JPIM) :: NTRAVU,ID,IGG,IDIAG,IAUX,IALPHA,IYBAR,ISBAR,M,MMEMO
REAL (KIND=JPRB) :: GNORM,PS
!
! --- FUNCTION
!
REAL (KIND=JPRB) :: DDOT
!
! --- STOP IF REVERSE < 0 (M1QN3 SHOULD NOT BE CALLED WITH REVERSE < 0)
!
IF (REVERSE.LT.0) THEN
  WRITE (IO,'(/A,A,I0,A/)') &
&        " >>> M1QN3 SHOULD NOT BE CALLED WITH A NEGATIVE REVERSE", " (=", REVERSE, ")"
  STOP
ENDIF
!
! --- POSSIBLE JUMPS
!     9999: GO DIRECTLY IN M1QN3A
!
IF (YDCTX%REENTRY.GT.0) GOTO 9999
!
!---- IMPRESSIONS INITIALES ET CONTROLE DES ARGUMENTS
!
BLOCK
  INTEGER (KIND=JPIM) :: NA
  CALL YDCTX%REDUCEI (1, (/N/), 'SUM', NA)
  IF (IMPRES.GE.1) THEN
    WRITE (IO, &
     &      '(/" M1QN3                            : ENTRY POINT"/ &
     &    5X,"DIMENSION OF THE PROBLEM (N):",I14/                 &
     &    5X,"ABSOLUTE PRECISION ON X (DXMIN):",9X,1PE9.2/        &
     &    5X,"EXPECTED DECREASE FOR F (DF1):",11X,1PE9.2/         &
     &    5X,"RELATIVE PRECISION ON G (EPSG):",10X,1PE9.2,        &
     &       " (",A3,"-NORM)"/                                    &
     &    5X,"MAXIMAL NUMBER OF ITERATIONS (NITER):",I6/          &
     &    5X,"MAXIMAL NUMBER OF SIMULATIONS (NSIM):",I6/          &
     &    5X,"PRINTING LEVEL (IMPRES):",15X,I4)')                 &
     &  NA,DXMIN,DF1,EPSG,NORMTYPE,NITER,NSIM,IMPRES
   IF (REVERSE.GT.0) THEN
       WRITE (IO,'(5X,A)') "REVERSE COMMUNICATION"
   ELSE
       WRITE (IO,'(5X,A)') "DIRECT COMMUNICATION"
   ENDIF
  ENDIF
ENDBLOCK
!
!---- CHECK THE ARGUMENTS
!
IF (N.LE.0) THEN
    OMODE=2
    IF (REVERSE.GT.0) REVERSE = -1
    IF (IMPRES.GE.1) WRITE (IO,'(/A)') " >>> M1QN3: N SHOULD BE > 0"
    RETURN
ENDIF
IF (NITER.LE.0) THEN
    OMODE=2
    IF (REVERSE.GT.0) REVERSE = -1
    IF (IMPRES.GE.1) WRITE (IO,'(/A)') " >>> M1QN3: NITER SHOULD BE > 0"
    RETURN
ENDIF
IF (NSIM.LE.0) THEN
    OMODE=2
    IF (REVERSE.GT.0) REVERSE = -1
    IF (IMPRES.GE.1) WRITE (IO,'(/A)') " >>> M1QN3: NSIM SHOULD BE > 0"
    RETURN
ENDIF
IF (DXMIN.LE.0._JPRB) THEN
    OMODE=2
    IF (REVERSE.GT.0) REVERSE = -1
    IF (IMPRES.GE.1) WRITE (IO,'(/A)') " >>> M1QN3: DXMIN SHOULD BE > 0.D0"
    RETURN
ENDIF
!     IF (EPSG.LE.0.D0 .OR. EPSG.GT.1.D0) THEN
IF (EPSG.LE.0._JPRB) THEN
    OMODE=2
    IF (REVERSE.GT.0) REVERSE = -1
    IF (IMPRES.GE.1) WRITE (IO,'(/A)') " >>> M1QN3: EPSG SHOULD BE > 0.D0"
    RETURN
ENDIF
IF (EPSG.GE.1._JPRB) THEN
    OMODE=1
    NITER=0
    NSIM=0
    EPSG=1._JPRB
    IF (REVERSE.GT.0) REVERSE = -1
    IF (IMPRES.GE.1) WRITE (IO,'(/A)') " >>> M1QN3: EPSG IS >= 1.D0, NO NEED TO MAKE PROGRESS"
    GOTO 1000
ENDIF
IF ((NORMTYPE.NE.'TWO') .AND. (NORMTYPE.NE.'SUP') .AND. (NORMTYPE.NE.'DFN')) THEN
    OMODE=2
    IF (REVERSE.GT.0) REVERSE = -1
    WRITE (IO,'(/A,A,A/)') " >>> M1QN3: UNKNOWN NORM TYPE '", NORMTYPE, "'"
    RETURN
ENDIF
IF (IMPRES.LT.0) THEN
    OMODE=2
    IF (REVERSE.GT.0) REVERSE = -1
    WRITE (IO,'(/A,I0/)') " >>> M1QN3: IMPRES SHOULD BE >= 0 AND HAS THE VALUE ", IMPRES
    RETURN
ENDIF
!
!---- WHAT METHOD
!
IF (IMODE(1).EQ.0) THEN
    IF (IMPRES.GE.1) WRITE (IO,920)
920 FORMAT (/" M1QN3: DIAGONAL INITIAL SCALING MODE")
    SSCALE=.FALSE.
ELSE
    IF (IMPRES.GE.1) WRITE (IO,921)
921 FORMAT (/" M1QN3: SCALAR INITIAL SCALING MODE")
    SSCALE=.TRUE.
ENDIF
!
IF ((NDZ.LT.5*N+1).OR.((.NOT.SSCALE).AND.(NDZ.LT.6*N+1))) THEN
    OMODE=2
    IF (REVERSE.GT.0) REVERSE = -1
    IF (IMPRES.GE.1) WRITE (IO,922)
922 FORMAT (/" >>> M1QN3: NOT ENOUGH MEMORY ALLOCATED")
    RETURN
ENDIF
!
!---- COMPUTE M
!
CALL MUPDTS (YDCTX, SSCALE,INMEMO,N,M,NDZ)
!
!     --- CHECK THE VALUE OF M (IF (Y,S) PAIRS IN CORE, M WILL BE >= 1)
!
IF (M.LT.1) THEN
    OMODE=2
    IF (REVERSE.GT.0) REVERSE = -1
    IF (IMPRES.GE.1) WRITE (IO,930)
930 FORMAT (/" >>> M1QN3: M IS SET TOO SMALL IN MUPDTS")
    RETURN
ENDIF
!
!     --- MMEMO = NUMBER OF (Y,S) PAIRS IN CORE MEMORY
!
BLOCK
  INTEGER (KIND=JPIM) :: NA, NDZA
  CALL YDCTX%REDUCEI (1, (/N/), 'SUM', NA)
  CALL YDCTX%REDUCEI (1, (/NDZ/), 'SUM', NDZA)
  MMEMO=1
  IF (INMEMO) MMEMO=M
!
  NTRAVU=2*(2+MMEMO)*NA+M
  IF (SSCALE) NTRAVU=NTRAVU-NA
  IF (IMPRES.GE.1) WRITE (IO,                   &
 &      '(/5X,"ALLOCATED MEMORY (NDZ) :",I9/    &
 &         5X,"USED MEMORY :           ",I9/    &
 &         5X,"NUMBER OF UPDATES :     ",I9)')  &
 &  NDZA,NTRAVU,M
  IF (NDZA.LT.NTRAVU) THEN
      OMODE=2
      IF (REVERSE.GT.0) REVERSE = -1
      IF (IMPRES.GE.1) WRITE (IO,922)
      RETURN
  ENDIF
ENDBLOCK
!
IF (IMPRES.GE.1) THEN
    IF (INMEMO) THEN
        WRITE (IO,932)
    ELSE
        WRITE (IO,933)
    ENDIF
ENDIF
932 FORMAT (5X,"(Y,S) PAIRS ARE STORED IN CORE MEMORY")
933 FORMAT (5X,"(Y,S) PAIRS ARE STORED BY THE USER")
!
!---- COLD START OR WARM RESTART ?
!     CHECK IZ: IZ(1)=N, IZ(2)=(0 IF DIS, 1 IF SIS),
!               IZ(3)=M, IZ(4)=JMIN, IZ(5)=JMAX
!
IF (IMODE(2).EQ.0) THEN
    IF (IMPRES.GE.1) WRITE (IO,940)
ELSE
    IF (IZ(1).NE.N .OR. IZ(2).NE.IMODE(1) .OR. IZ(3).NE.M       &
&.OR.   IZ(4).LT.1 .OR. IZ(5).LT.0        .OR. IZ(4).GT.IZ(3)   &
&.OR.   IZ(5).GT.IZ(3)) THEN
      OMODE=2
      IF (REVERSE.GT.0) REVERSE = -1
      IF (IMPRES.GE.1) THEN
          WRITE (IO,941)
          IF (IZ(1).NE.N) WRITE (IO,942)
          IF (IZ(2).NE.IMODE(1)) WRITE (IO,943)
          IF (IZ(3).NE.M) WRITE (IO,944)
          IF (IZ(4).LT.1 .OR. IZ(5).LT.0 .OR. IZ(4).GT.IZ(3) .OR. IZ(5).GT.IZ(3)) WRITE (IO,945)
      ENDIF
      RETURN
    ENDIF
    IF (IMPRES.GE.1) WRITE (IO,946)
ENDIF
940 FORMAT (/" M1QN3: COLD START"/1X)
941 FORMAT (/" >>> M1QN3: INCONSISTENT WARM RESTART ")
942 FORMAT (" >>> M1QN3: (THE NUMBER OF VARIABLES HAS CHANGED)")
943 FORMAT (" >>> M1QN3: (THE SCALING MODE HAS CHANGED)")
944 FORMAT (" >>> M1QN3: (THE NUMBER OF UPDATES HAS CHANGED)")
945 FORMAT (" >>> M1QN3: (WRONG POINTERS)")
946 FORMAT (/" M1QN3: WARM RESTART"/1X)
IZ(1)=N
IZ(2)=0
IF (SSCALE) IZ(2)=1
IZ(3)=M
!
!---- SPLIT THE WORKING ZONE DZ
!
IDIAG=1
IYBAR=IDIAG+N
IF (SSCALE) IYBAR=1
ISBAR=IYBAR+N*MMEMO
ID=ISBAR+N*MMEMO
IGG=ID+N
IAUX=IGG+N
IALPHA=IAUX+N
!
!---- CALL THE OPTIMIZATION CODE
!
9999 CONTINUE
CALL M1QN3A (YDCTX,N,X,F,G,DXMIN,DF1,EPSG, &
&    NORMTYPE,IMPRES,IO,IMODE,OMODE,NITER, &
&    NSIM,INMEMO,                          &
&    IZ(3),IZ(4),IZ(5),DZ(ID),DZ(IGG),     &
&    DZ(IDIAG),DZ(IAUX),                   &
&    DZ(IALPHA),DZ(IYBAR),DZ(ISBAR),       &
&    REVERSE,YDCTX%REENTRY,INDIC)  
IF (YDCTX%REENTRY.GT.0) RETURN
!
!---- IMPRESSIONS FINALES
!
1000 CONTINUE
IF (IMPRES.GE.1) WRITE (IO,960) OMODE,NITER,NSIM,EPSG
960 FORMAT (/1X,79("-")/                      &
&           /" M1QN3: OUTPUT MODE IS ",I2     &
&           /5X,"NUMBER OF ITERATIONS: ",I14  &
&           /5X,"NUMBER OF SIMULATIONS: ",I13 &
&           /5X,"REALIZED RELATIVE PRECISION ON G: ",1PE9.2)
IF (NORMTYPE.EQ.'TWO') THEN
    GNORM = SQRT(DDOT(N,G,1,G,1))
ELSEIF (NORMTYPE.EQ.'SUP') THEN
    GNORM = DNRMI(YDCTX,N,G)
ELSEIF (NORMTYPE.EQ.'DFN') THEN
    CALL YDCTX%PROSCA (N,G,G,PS)
    GNORM=SQRT(PS)
ENDIF

IF (IMPRES.GE.1) WRITE (IO,961) F,NORMTYPE,GNORM
961 FORMAT (5X,"F             = ",1PE15.8 &
&          /5X,A3,"-NORM OF G = ",1PE15.8)
RETURN
END SUBROUTINE
!
!--------0---------0---------0---------0---------0---------0---------0--
!
SUBROUTINE M1QN3A (YDCTX,N,X,F,G,DXMIN,DF1,           &
&   EPSG,NORMTYPE,IMPRES,IO,IMODE,OMODE,NITER,NSIM,   &
&   INMEMO,M,JMIN,JMAX,D,GG,DIAG,AUX,ALPHA,YBAR,      &
&   SBAR,REVERSE,REENTRY,INDIC)
!----
!
!     CODE D OPTIMISATION PROPREMENT DIT.
!
!----
!
IMPLICIT NONE
!
!         ARGUMENTS
!
LOGICAL INMEMO
CHARACTER (LEN=3) NORMTYPE
INTEGER (KIND=JPIM) :: N,IMPRES,IO,IMODE(3),OMODE,NITER,NSIM,M,JMIN,JMAX,INDIC,REVERSE,REENTRY
REAL (KIND=JPRB) :: X(N),F,G(N),DXMIN,DF1,EPSG,D(N),GG(N),DIAG(N), &
&    AUX(N),ALPHA(M),YBAR(N,1),SBAR(N,1)
CLASS (M1QN3CTX) :: YDCTX
!
!         VARIABLES LOCALES
!
LOGICAL SSCALE,COLD,WARM,SKIP_UPDATE
INTEGER (KIND=JPIM) :: I,ITMAX,MODERL,ISIM,JCOUR
REAL (KIND=JPRB) :: D1,T,TMIN,TMAX,GNORM,GNORMS,EPS1,FF,PRECO,PRECOS,YS,DEN,DK,DK1,PS,PS2,HP0
!
!         PARAMETRES
!
REAL (KIND=JPRB) :: RM1,RM2
PARAMETER (RM1=0.0001D+0,RM2=0.99D+0)
REAL (KIND=JPRB) :: PI
PARAMETER (PI=3.1415927D+0)
REAL (KIND=JPRB) :: RMIN
!
!         FUNCTION
!
REAL (KIND=JPRB) :: DDOT
!
! --- POSSIBLE JUMPS
!     9998: CALL OF THE SIMULATOR IN M1QN3A WITH INDIC = 1
!     9999: CALL OF THE SIMULATOR IN MLIS3 WITH INDIC = 4
!
IF (REENTRY.EQ.1) GOTO 9998
IF (REENTRY.EQ.2) GOTO 9999
!
!---- INITIALISATION
!
RMIN=1.D-20
!
SSCALE=.TRUE.
IF (IMODE(1).EQ.0) SSCALE=.FALSE.
!
WARM=.FALSE.
IF (IMODE(2).EQ.1) WARM=.TRUE.
COLD=.NOT.WARM
!
SKIP_UPDATE = .FALSE.
!
ITMAX=NITER
NITER=0
ISIM=1
EPS1=1.D+0
!
CALL YDCTX%PROSCA (N,G,G,PS)
GNORM = SQRT(PS)
IF (NORMTYPE.EQ.'TWO') THEN
    GNORMS = SQRT(DDOT(N,G,1,G,1))
ELSEIF (NORMTYPE.EQ.'SUP') THEN
    GNORMS = DNRMI(YDCTX,N,G)
ELSEIF (NORMTYPE.EQ.'DFN') THEN
    GNORMS = GNORM
ENDIF
IF (IMPRES.GE.1) WRITE (IO,900) F,NORMTYPE,GNORMS
900 FORMAT (5X,"F             = ",1PE15.8 &
&          /5X,A3,"-NORM OF G = ",1PE15.8)
IF (GNORMS.LT.RMIN) THEN
    OMODE=2
    IF (IMPRES.GE.1) WRITE (IO,901)
    GOTO 1000
ENDIF
901 FORMAT (/" >>> M1QN3A: INITIAL GRADIENT IS TOO SMALL")
!
!     --- INITIALISATION POUR DD
!
IF (COLD) THEN
    JMIN=1
    JMAX=0
ENDIF
JCOUR=1
IF (INMEMO) JCOUR=JMAX
!
!     --- MISE A L'ECHELLE DE LA PREMIERE DIRECTION DE DESCENTE
!
IF (COLD) THEN
!
!         --- USE FLETCHER'S SCALING AND INITIALIZE DIAG TO 1.
!
  PRECOS=2.D+0*DF1/GNORM**2
  DO I=1,N
      D(I)=-G(I)*PRECOS
      DIAG(I)=1.D+0
  ENDDO
  IF (IMPRES.GE.5) WRITE(IO,902) PRECOS
902 FORMAT (/" M1QN3A: DESCENT DIRECTION -G: PRECON = ",E10.3)
ELSE
!
!         --- USE THE MATRIX STORED IN [DIAG AND] THE (Y,S) PAIRS
!
  IF (SSCALE) THEN
      CALL YDCTX%PROSCA (N,YBAR(1,JCOUR),YBAR(1,JCOUR), PS)
      PRECOS=1.D+0/PS
  ENDIF
  DO I=1,N
      D(I)=-G(I)
  ENDDO
  IF (INMEMO) THEN
      CALL DD (YDCTX,IMPRES,N,SSCALE,M,D,AUX,JMIN,JMAX, &
&                 PRECOS,DIAG,ALPHA,YBAR,SBAR)
  ELSE
      CALL DDS (YDCTX,IMPRES,N,SSCALE,M,D,AUX,JMIN,JMAX, &
&                  PRECOS,DIAG,ALPHA,YBAR,SBAR)
  ENDIF
ENDIF
!
IF (IMPRES.EQ.3) WRITE(IO,903)
IF (IMPRES.EQ.4) WRITE(IO,903)
903 FORMAT (/1X,79("-"))
904 FORMAT (1X)
!
!     --- INITIALISATION POUR MLIS3
!
TMAX=1.D+20
CALL YDCTX%PROSCA (N,D,G,HP0)
IF (HP0.GE.0.D+0) THEN
    OMODE=7
    IF (IMPRES.GE.1) WRITE (IO,905) NITER,HP0
    GOTO 1000
ENDIF
905 FORMAT (/" >>> M1QN3 (ITERATION ",I2,"): "        &
&           /5X," THE SEARCH DIRECTION D IS NOT A ",  &
&            "DESCENT DIRECTION: (G,D) = ",E12.5)
!
!     --- COMPUTE THE ANGLE (-G,D)
!
IF (WARM.AND.IMPRES.GE.5) THEN
    CALL YDCTX%PROSCA (N,G,G,PS)
    PS=SQRT(PS)
    CALL YDCTX%PROSCA (N,D,D,PS2)
    PS2=SQRT(PS2)
    PS=HP0/PS/PS2
    PS=MIN(-PS,1.D+0)
    PS=ACOS(PS)
    D1=PS*180.D+0/PI
    WRITE (IO,906) REAL(D1)
ENDIF
906 FORMAT (/" M1QN3: DESCENT DIRECTION D: ", &
&            "ANGLE(-G,D) = ",F5.1," DEGREES")
!
!---- DEBUT DE L ITERATION. ON CHERCHE X(K+1) DE LA FORME X(K) + T*D,
!     AVEC T > 0. ON CONNAIT D.
!
!         DEBUT DE LA BOUCLE: ETIQUETTE 100,
!         SORTIE DE LA BOUCLE: GOTO 1000.
!
100   NITER=NITER+1
IF (IMPRES.GE.5) WRITE(IO,903)
IF (IMPRES.GE.4) WRITE(IO,904)
IF (IMPRES.GE.4) WRITE (IO,910) NITER,ISIM,F,HP0
910 FORMAT (" M1QN3: ITER ",I0,", SIMUL ",I0, &
&        ", F=",1PE15.8,", H'(0)=",E12.5)
!
!     --- FREE SIMULATION IF DESIRED
!
IF (IMODE(3).GT.0) THEN
    IF (MOD(NITER-1,IMODE(3)).EQ.0) THEN
        INDIC=1
        IF (REVERSE.GT.0) THEN
            REENTRY = 1
            RETURN
        ELSE
            CALL YDCTX%SIMUL(INDIC,N,X,F,G)
        ENDIF
    ENDIF
ENDIF
9998 CONTINUE
!
!     --- RECHERCHE LINEAIRE ET NOUVEAU POINT X(K+1)
!
DO I=1,N
    GG(I)=G(I)
ENDDO
FF=F
IF (IMPRES.GE.5) WRITE (IO,911)
911 FORMAT (/" M1QN3: LINE SEARCH")
!
!         --- CALCUL DE TMIN
!
CALL YDCTX%REDUCER (N, ABS (D), 'MAX', TMIN)
TMIN = MAX (0.D+0, TMIN)
TMIN=DXMIN/TMIN
T=1.D+0
D1=HP0
!
9999 CONTINUE
CALL MLIS3 (N,YDCTX,X,F,D1,T,TMIN,TMAX,D,G,RM2,RM1,IMPRES, &
&            IO,MODERL,ISIM,NSIM,AUX,REVERSE,REENTRY,INDIC)
IF (REENTRY.GT.0) RETURN
!
!         --- MLIS3 RENVOIE LES NOUVELLES VALEURS DE X, F ET G
!
IF (MODERL.NE.0) THEN
    IF (MODERL.LT.0) THEN
!
!             --- CALCUL IMPOSSIBLE
!                 T, G: OU LES CALCULS SONT IMPOSSIBLES
!                 X, F: CEUX DU T_GAUCHE (DONC F <= FF)
!
        OMODE=MODERL
        GOTO 1000
    ELSEIF (MODERL.EQ.1) THEN
!
!             --- DESCENTE BLOQUEE SUR TMAX
!
SKIP_UPDATE = .TRUE.
!             OMODE=3
!             IF (IMPRES.GE.1) WRITE(IO,912) NITER
! 912         FORMAT (/" >>> M1QN3 (ITERATION ",I0,
!    &                "): LINE SEARCH BLOCKED ON TMAX: "/
!    &                " >>> POSSIBLE REASONS: BAD SCALING,",
!    &                " UNBOUNDED PROBLEM")
    ELSEIF (MODERL.EQ.4) THEN
!
!             --- NSIM ATTEINT
!                 X, F: CEUX DU T_GAUCHE (DONC F <= FF)
!
        OMODE=5
        GOTO 1000
    ELSEIF (MODERL.EQ.5) THEN
!
!             --- ARRET DEMANDE PAR L UTILISATEUR (INDIC = 0)
!                 X, F: CEUX EN SORTIE DU SIMULATEUR
!
        OMODE=0
        GOTO 1000
    ELSEIF (MODERL.EQ.6) THEN
!
!             --- ARRET SUR DXMIN OU APPEL INCOHERENT
!                 X, F: CEUX DU T_GAUCHE (DONC F <= FF)
!
        OMODE=6
        GOTO 1000
    ENDIF
ELSE
    SKIP_UPDATE = .FALSE.
ENDIF
!
! NOTE: STOPPING TESTS ARE NOW DONE AFTER HAVING UPDATED THE MATRIX, SO
! THAT UPDATE INFORMATION CAN BE STORED IN CASE OF A LATER WARM RESTART
!
!     --- MISE A JOUR DE LA MATRICE
!
IF (SKIP_UPDATE) THEN
    IF (IMPRES.GE.5) WRITE(IO,'(/A)') " M1QN3: MATRIX UPDATE IS SKIPPED"
ELSEIF (M.GT.0) THEN
!
!         --- MISE A JOUR DES POINTEURS
!
  JMAX=JMAX+1
  IF (JMAX.GT.M) JMAX=JMAX-M
  IF ((COLD.AND.NITER.GT.M).OR.(WARM.AND.JMIN.EQ.JMAX)) THEN
      JMIN=JMIN+1
      IF (JMIN.GT.M) JMIN=JMIN-M
  ENDIF
  IF (INMEMO) JCOUR=JMAX
!
!         --- Y, S ET (Y,S)
!
DO I=1,N
    SBAR(I,JCOUR)=T*D(I)
    YBAR(I,JCOUR)=G(I)-GG(I)
ENDDO
IF (IMPRES.GE.5) THEN
    CALL YDCTX%PROSCA (N,SBAR(1,JCOUR),SBAR(1,JCOUR),PS)
    DK1=SQRT(PS)
    IF (NITER.GT.1) WRITE (IO,930) DK1/DK
930 FORMAT (/" M1QN3: CONVERGENCE RATE, S(K)/S(K-1) = ",1PE12.5)
    DK=DK1
ENDIF
CALL YDCTX%PROSCA (N,YBAR(1,JCOUR),SBAR(1,JCOUR),YS)
IF (YS.LE.0.D+0) THEN
    OMODE=7
    IF (IMPRES.GE.1) WRITE (IO,931) NITER,YS
931 FORMAT (/" >>> M1QN3 (ITERATION ",I2,              &
&            "): THE SCALAR PRODUCT (Y,S) = ",E12.5    &
&            /27X,"IS NOT POSITIVE")
    GOTO 1000
ENDIF
!
!         --- YBAR ET SBAR
!
D1=SQRT(1.D+0/YS)
DO I=1,N
    SBAR(I,JCOUR)=D1*SBAR(I,JCOUR)
    YBAR(I,JCOUR)=D1*YBAR(I,JCOUR)
ENDDO
IF (.NOT.INMEMO) CALL YSTBL (.TRUE.,YBAR,SBAR,N,JMAX)
!
!         --- COMPUTE THE SCALAR OR DIAGONAL PRECONDITIONER
!
IF (IMPRES.GE.5) WRITE(IO,932)
932 FORMAT (/" M1QN3: MATRIX UPDATE:")
!
!             --- HERE IS THE OREN-SPEDICATO FACTOR, FOR SCALAR SCALING
!
IF (SSCALE) THEN
    CALL YDCTX%PROSCA (N,YBAR(1,JCOUR),YBAR(1,JCOUR),PS)
    PRECOS=1.D+0/PS
!
    IF (IMPRES.GE.5) WRITE (IO,933) PRECOS
933 FORMAT (5X,"OREN-SPEDICATO FACTOR = ",E10.3)
!
!             --- SCALE THE DIAGONAL TO RAYLEIGH S ELLIPSOID.
!                 INITIALLY (NITER.EQ.1) AND FOR A COLD START, THIS IS
!                 EQUIVALENT TO AN OREN-SPEDICATO SCALING OF THE
!                 IDENTITY MATRIX.
!
ELSE
    CALL YDCTX%CTONB (N,YBAR(1,JCOUR),AUX)
    CALL YDCTX%EUCLID (N,DIAG,AUX*AUX,PS)
    D1=1._JPRB/PS
    IF (IMPRES.GE.5) THEN
        WRITE (IO,934) D1
934 FORMAT(5X,"FITTING THE ELLIPSOID: FACTOR = ",1PE10.3)
    ENDIF
    DO I=1,N
        DIAG(I)=DIAG(I)*D1
    ENDDO
!
!             --- UPDATE THE DIAGONAL
!                 (GG IS USED AS AN AUXILIARY VECTOR)
!
    CALL YDCTX%CTONB (N,SBAR(1,JCOUR),GG)
    CALL YDCTX%EUCLID (N,GG,GG/DIAG,PS)
    DEN=PS
    DO I=1,N
        DIAG(I)=1._JPRB/(1._JPRB/DIAG(I)+AUX(I)**2-(GG(I)/DIAG(I))**2/DEN)
        IF (DIAG(I).LE.0._JPRB) THEN
            IF (IMPRES.GE.5) WRITE (IO,935) I,DIAG(I),RMIN
            DIAG(I)=RMIN
        ENDIF
    ENDDO
935 FORMAT (/" >>> M1QN3-WARNING: DIAGONAL ELEMENT ",I8," IS NEGATIVE (",E10.3,"), RESET TO ",E10.3)
!
    IF (IMPRES.GE.5) THEN
        CALL YDCTX%REDUCER(N,DIAG,'AVG',PS)
        PRECO=PS
!
        CALL YDCTX%REDUCER (N,(DIAG-PS)**2,'AVG',PS2)
        PS2=SQRT(PS2)
        WRITE (IO,936) PRECO,PS2
936 FORMAT (5X,"UPDATED DIAGONAL: AVERAGE VALUE = ",1PE10.3,", SQRT(VARIANCE) = ",E10.3)
        ENDIF
    ENDIF
ENDIF
!
!     --- PRINTINGS
!
!
!     --- TESTS D ARRET
!
CALL YDCTX%PROSCA(N,G,G,PS)
IF (NORMTYPE.EQ.'TWO') THEN
    GNORM = SQRT(DDOT(N,G,1,G,1))
ELSEIF (NORMTYPE.EQ.'SUP') THEN
    GNORM = DNRMI(YDCTX,N,G)
ELSEIF (NORMTYPE.EQ.'DFN') THEN
    GNORM = SQRT(PS)
ENDIF
EPS1 = GNORM/GNORMS
!
IF (IMPRES.EQ.3) THEN
    IF (MOD(NITER-1,50).EQ.0) WRITE(IO,'(/A,A)')                    &
&        "  ITER  SIMUL  STEPSIZE            F                |G|",  &
&        "       |G|/|G0|" 
    WRITE(IO,                                                   &
&        '(1X,I5,2X,I5,2X,1PE8.2,2X,E21.14,2X,E11.5,2X,E10.4)')  &
&        NITER, ISIM, T, F, GNORM, EPS1
ENDIF
IF (IMPRES.GE.5) WRITE (IO,940) EPS1
940 FORMAT (/" M1QN3: STOPPING CRITERION ON G: ",1PE12.5)
IF (EPS1.LT.EPSG) THEN
    OMODE=1
    GOTO 1000
ENDIF
IF (NITER.EQ.ITMAX) THEN
    OMODE=4
    IF (IMPRES.GE.1) WRITE (IO,941) NITER
941 FORMAT (/" >>> M1QN3 (ITERATION ",I0,"): MAXIMAL NUMBER OF ITERATIONS")
    GOTO 1000
ENDIF
IF (ISIM.GT.NSIM) THEN
    OMODE=5
    IF (IMPRES.GE.1) WRITE (IO,942) NITER,ISIM
942 FORMAT (/" >>> M1QN3 (ITERATION ",I3,"): ",I6," SIMULATIONS (MAXIMAL NUMBER REACHED)")
    GOTO 1000
ENDIF
!
!     --- CALCUL DE LA NOUVELLE DIRECTION DE DESCENTE D = - H.G
!
IF (M.EQ.0) THEN
    PRECO=2._JPRB*(FF-F)/PS
    DO I=1,N
        D(I)=-G(I)*PRECO
    ENDDO
ELSE
    DO I=1,N
        D(I)=-G(I)
    ENDDO
    IF (INMEMO) THEN
        CALL DD (YDCTX,IMPRES,N,SSCALE,M,D,AUX,JMIN,JMAX,PRECOS,DIAG,ALPHA,YBAR,SBAR)
    ELSE
        CALL DDS (YDCTX,IMPRES,N,SSCALE,M,D,AUX,JMIN,JMAX,PRECOS,DIAG,ALPHA,YBAR,SBAR)
    ENDIF
ENDIF
!
!         --- TEST: LA DIRECTION D EST-ELLE DE DESCENTE ?
!             HP0 SERA UTILISE PAR MLIS3
!
CALL YDCTX%PROSCA (N,D,G,HP0)
IF (HP0.GE.0.D+0) THEN
    OMODE=7
    IF (IMPRES.GE.1) WRITE (IO,905) NITER,HP0
    GOTO 1000
ENDIF
IF (IMPRES.GE.5) THEN
    CALL YDCTX%PROSCA (N,G,G,PS)
    PS=SQRT(PS)
    CALL YDCTX%PROSCA (N,D,D,PS2)
    PS2=SQRT(PS2)
    PS=HP0/PS/PS2
    PS=MIN(-PS,1.D+0)
    PS=ACOS(PS)
    D1=PS
    D1=D1*180._JPRB/PI
    WRITE (IO,906) REAL(D1)
ENDIF
!
!---- ON POURSUIT LES ITERATIONS
!
      GOTO 100
!
! --- N1QN3 HAS FINISHED FOR EVER
!
1000 CONTINUE
IF (REVERSE.NE.0) REVERSE = -1
REENTRY = 0
NSIM=ISIM
EPSG=EPS1
RETURN
END SUBROUTINE
!
!--------0---------0---------0---------0---------0---------0---------0--
!
SUBROUTINE DD (YDCTX,IMPRES,N,SSCALE,NM,DEPL,AUX,JMIN,JMAX, &
&                PRECOS,DIAG,ALPHA,YBAR,SBAR)
!----
!
!     CALCULE LE PRODUIT H.G OU
!         . H EST UNE MATRICE CONSTRUITE PAR LA FORMULE DE BFGS INVERSE
!           A NM MEMOIRES A PARTIR DE LA MATRICE DIAGONALE DIAG
!           DANS UN ESPACE HILBERTIEN DONT LE PRODUIT SCALAIRE
!           EST DONNE PAR PROSCA
!           (CF. J. NOCEDAL, MATH. OF COMP. 35/151 (1980) 773-782)
!         . G EST UN VECTEUR DE DIMENSION N (EN GENERAL LE GRADIENT)
!
!     LA MATRICE DIAG APPARAIT DONC COMME UN PRECONDITIONNEUR DIAGONAL
!
!     DEPL = G (EN ENTREE), = H G (EN SORTIE)
!
!     LA MATRICE H EST MEMORISEE PAR LES VECTEURS DES TABLEAUX
!     YBAR, SBAR ET LES POINTEURS JMIN, JMAX
!
!     ALPHA(NM) EST UNE ZONE DE TRAVAIL
!
!     IZS(*),RZS(*),DZS(*) SONT DES ZONES DE TRAVAIL POUR PROSCA
!
!----
!
IMPLICIT NONE
!
!         ARGUMENTS
!
LOGICAL SSCALE
INTEGER (KIND=JPIM) :: N,NM,JMIN,JMAX
INTEGER (KIND=JPIM) :: IMPRES
REAL (KIND=JPRB) :: DEPL(N),PRECOS,DIAG(N),ALPHA(NM),YBAR(N,1),SBAR(N,1),AUX(N)
CLASS (M1QN3CTX) :: YDCTX
!
!         VARIABLES LOCALES
!
INTEGER (KIND=JPIM) :: JFIN,I,J,JP
REAL (KIND=JPRB) :: R,PS
!
JFIN=JMAX
IF (JFIN.LT.JMIN) JFIN=JMAX+NM
!
!         PHASE DE DESCENTE
!
DO J=JFIN,JMIN,-1
    JP=J
    IF (JP.GT.NM) JP=JP-NM
    CALL YDCTX%PROSCA (N,DEPL,SBAR(1,JP),PS)
    R=PS
    ALPHA(JP)=R
    DO I=1,N
        DEPL(I)=DEPL(I)-R*YBAR(I,JP)
    ENDDO
ENDDO
!
!         PRECONDITIONNEMENT
!
IF (SSCALE) THEN
    DO I=1,N
        DEPL(I)=DEPL(I)*PRECOS
    ENDDO
ELSE
    CALL YDCTX%CTONB (N,DEPL,AUX)
    DO I=1,N
        AUX(I)=AUX(I)*DIAG(I)
    ENDDO
    CALL YDCTX%CTCAB (N,AUX,DEPL)
ENDIF
!
!         REMONTEE
!
DO J=JMIN,JFIN
    JP=J
    IF (JP.GT.NM) JP=JP-NM
    CALL YDCTX%PROSCA (N,DEPL,YBAR(1,JP),PS)
    R=ALPHA(JP)-PS
    DO I=1,N
        DEPL(I)=DEPL(I)+R*SBAR(I,JP)
    ENDDO
ENDDO
RETURN
END SUBROUTINE
!
!--------0---------0---------0---------0---------0---------0---------0--
!
SUBROUTINE DDS (YDCTX,IMPRES,N,SSCALE,NM,DEPL,AUX,JMIN, &
&                 JMAX,PRECOS,DIAG,ALPHA,YBAR,SBAR)
!----
!
!     THIS SUBROUTINE HAS THE SAME ROLE AS DD (COMPUTATION OF THE
!     PRODUCT H.G). IT SUPPOSES HOWEVER THAT THE (Y,S) PAIRS ARE NOT
!     STORED IN CORE MEMORY, BUT ON A DEVISE CHOSEN BY THE USER.
!     THE ACCESS TO THIS DEVISE IS PERFORMED VIA THE SUBROUTINE YSTBL.
!
!----
!
IMPLICIT NONE
!
!         ARGUMENTS
!
LOGICAL SSCALE
INTEGER (KIND=JPIM) :: N,NM,JMIN,JMAX,IMPRES
REAL (KIND=JPRB) :: DEPL(N),PRECOS,DIAG(N),ALPHA(NM),YBAR(N),SBAR(N),AUX(N)
CLASS (M1QN3CTX) :: YDCTX
!
!         VARIABLES LOCALES
!
INTEGER (KIND=JPIM) :: JFIN,I,J,JP
REAL (KIND=JPRB) :: R,PS
!
JFIN=JMAX
IF (JFIN.LT.JMIN) JFIN=JMAX+NM
!
!         PHASE DE DESCENTE
!
DO J=JFIN,JMIN,-1
    JP=J
    IF (JP.GT.NM) JP=JP-NM
    CALL YSTBL (.FALSE.,YBAR,SBAR,N,JP)
    CALL YDCTX%PROSCA (N,DEPL,SBAR,PS)
    R=PS
    ALPHA(JP)=R
    DO I=1,N
        DEPL(I)=DEPL(I)-R*YBAR(I)
    ENDDO
ENDDO
!
!         PRECONDITIONNEMENT
!
IF (SSCALE) THEN
    DO I=1,N
        DEPL(I)=DEPL(I)*PRECOS
    ENDDO
ELSE
    CALL YDCTX%CTONB (N,DEPL,AUX)
    DO I=1,N
        AUX(I)=AUX(I)*DIAG(I)
    ENDDO
    CALL YDCTX%CTCAB (N,AUX,DEPL)
ENDIF
!
!         REMONTEE
!
DO J=JMIN,JFIN
    JP=J
    IF (JP.GT.NM) JP=JP-NM
    CALL YSTBL (.FALSE.,YBAR,SBAR,N,JP)
    CALL YDCTX%PROSCA (N,DEPL,YBAR(1),PS)
    R=ALPHA(JP)-PS
    DO I=1,N
        DEPL(I)=DEPL(I)+R*SBAR(I)
    ENDDO
ENDDO
RETURN
END SUBROUTINE
!
!--------0---------0---------0---------0---------0---------0---------0--
!
SUBROUTINE MLIS3 (N,YDCTX,X,F,FPN,T,TMIN,TMAX,D,G, &
&                  AMD,AMF,IMP,IO,LOGIC,NAP,NAPMAX,XN, &
&                  REVERSE,REENTRY,INDIC)
!
! ----
!
!     MLIS3 + MINUSCULES + COMMENTAIRES
!     + VERSION AMELIOREE (XII 88): INTERPOLATION CUBIQUE SYSTEMATIQUE
!       ET ANTI-OVERFLOWS
!     + DECLARATION VARIABLES (II/89, JCG).
!     + BARR IS ALSO PROGRESSIVELY DECREASED (12/93, CL & JCHG).
!       BARMUL IS SET TO 5.
!
!     ----------------------------------------------------------------
!
!        EN SORTIE LOGIC =
!
!        0          DESCENTE SERIEUSE
!        1          DESCENTE BLOQUEE SUR TMAX
!        4          NAP > NAPMAX
!        5          ARRET DEMANDE PAR LE SIMULATEUR
!        6          FONCTION ET GRADIENT PAS D ACCORD
!        < 0        CONTRAINTE IMPLICITE ACTIVE
!
!     INDIC ON ENTRY (IN REVERSE COMMUNICATION)
!
!       < 0: THE SIMULATOR CANNOT COMPUTE F AND G
!       = 0: THE SIMULATOR WANTS TO STOP
!       > 0: THE SIMULATOR HAS DONE ITS WORK
!
!     INDIC ON RETURN (IN REVERSE COMMUNICATION)
!
!       = 4: THE SIMULATOR IS ASKED TO COMPUTE F AND G
!
!     REVERSE
!
!       = 0: DIRECT COMMUNICATION
!       = 1: REVERSE COMMUNICATION
!
!     REENTRY ON ENTRY
!
!       = 2: REVERSE COMMUNICATION, RETURN FROM A SIMULATION, SKIP TO
!            THE PLACE WHERE THE SIMULATOR WAS CALLED (9999)
!
!     REENTRY RETURN
!
!       = 0: REVERSE COMMUNICATION, THE LINESEARCH HAS FINISHED ITS JOB
!       = 2: REVERSE COMMUNICATION, A SIMULATION IS REQUIRED
!
! ----
!
IMPLICIT NONE
!
! --- ARGUMENTS
!
CLASS (M1QN3CTX) :: YDCTX
INTEGER (KIND=JPIM) :: N,IMP,IO,LOGIC,NAP,NAPMAX,INDIC,REVERSE,REENTRY
REAL (KIND=JPRB) :: X(N),F,FPN,T,TMIN,TMAX,D(N),G(N),AMD,AMF,XN(N)
!
! --- VARIABLES LOCALES
!
LOGICAL T_INCREASED
INTEGER (KIND=JPIM) :: I,INDICA,INDICD
REAL (KIND=JPRB) :: TESF,TESD,TG,FG,FPG,TD,TA,FA,FPA,D2,FN,FP,FFN,FD, &
&     FPD,Z,TEST,BARMIN,BARMUL,BARMAX,BARR,GAUCHE,DROITE,TAA,PS
!
1000 FORMAT (/4X," MLIS3   ",4X,"FPN=",1PE10.3," D2=",E9.2,"  TMIN=",E9.2," TMAX=",E9.2)
1001 FORMAT (/4X," MLIS3",3X,"STOP ON TMIN",5X,"STEPSIZES",11X,"FUNCTIONS",8X,"DERIVATIVES")
1002 FORMAT (4X," MLIS3",37X,1PE10.3,2E11.3)
1003 FORMAT (4X," MLIS3",1PE14.3,2E11.3)
1004 FORMAT (4X," MLIS3",37X,1PE10.3," INDIC=",I3)
1005 FORMAT (4X," MLIS3",14X,1PE18.8,2X,E21.14,2X,E11.4)
1006 FORMAT (4X," MLIS3",14X,1PE18.8,"      INDIC=",I3)
1007 FORMAT (/4X," MLIS3",10X,"TMIN FORCED TO TMAX")
1008 FORMAT (/4X," MLIS3",10X,"INCONSISTENT CALL")
!
! --- POSSIBLE JUMP
!
IF (REENTRY.EQ.2) GOTO 9999
!
IF (N.GT.0 .AND. FPN.LT.0._JPRB .AND. T.GT.0._JPRB &
& .AND. TMAX.GT.0._JPRB .AND. AMF.GT.0._JPRB &
& .AND. AMD.GT.AMF .AND. AMD.LT.1._JPRB) GO TO 5
LOGIC=6
GO TO 999
5 TESF=AMF*FPN
TESD=AMD*FPN
BARMIN=0.01_JPRB
BARMUL=5._JPRB
BARMAX=0.3_JPRB
BARR=BARMIN
TD=0._JPRB
TG=0._JPRB
FN=F
FG=FN
FPG=FPN
TA=0._JPRB
FA=FN
FPA=FPN
CALL YDCTX%PROSCA (N,D,D,PS)
D2=PS
!
!               ELIMINATION D UN T INITIAL RIDICULEMENT PETIT
!
!<
!     IF (T.GT.TMIN) GO TO 20
!     T=TMIN
!     IF (T.LE.TMAX) GO TO 20
!     IF (IMP.GT.0) WRITE (IO,1007)
!     TMIN=TMAX
!  20 IF (FN+T*FPN.LT.FN+0.9D0*T*FPN) GO TO 30
!     T=2.D0*T
!     GO TO 20
! CHANGED INTO
IF (T.LT.TMIN) THEN
    T=TMIN
    IF (IMP.GE.4) WRITE (IO,'(A)') ' MLIS3: INITIAL STEP-SIZE INCREASED TO TMIN'
    IF (T.GT.TMAX) THEN
        IF (IMP.GT.0) WRITE (IO,1007)
        TMIN=TMAX
    ENDIF
ENDIF
T_INCREASED = .FALSE.
DO WHILE (FN+T*FPN.GE.FN+0.9_JPRB*T*FPN)
    T_INCREASED = .TRUE.
    T = 2._JPRB*T
ENDDO
IF (T_INCREASED .AND. (IMP.GE.4)) WRITE (IO,'(A,1PE10.3)') ' MLIS3: INITIAL STEP-SIZE INCREASED TO ',T
!>
30 INDICA=1
LOGIC=0
IF (T.GT.TMAX) THEN
    T=TMAX
    LOGIC=1
ENDIF
IF (IMP.GE.4) WRITE (IO,1000) FPN,D2,TMIN,TMAX
!
!     --- NOUVEAU X
!         INITIALIZE XN TO THE CURRENT ITERATE
!         USE X AS THE TRIAL ITERATE
!
DO I=1,N
    XN(I)=X(I)
    X(I)=XN(I)+T*D(I)
ENDDO
!
! --- BOUCLE
!
100 NAP=NAP+1
IF(NAP.GT.NAPMAX) THEN
    LOGIC=4
    FN=FG
    DO I=1,N
        XN(I)=XN(I)+TG*D(I)
    ENDDO
    GO TO 999
ENDIF
!
!     --- APPEL SIMULATEUR
!
INDIC=4
IF (REVERSE.GT.0) THEN
    REENTRY = 2
    RETURN
ELSE
    CALL YDCTX%SIMUL(INDIC,N,X,F,G)
ENDIF
9999 CONTINUE
IF (INDIC.EQ.0) THEN
!
!         --- ARRET DEMANDE PAR L UTILISATEUR
!
    LOGIC=5
    FN=F
    DO I=1,N
        XN(I)=X(I)
    ENDDO
    GO TO 999
ENDIF
IF(INDIC.LT.0) THEN
!
!         --- LES CALCULS N ONT PAS PU ETRE EFFECTUES PAR LE SIMULATEUR
!
    TD=T
    INDICD=INDIC
    LOGIC=0
    IF (IMP.GE.4) WRITE (IO,1004) T,INDIC
    T=TG+0.1_JPRB*(TD-TG)
    GO TO 905
ENDIF
!
!     --- LES TESTS ELEMENTAIRES SONT FAITS, ON Y VA
!
CALL YDCTX%PROSCA (N,D,G,PS)
FP=PS
!
!     --- PREMIER TEST DE WOLFE
!
FFN=F-FN
IF(FFN.GT.T*TESF) THEN
    TD=T
    FD=F
    FPD=FP
    INDICD=INDIC
    LOGIC=0
    IF(IMP.GE.4) WRITE (IO,1002) T,FFN,FP
    GO TO 500
ENDIF
!
!     --- TEST 1 OK, DONC DEUXIEME TEST DE WOLFE
!
IF(IMP.GE.4) WRITE (IO,1003) T,FFN,FP
IF(FP.GT.TESD) THEN
    LOGIC=0
    GO TO 320
ENDIF
IF (LOGIC.EQ.0) GO TO 350
!
!     --- TEST 2 OK, DONC PAS SERIEUX, ON SORT
!
320 FN=F
DO I=1,N
    XN(I)=X(I)
ENDDO
GO TO 999
!
!
!
350 TG=T
FG=F
FPG=FP
IF(TD.NE.0._JPRB) GO TO 500
!
!              EXTRAPOLATION
!
TAA=T
GAUCHE=(1._JPRB+BARMIN)*T
DROITE=10._JPRB*T
CALL ECUBE (T,F,FP,TA,FA,FPA,GAUCHE,DROITE)
TA=TAA
IF(T.LT.TMAX) GO TO 900
LOGIC=1
T=TMAX
GO TO 900
!
!              INTERPOLATION
!
500 IF(INDICA.LE.0) THEN
    TA=T
    T=0.9_JPRB*TG+0.1_JPRB*TD
    GO TO 900
ENDIF
TEST=BARR*(TD-TG)
GAUCHE=TG+TEST
DROITE=TD-TEST
TAA=T
CALL ECUBE (T,F,FP,TA,FA,FPA,GAUCHE,DROITE)
TA=TAA
IF (T.GT.GAUCHE .AND. T.LT.DROITE) THEN
  BARR=MAX(BARMIN,BARR/BARMUL)
!         BARR=BARMIN
  ELSE
    BARR=MIN(BARMUL*BARR,BARMAX)
ENDIF
!
! --- FIN DE BOUCLE
!     - T PEUT ETRE BLOQUE SUR TMAX
!       (VENANT DE L EXTRAPOLATION AVEC LOGIC=1)
!
900 FA=F
FPA=FP
905 INDICA=INDIC
!
! --- FAUT-IL CONTINUER ?
!
IF (TD.EQ.0._JPRB) GO TO 950
IF (TD-TG.LT.TMIN) GO TO 920
!
!     --- LIMITE DE PRECISION MACHINE (ARRET DE SECOURS) ?
!
DO I=1,N
    Z=XN(I)+T*D(I)
    IF (Z.NE.XN(I).AND.Z.NE.X(I)) GO TO 950
ENDDO
IF (IMP.GT.3) WRITE (IO,'(5X,A)') "MLIS3   NO CHANGE IN X"
!
! --- ARRET SUR DXMIN OU DE SECOURS
!
920 LOGIC=6
!
!     SI INDICD<0, DERNIERS CALCULS NON FAITS PAR SIMUL
!
IF (INDICD.LT.0) LOGIC=INDICD
!
!     SI TG=0, XN = XN_DEPART,
!     SINON ON PREND XN=X_GAUCHE QUI FAIT DECROITRE F
!
IF (TG.EQ.0._JPRB) GO TO 940
FN=FG
DO I=1,N
  XN(I)=XN(I)+TG*D(I)
ENDDO
940 IF (IMP.LE.3) GO TO 999
WRITE (IO,1001)
WRITE (IO,1005) TG,FG,FPG
IF (LOGIC.EQ.6) WRITE (IO,1005) TD,FD,FPD
IF (LOGIC.EQ.7) WRITE (IO,1006) TD,INDICD
GO TO 999
!
!               RECOPIAGE DE X ET BOUCLE
!
950 DO I=1,N
        X(I)=XN(I)+T*D(I)
ENDDO
GO TO 100
!     --- LINESEARCH FINISHED, NO SKIP AT NEXT ENTRY IN MLIS3
999 IF (REVERSE.NE.0) REENTRY = 0
RETURN
END SUBROUTINE
!
!
!--------0---------0---------0---------0---------0---------0---------0--
!
SUBROUTINE ECUBE (T,F,FP,TA,FA,FPA,TLOWER,TUPPER)
!
IMPLICIT NONE
!
! --- ARGUMENTS
!
REAL (KIND=JPRB) :: SIGN,DEN,ANUM,T,F,FP,TA,FA,FPA,TLOWER,TUPPER
!
! --- VARIABLES LOCALES
!
REAL (KIND=JPRB) :: Z1,B,DISCRI
!
!           USING F AND FP AT T AND TA, COMPUTES NEW T BY CUBIC FORMULA
!           SAFEGUARDED INSIDE [TLOWER,TUPPER].
!
Z1=FP+FPA-3._JPRB*(FA-F)/(TA-T)
B=Z1+FP
!
!              FIRST COMPUTE THE DISCRIMINANT (WITHOUT OVERFLOW)
!
IF (ABS(Z1).LE.1._JPRB) THEN
    DISCRI=Z1*Z1-FP*FPA
  ELSE
    DISCRI=FP/Z1
    DISCRI=DISCRI*FPA
    DISCRI=Z1-DISCRI
    IF (Z1.GE.0._JPRB .AND. DISCRI.GE.0._JPRB) THEN
        DISCRI=SQRT(Z1)*SQRT(DISCRI)
        GO TO 120
    ENDIF
    IF (Z1.LE.0._JPRB .AND. DISCRI.LE.0._JPRB) THEN
        DISCRI=SQRT(-Z1)*SQRT(-DISCRI)
        GO TO 120
    ENDIF
    DISCRI=-1._JPRB
ENDIF
IF (DISCRI.LT.0._JPRB) THEN
    IF (FP.LT.0._JPRB) T=TUPPER
    IF (FP.GE.0._JPRB) T=TLOWER
    GO TO 900
ENDIF
!
!  DISCRIMINANT NONNEGATIVE, COMPUTE SOLUTION (WITHOUT OVERFLOW)
!
DISCRI=SQRT(DISCRI)
120 IF (T-TA.LT.0._JPRB) DISCRI=-DISCRI
SIGN=(T-TA)/ABS(T-TA)
IF (B*SIGN.GT.0.D+0) THEN
    T=T+FP*(TA-T)/(B+DISCRI)
  ELSE
    DEN=Z1+B+FPA
    ANUM=B-DISCRI
    IF (ABS((T-TA)*ANUM).LT.(TUPPER-TLOWER)*ABS(DEN)) THEN
        T=T+ANUM*(TA-T)/DEN
      ELSE
        T=TUPPER
    ENDIF
ENDIF
900 T=MAX(T,TLOWER)
T=MIN(T,TUPPER)
RETURN
END SUBROUTINE
!
!--------0---------0---------0---------0---------0---------0---------0--
!
SUBROUTINE MUPDTS (YDCTX, SSCALE,INMEMO,N,M,NRZ)
!
IMPLICIT NONE
CLASS (M1QN3CTX) YDCTX
!
!         ARGUMENTS
!
LOGICAL SSCALE,INMEMO
INTEGER (KIND=JPIM) :: N,M,NRZ,NA,NRZA
!----
!
!     ON ENTRY:
!       SSCALE: .TRUE. IF SCALAR INITIAL SCALING,
!               .FALSE. IF DIAGONAL INITIAL SCALING
!       N:      NUMBER OF VARIABLES
!
!     THIS ROUTINE HAS TO RETURN:
!       M:      THE NUMBER OF UPDATES TO FORM THE APPROXIMATE HESSIEN H,
!       INMEMO: .TRUE., IF THE VECTORS Y AND S USED TO FORM H ARE STORED
!                  IN CORE MEMORY,
!               .FALSE. OTHERWISE (STORAGE OF Y AND S ON DISK, FOR
!                  INSTANCE).
!     WHEN INMEMO=.FALSE., THE ROUTINE "YSTBL", WHICH STORES AND
!     RESTORES (Y,S) PAIRS, HAS TO BE REWRITTEN.
!
!----
!
CALL YDCTX%REDUCEI (1, (/N/),   'SUM', NA)
CALL YDCTX%REDUCEI (1, (/NRZ/), 'SUM', NRZA)
IF (SSCALE) THEN
    M=(NRZA-3*NA)/(2*NA+1)
ELSE
    M=(NRZA-4*NA)/(2*NA+1)
ENDIF
INMEMO=.TRUE.
RETURN
END SUBROUTINE
!
!--------0---------0---------0---------0---------0---------0---------0--
!
SUBROUTINE YSTBL (STORE,YBAR,SBAR,N,J)
!----
!
!     THIS SUBROUTINE SHOULD STORE (IF STORE = .TRUE.) OR RESTORE
!     (IF STORE = .FALSE.) A PAIR (YBAR,SBAR) AT OR FROM POSITION
!     J IN MEMORY. BE SURE TO HAVE 1 <= J <= M, WHERE M IN THE NUMBER
!     OF UPDATES SPECIFIED BY SUBROUTINE MUPDTS.
!
!     THE SUBROUTINE IS USED ONLY WHEN THE (Y,S) PAIRS ARE NOT
!     STORED IN CORE MEMORY IN THE ARRAYS YBAR(.,.) AND SBAR(.,.).
!     IN THIS CASE, THE SUBROUTINE HAS TO BE WRITTEN BY THE USER.
!
!----
!
IMPLICIT NONE
!
!         ARGUMENTS
!
LOGICAL STORE
INTEGER (KIND=JPIM) :: N,J
REAL (KIND=JPRB) :: YBAR(N),SBAR(N)
!
RETURN
END SUBROUTINE
!
!--------0---------0---------0---------0---------0---------0---------0--
!
SUBROUTINE CTONBE (YDCTX,N,U,V)
!
IMPLICIT NONE
CLASS (M1QN3CTX) :: YDCTX
INTEGER (KIND=JPIM) :: N
REAL (KIND=JPRB) :: U(1),V(1)
!
INTEGER (KIND=JPIM) :: I
!
DO I=1,N
    V(I)=U(I)
ENDDO
RETURN
END SUBROUTINE
!
!--------0---------0---------0---------0---------0---------0---------0--
!
SUBROUTINE CTCABE (YDCTX,N,U,V)
!
IMPLICIT NONE
CLASS (M1QN3CTX) :: YDCTX
INTEGER (KIND=JPIM) :: N
REAL (KIND=JPRB) :: U(1),V(1)
!
INTEGER (KIND=JPIM) :: I
!
DO I=1,N
    V(I)=U(I)
ENDDO
RETURN
END SUBROUTINE
!
!--------0---------0---------0---------0---------0---------0---------0--
!
REAL (KIND=JPRB) FUNCTION DNRMI (YDCTX, N,V)
!
INTEGER (KIND=JPIM) :: N
CLASS (M1QN3CTX) YDCTX
REAL (KIND=JPRB) :: V(N)
!
!----
!
!     COMMPUTES THE INFINTY-NORM OF THE VECTOR V(N)
!
!----
!
! --- LOCAL VARIABLES
!
INTEGER (KIND=JPIM) :: I
REAL (KIND=JPRB) :: NORM
!
! --- COMPUTE
!
NORM = 0._JPRB
IF (N.GT.0) THEN
  CALL YDCTX%REDUCER (N, ABS (V), 'MAX', NORM)
ENDIF
DNRMI = NORM
!
RETURN
END FUNCTION

END MODULE

