MODULE ATLAS_DH

USE FCKIT_MODULE, ONLY : FCKIT_MPI_COMM

USE ATLAS_IO, ONLY : ATLAS_IO_t

USE PARKIND1, ONLY : JPRB, JPIM
USE ATLAS_MODULE

#include "atlas-abort.h"

IMPLICIT NONE

TYPE, EXTENDS (ATLAS_IO_t) :: ATLAS_DH_t

! Domain restriction
  REAL (KIND=JPRB) :: ZLONW = -180._JPRB, ZLONE = +180._JPRB
  REAL (KIND=JPRB) :: ZLATS =  -90._JPRB, ZLATN =  +90._JPRB

CONTAINS
  PROCEDURE :: GRID
  PROCEDURE :: READ    
  PROCEDURE :: WRITE   
END TYPE

PRIVATE

PUBLIC :: ATLAS_DH_t

INTERFACE ATLAS_DH_t
  MODULE PROCEDURE ATLAS_DH_t_ctor
END INTERFACE 

TYPE HDR_t
  REAL (KIND=JPRB) :: RUNDEF = HUGE (0._JPRB)
  REAL (KIND=JPRB) :: ZWEST = -999, ZEAST = -999, ZNORTH = -999, ZSOUTH = -999
  INTEGER (KIND=JPIM) :: ICOLS = -999, IROWS = -999, IWIDTH = -999
  CHARACTER (LEN=256) :: CLCOMMENT = ''
END TYPE HDR_t

TYPE RES_t
  LOGICAL :: LLGLOBAL = .TRUE.
  INTEGER (KIND=JPIM) :: ICOLS, ICOL1, ICOL2
  INTEGER (KIND=JPIM) :: IROWS, IROW1, IROW2
  REAL (KIND=JPRB) :: ZLOND, ZLATD, ZLONW, ZLONE, ZLATS, ZLATN
END TYPE RES_t

CONTAINS

FUNCTION ATLAS_DH_t_ctor (PLONLATBOUNDINGBOX) RESULT (THIS)

REAL (KIND=JPRB), INTENT (IN) :: PLONLATBOUNDINGBOX (4)
TYPE (ATLAS_DH_t) :: THIS

THIS%ZLONW = PLONLATBOUNDINGBOX (1); THIS%ZLONE = PLONLATBOUNDINGBOX (2)
THIS%ZLATS = PLONLATBOUNDINGBOX (3); THIS%ZLATN = PLONLATBOUNDINGBOX (4)

END FUNCTION ATLAS_DH_t_ctor

TYPE (RES_t) FUNCTION RES (THIS, YDHDR) RESULT (YLRES)
CLASS (ATLAS_DH_t), INTENT (IN) :: THIS
TYPE (HDR_t) :: YDHDR
REAL (KIND=JPRB) :: ZMARGIN = 1._JPRB ! extends domain by 1 degree

YLRES%LLGLOBAL = &
  &        (THIS%ZLONW == -180._JPRB) &
  & .AND.  (THIS%ZLONE == +180._JPRB) &
  & .AND.  (THIS%ZLATS ==  -90._JPRB) &
  & .AND.  (THIS%ZLATN ==  +90._JPRB) 

IF (.NOT. YLRES%LLGLOBAL) THEN
  YLRES%ZLOND = MODULO (YDHDR%ZEAST  - YDHDR%ZWEST , 360._JPRB) / YDHDR%ICOLS
  
  IF (YLRES%ZLOND == 0._JPRB) THEN
    YLRES%ZLOND = 360._JPRB / YDHDR%ICOLS
  ENDIF
  
  YLRES%ZLATD = (YDHDR%ZNORTH - YDHDR%ZSOUTH) / YDHDR%IROWS

  YLRES%ICOL1 = MAX (          1, FLOOR   (0.5_JPRB + (THIS%ZLONW - ZMARGIN - YDHDR%ZWEST) / YLRES%ZLOND))
  YLRES%ICOL2 = MIN (YDHDR%ICOLS, CEILING (0.5_JPRB + (THIS%ZLONE + ZMARGIN - YDHDR%ZWEST) / YLRES%ZLOND))
  YLRES%IROW1 = MIN (YDHDR%IROWS, CEILING (0.5_JPRB + (THIS%ZLATS - ZMARGIN) / YLRES%ZLATD))
  YLRES%IROW2 = MAX (          1, FLOOR   (0.5_JPRB + (THIS%ZLATN + ZMARGIN) / YLRES%ZLATD))

  YLRES%ZLONW = YLRES%ZLOND * (YLRES%ICOL1 - 0.5_JPRB) + YDHDR%ZWEST
  YLRES%ZLONE = YLRES%ZLOND * (YLRES%ICOL2 - 0.5_JPRB) + YDHDR%ZWEST
  YLRES%ZLATN = YLRES%ZLATD * (YLRES%IROW1 - 0.5_JPRB)
  YLRES%ZLATS = YLRES%ZLATD * (YLRES%IROW2 - 0.5_JPRB)

  YLRES%ICOLS = YLRES%ICOL2 - YLRES%ICOL1 + 1
  YLRES%IROWS = YLRES%IROW2 - YLRES%IROW1 + 1
ENDIF

END FUNCTION RES

TYPE (ATLAS_STRUCTUREDGRID) FUNCTION GRID (THIS, CDFILE) RESULT (YLGRID)
CLASS (ATLAS_DH_t), INTENT (IN) :: THIS
CHARACTER (LEN=*),  INTENT (IN) :: CDFILE

TYPE (HDR_t) :: YLHDR
TYPE (RES_t) :: YLRES

YLHDR = HDR (CDFILE)
YLRES = RES (THIS, YLHDR)

YLRES%LLGLOBAL = .TRUE.

IF (YLRES%LLGLOBAL) THEN
BLOCK
  TYPE (ATLAS_CONFIG) :: YLCFGR, YLCFDO
  YLCFGR = ATLAS_CONFIG ()
  YLCFDO = ATLAS_CONFIG ()
  CALL YLCFGR%SET ("nx", YLHDR%ICOLS)
  CALL YLCFGR%SET ("ny", YLHDR%IROWS)
  CALL YLCFGR%SET ("type", "shifted_lonlat")
  CALL YLCFDO%SET ("type", "global")
  CALL YLCFDO%SET ("units", "degrees")
  CALL YLCFDO%SET ("west", YLHDR%ZWEST)
  CALL YLCFGR%SET ("domain", YLCFDO)
  YLGRID = ATLAS_STRUCTUREDGRID (YLCFGR)
  CALL YLCFGR%FINAL ()
  CALL YLCFDO%FINAL ()
ENDBLOCK
ELSE
BLOCK
  YLGRID = ATLAS_LONLATREGIONALGRID (YLRES%ICOLS, YLRES%IROWS, &
         & YLRES%ZLONW, YLRES%ZLONE, YLRES%ZLATS, YLRES%ZLATN)
ENDBLOCK
ENDIF

CALL YLGRID%RETURN ()

END FUNCTION

TYPE (ATLAS_FIELDSET) FUNCTION READ (THIS, CDFILE, CDNAME, YDSTCO, PUNDEF, PSCALE) RESULT (YLFLST)
CLASS (ATLAS_DH_t), INTENT (IN) :: THIS
CHARACTER (LEN=*),  INTENT (IN) :: CDFILE
CHARACTER (LEN=*),  INTENT (IN) :: CDNAME (:)
TYPE (ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS), INTENT (IN) :: YDSTCO
REAL (KIND=JPRB),   INTENT (IN), OPTIONAL :: PUNDEF, PSCALE
TYPE (ATLAS_FIELD) :: YLFLD


YLFLST = ATLAS_FIELDSET ()

YLFLD = DIR (CDFILE, YDSTCO, PUNDEF, PSCALE)
CALL YLFLD%RENAME (CDNAME (1))

CALL YLFLST%ADD (YLFLD)

CALL YLFLD%FINAL ()
CALL YLFLST%RETURN ()

END FUNCTION

SUBROUTINE WRITE (THIS, CDFILE, YDFLST, YDSTCO)
CLASS (ATLAS_DH_t),    INTENT (IN) :: THIS
CHARACTER (LEN=*),     INTENT (IN) :: CDFILE
TYPE (ATLAS_FIELDSET), INTENT (IN) :: YDFLST
TYPE (ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS), INTENT (IN) :: YDSTCO

CALL ABORT ('ATLAS_DH:WRITE NOT IMPLEMENTED')

END SUBROUTINE

TYPE (HDR_t) FUNCTION HDR (CDFILE) RESULT (YLHDR)

CHARACTER (LEN=*), INTENT (IN)  :: CDFILE

CHARACTER (LEN=256) :: CLLINE

OPEN (77, FILE=TRIM (CDFILE)//'.hdr', FORM='FORMATTED')

READ (77, '(A)') CLLINE

YLHDR%CLCOMMENT = CLLINE

DO 
  READ (77, '(A256)', END=999) CLLINE
  IF (CLLINE (1:7) == 'nodata:'             ) READ (CLLINE ( 8:), *) YLHDR%RUNDEF
  IF (CLLINE (1:6) == 'north:'              ) READ (CLLINE ( 7:), *) YLHDR%ZNORTH
  IF (CLLINE (1:6) == 'south:'              ) READ (CLLINE ( 7:), *) YLHDR%ZSOUTH
  IF (CLLINE (1:5) == 'west:'               ) READ (CLLINE ( 6:), *) YLHDR%ZWEST
  IF (CLLINE (1:5) == 'east:'               ) READ (CLLINE ( 6:), *) YLHDR%ZEAST
  IF (CLLINE (1:5) == 'rows:'               ) READ (CLLINE ( 6:), *) YLHDR%IROWS
  IF (CLLINE (1:5) == 'cols:'               ) READ (CLLINE ( 6:), *) YLHDR%ICOLS
  IF (CLLINE (1:19) == 'recordtype: integer') READ (CLLINE (20:), *) YLHDR%IWIDTH
ENDDO

999 CONTINUE

CLOSE (77)

SELECT CASE (YLHDR%IWIDTH)
  CASE ( 8)
    IF (YLHDR%RUNDEF < 0) YLHDR%RUNDEF = YLHDR%RUNDEF + 256._JPRB
  CASE DEFAULT
END SELECT

END FUNCTION

FUNCTION DIR (CDFILE, YDFSSC, PUNDEF, PSCALE) RESULT (YLFLD)

TYPE (ATLAS_FIELD) :: YLFLD

CHARACTER (LEN=*),                            INTENT (IN) :: CDFILE
TYPE (ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS), INTENT (IN) :: YDFSSC
REAL (KIND=JPRB),                             INTENT (IN), OPTIONAL :: PUNDEF, PSCALE

INTEGER (KIND=JPIM), ALLOCATABLE :: ISIZE (:), IOFFS (:)
INTEGER (KIND=JPIM) :: IPROC, INX, NPROC, IROWLENG

INTEGER*1, ALLOCATABLE :: IL1 (:)
INTEGER*2, ALLOCATABLE :: IL2 (:)
INTEGER (KIND=JPIM) :: IROW, ICOL, IOFF, JLAT, IROW1, IROW2, I, IRANK
REAL (KIND=JPRB), POINTER :: ZDATA (:)
TYPE (ATLAS_STRUCTUREDGRID) :: YLGRID
TYPE (HDR_t) :: YLHDR
TYPE (FCKIT_MPI_COMM) :: YLCOMM
TYPE (ATLAS_METADATA) :: YLMETA

YLHDR = HDR (CDFILE)

YLCOMM = FCKIT_MPI_COMM ()
IRANK = YLCOMM%RANK ()
NPROC = YLCOMM%SIZE ()

YLGRID = YDFSSC%GRID ()


YLFLD = ATLAS_FIELD (NAME=TRIM (CDFILE), KIND=JPRB, SHAPE=[YDFSSC%SIZE ()])

CALL YLFLD%DATA (ZDATA)

ALLOCATE (ISIZE (NPROC), IOFFS (NPROC + 1))

CALL YLCOMM%ALLGATHER ([YDFSSC%SIZE_OWNED ()], ISIZE, 1, &
                     & [(1, I = 0, YLCOMM%SIZE ())],     &
                     & [(I, I = 0, YLCOMM%SIZE ())]);

IOFFS (1) = 0
DO IPROC = 2, NPROC+1
  IOFFS (IPROC) = IOFFS (IPROC-1) + ISIZE (IPROC-1)
ENDDO

IPROC = IRANK + 1

INX = YLGRID%NX (1)

IF (MODULO (IOFFS (IPROC), INX) /= 0) THEN
  CALL ABORT ('DIR: DISTRIBUTION MISMATCH')
ENDIF

IROW1 = 1 + IOFFS (IPROC+0) / INX
IROW2 = 0 + IOFFS (IPROC+1) / INX

IF (SIZE (ZDATA) < INX * (IROW2-IROW1+1)) THEN
  CALL ABORT ('DIR: ZDATA IS TOO SMALL')
ENDIF

OPEN (77, FILE=TRIM (CDFILE)//'.dir', FORM='UNFORMATTED', ACTION='READ', ACCESS='STREAM')

IROWLENG = (YLHDR%ICOLS * YLHDR%IWIDTH) / 8

SELECT CASE (YLHDR%IWIDTH)

  CASE ( 8)
  
    ALLOCATE (IL1 (YLHDR%ICOLS))

    IOFF = 0
    DO IROW = IROW1, IROW2
      READ (77, POS=1+(IROW-1)*IROWLENG) IL1
      WHERE (IL1 < 0)
        ZDATA (IOFF+1:IOFF+YLHDR%ICOLS) = IL1 + 256
      ELSEWHERE
        ZDATA (IOFF+1:IOFF+YLHDR%ICOLS) = IL1 
      ENDWHERE
      IOFF = IOFF + YLHDR%ICOLS
    ENDDO

  CASE (16)

    ALLOCATE (IL2 (YLHDR%ICOLS))

    IOFF = 0
    DO IROW = IROW1, IROW2
      READ (77, POS=1+(IROW-1)*IROWLENG) IL2
      ZDATA (IOFF+1:IOFF+YLHDR%ICOLS) = IL2 
      IOFF = IOFF + YLHDR%ICOLS
    ENDDO

  CASE DEFAULT

    STOP

END SELECT

CLOSE (77)

CALL YLCOMM%FINAL ()
CALL YLGRID%FINAL ()

IF (PRESENT (PSCALE)) THEN
  WHERE (ZDATA /= YLHDR%RUNDEF)
    ZDATA = ZDATA * PSCALE
  END WHERE
ENDIF

IF (PRESENT (PUNDEF)) THEN
  WHERE (ZDATA == YLHDR%RUNDEF)
    ZDATA = PUNDEF
  END WHERE
  YLHDR%RUNDEF = PUNDEF
ENDIF

YLMETA = YLFLD%METADATA ()
CALL YLMETA%SET ("undef", YLHDR%RUNDEF)
CALL YLMETA%FINAL ()

CALL YLFLD%RETURN ()

END FUNCTION

END MODULE

