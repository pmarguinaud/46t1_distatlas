MODULE ATLAS_FA

USE FCKIT_MODULE, ONLY : FCKIT_MPI_COMM

USE FA_MOD, ONLY : FA_COM_DEFAULT, NEW_FA_DEFAULT, FACADR
USE ATLAS_IO, ONLY : ATLAS_IO_t

USE PARKIND1, ONLY : JPRB, JPIM
USE ATLAS_MODULE

#include "atlas-abort.h"

IMPLICIT NONE

REAL (KIND=JPRB), PARAMETER :: RPI = 2.0_JPRB * ASIN (1.0_JPRB), &
                             & R2PI = 2._JPRB * RPI,             &
                             & RAD2DEG = 180._JPRB / RPI,        &
                             & DEG2RAD = RPI / 180._JPRB


TYPE, EXTENDS (ATLAS_IO_t) :: ATLAS_FA_t
CONTAINS

  PROCEDURE :: GRID
  PROCEDURE :: READ    
  PROCEDURE :: WRITE   

END TYPE

PRIVATE
PUBLIC :: ATLAS_FA_t, ISMGLO, ISMLAM, ISLTLN

CONTAINS

TYPE (ATLAS_STRUCTUREDGRID) FUNCTION GRID (THIS, CDFILE) RESULT (YLGRID)
CLASS (ATLAS_FA_t), INTENT (IN) :: THIS
CHARACTER (LEN=*),  INTENT (IN) :: CDFILE

CHARACTER (LEN=*), PARAMETER :: CLNOMC = 'c'
INTEGER (KIND=JPIM) :: ILUN, IREP, INBARP, INBARI, IRANGC
TYPE (FACADR), POINTER :: YLCADR
LOGICAL :: LLMLAM, LLLTLN, LLMGLO

ILUN = 77_JPIM
INBARP = 0
INBARI = 0
CALL FAITOU (IREP, ILUN, .TRUE., TRIM (CDFILE), 'OLD', &
           & .TRUE., .TRUE., 2_JPIM, INBARP, INBARI, CLNOMC)

CALL FANUCA (CLNOMC, IRANGC, .FALSE.)
YLCADR => FA_COM_DEFAULT%CADRE (IRANGC)

LLMLAM = YLCADR%LIMLAM
LLLTLN = YLCADR%SINLAT(2) < 0 .AND. LLMLAM
LLMGLO = (.NOT. LLMLAM) .AND. (.NOT. LLLTLN)

IF (LLLTLN) THEN ! Lat/lon grid
BLOCK
  REAL (KIND=JPRB) :: ZLONW, ZLATS, ZLONE, ZLATN, ZLOND, ZLATD
  INTEGER (KIND=JPIM) :: ILATS, ILONS
  LOGICAL :: LLGLOBAL
  TYPE (ATLAS_CONFIG) :: YLCFGR, YLCFDO
  
  ILATS = YLCADR%NLATIT
  ILONS = YLCADR%NXLOPA
  

  ZLONW = LONRAD2DEG (YLCADR%SINLAT(13))
  ZLATS = LATRAD2DEG (YLCADR%SINLAT(14))
  ZLONE = LONRAD2DEG (YLCADR%SINLAT(15))
  ZLATN = LATRAD2DEG (YLCADR%SINLAT(16))
  
  ZLOND = MODULO (ZLONE-ZLONW, 360._JPRB) / (ILONS-1)
  ZLATD = (ZLATN-ZLATS)/(ILATS-1)
  
  ZLONW = RROUND16 (ZLONW)
  ZLATS = RROUND16 (ZLATS)
  ZLONE = RROUND16 (ZLONE)
  ZLATN = RROUND16 (ZLATN)
  ZLOND = RROUND16 (ZLOND)
  ZLATD = RROUND16 (ZLATD)
  
  LLGLOBAL = ABS (MOD (ZLONE+ZLOND-ZLONW-360._JPRB, 360._JPRB)) < 1E-6_JPRB

  YLCFGR = ATLAS_CONFIG ()
  YLCFDO = ATLAS_CONFIG ()

  IF (LLGLOBAL) THEN ! Global lat/lon
    CALL YLCFGR%SET ("nx", ILONS)
    CALL YLCFGR%SET ("ny", ILATS)
    CALL YLCFGR%SET ("type", "regular_lonlat")
    IF (ZLONE+ZLOND < ZLONW) THEN
      ZLONW = ZLONW - 360._JPRB
    ENDIF
    CALL YLCFDO%SET ("type", "global") 
    CALL YLCFDO%SET ("xmin", ZLONW)
    CALL YLCFDO%SET ("xmax", ZLONE+ZLOND)
    CALL YLCFDO%SET ("ymin", ZLATS)
    CALL YLCFDO%SET ("ymax", ZLATN)
    CALL YLCFDO%SET ("units", "degrees")
    CALL YLCFGR%SET ("domain", YLCFDO)
    YLGRID = ATLAS_STRUCTUREDGRID (YLCFGR)
  ELSE ! Regional lat/lon
    IF (ZLONE < ZLONW) THEN
      ZLONW = ZLONW - 360._JPRB
    ENDIF
    YLGRID = ATLAS_REGIONALGRID (NX=ILONS, NY=ILATS, NORTH=ZLATN, WEST=ZLONW, SOUTH=ZLATS, EAST=ZLONE)
  ENDIF
  CALL YLCFGR%FINAL ()
  CALL YLCFDO%FINAL ()
ENDBLOCK
ELSEIF (LLMLAM) THEN
BLOCK ! Regional model
  REAL (KIND=JPRB) :: DXINMETRES, DYINMETRES
  REAL (KIND=JPRB) :: LOVINDEGREES, LADINDEGREES, LATIN1INDEGREES, LATIN2INDEGREES
  INTEGER (KIND=JPIM) :: NUX, NUY

  DXINMETRES = YLCADR%SINLAT (7)
  DYINMETRES = YLCADR%SINLAT (8)
  NUX = INT (YLCADR%NLOPAR (4), JPIM)
  NUY = INT (YLCADR%NLOPAR (6), JPIM)

  LADINDEGREES    = YLCADR%SINLAT (4) * RAD2DEG
  LATIN1INDEGREES = YLCADR%SINLAT (4) * RAD2DEG
  LATIN2INDEGREES = YLCADR%SINLAT (4) * RAD2DEG
  LOVINDEGREES    = YLCADR%SINLAT (3) * RAD2DEG

  YLGRID = ATLAS_REGIONALGRID (NX=YLCADR%NXLOPA, NY=YLCADR%NLATIT,         &
         & XY_MIN=[-NUX / 2 * DXINMETRES, -NUY / 2 * DYINMETRES],          &
         & DX=DXINMETRES, DY=DYINMETRES,                                   &
         & PROJECTION=ATLAS_LAMBERTCONFORMALCONICPROJECTION                &
         & (LOVINDEGREES, LADINDEGREES, LATIN1INDEGREES, LATIN2INDEGREES))

ENDBLOCK
ELSEIF (LLMGLO) THEN
BLOCK ! Global model
  INTEGER (KIND=JPIM), ALLOCATABLE :: NLOENG (:)
  REAL (KIND=JPRB) :: ZLONC, ZLATC

  ALLOCATE (NLOENG (YLCADR%NLATIT))

  IF (MODULO (YLCADR%NLATIT, 2) == 0) THEN
    NLOENG (1:YLCADR%NLATIT/2) = INT (YLCADR%NLOPAR (1:YLCADR%NLATIT/2), JPIM)
    NLOENG (YLCADR%NLATIT/2+1:YLCADR%NLATIT) = INT (NLOENG (YLCADR%NLATIT/2:1:-1), JPIM)
  ELSE
    CALL ABORT ('UNEXPECTED ODD NUMBER OF LATITUDES')
  ENDIF

  ZLATC = RAD2DEG * ASIN (YLCADR%SSLAPO)
  ZLONC = RAD2DEG * ATAN2 (YLCADR%SSLOPO, YLCADR%SCLOPO)

  YLGRID = ATLAS_REDUCEDGAUSSIANGRID (NLOENG,        &
         & PROJECTION=ATLAS_ROTATEDSCHMIDTPROJECTION &
         & (YLCADR%SCODIL, [ZLONC, ZLATC], 180._JPRB))

ENDBLOCK
ENDIF

CALL FAIRME (IREP, ILUN, 'KEEP')

CALL YLGRID%RETURN ()

CONTAINS

REAL (KIND=JPRB) FUNCTION LATRAD2DEG (PLAT)
REAL (KIND=JPRB), INTENT (IN) :: PLAT
LATRAD2DEG = 180._JPRB/RPI * PLAT
END FUNCTION LATRAD2DEG

FUNCTION RROUND16 (PVA) RESULT (PVAR)
REAL (KIND=JPRB)    :: PVA, PVAR
PVAR = NINT (PVA * 10000000., SELECTED_INT_KIND (16)) / 10000000.
END FUNCTION RROUND16

REAL (KIND=JPRB) FUNCTION LONRAD2DEG (PLON)
REAL (KIND=JPRB), INTENT (IN) :: PLON
LONRAD2DEG = MODULO (180._JPRB/RPI * PLON, 360._JPRB)
END FUNCTION LONRAD2DEG

END FUNCTION

TYPE (ATLAS_FIELDSET) FUNCTION READ (THIS, CDFILE, CDNAME, YDSTCO, PUNDEF, PSCALE) RESULT (YLFLST)

USE FCKIT_MODULE, ONLY : FCKIT_MPI_COMM

CLASS (ATLAS_FA_t), INTENT (IN) :: THIS
CHARACTER (LEN=*),  INTENT (IN) :: CDFILE
CHARACTER (LEN=*),  INTENT (IN) :: CDNAME (:)
TYPE (ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS), INTENT (IN) :: YDSTCO
REAL (KIND=JPRB),   INTENT (IN), OPTIONAL :: PUNDEF, PSCALE

#include "facilo.h"

CHARACTER (LEN=*), PARAMETER :: CLNOMC = 'c'
INTEGER (KIND=JPIM) :: ILUN, INBARP, INBARI, IREP
INTEGER (KIND=JPIM) :: MYPROC, NPROC, IPROC
INTEGER (KIND=JPIM) :: JFLD1, JFLD2, INFLD, JFLD
INTEGER (KIND=JPIM) :: IFROM (SIZE (CDNAME))
TYPE (ATLAS_FIELD)  :: YLFLDL (SIZE (CDNAME))
TYPE (ATLAS_FIELD)  :: YLFLDG (SIZE (CDNAME))
TYPE (ATLAS_FIELDSET) :: YLFLSG
TYPE (FCKIT_MPI_COMM) :: YLCOMM
TYPE (ATLAS_STRUCTUREDGRID) :: YLGRID
INTEGER (KIND=JPIM),   ALLOCATABLE :: INIVAU (:)
CHARACTER (LEN=16),    ALLOCATABLE :: CLSUFF (:)
CHARACTER (LEN=16),    ALLOCATABLE :: CLPREF (:)
LOGICAL, ALLOCATABLE :: LLUNDEF (:)
REAL (KIND=JPRB), ALLOCATABLE :: ZUNDEF (:)


YLGRID = YDSTCO%GRID ()
YLCOMM = FCKIT_MPI_COMM ()
MYPROC = YLCOMM%RANK () + 1
NPROC  = YLCOMM%SIZE ()
INFLD  = SIZE (CDNAME)

ALLOCATE (CLPREF (INFLD), INIVAU (INFLD), CLSUFF (INFLD))
ALLOCATE (LLUNDEF (INFLD), ZUNDEF (INFLD))

YLFLST = ATLAS_FIELDSET ()
YLFLSG = ATLAS_FIELDSET ()

DO IPROC = 1, NPROC
  JFLD1 = 1 + ((IPROC-1) * INFLD) / NPROC
  JFLD2 = 0 + ((IPROC+0) * INFLD) / NPROC
  IFROM (JFLD1:JFLD2) = IPROC
ENDDO

ILUN = 77_JPIM
INBARP = 0
INBARI = 0
CALL FAITOU (IREP, ILUN, .TRUE., TRIM (CDFILE), 'OLD', &
           & .TRUE., .TRUE., 2_JPIM, INBARP, INBARI, CLNOMC)

DO JFLD = 1, INFLD
BLOCK
  TYPE (ATLAS_METADATA) :: YLMETA
  REAL (KIND=JPRB), POINTER :: ZFLDL (:)
  INTEGER (KIND=JPIM) :: ISIZEG

  CALL FAQUIN (IREP, ILUN, CLPREF (JFLD), INIVAU (JFLD), CLSUFF (JFLD), &
             & CDNAME (JFLD), LEN_TRIM (CDNAME (JFLD)))

! Global field; zero size if this proc does not read the field
  ISIZEG = 0
  IF (IFROM (JFLD) == MYPROC) ISIZEG = INT (YLGRID%SIZE (), JPIM)
  YLFLDG (JFLD) = ATLAS_FIELD (NAME=TRIM (CDNAME (JFLD)), KIND=JPRB, SHAPE=[ISIZEG])
  YLMETA = YLFLDG (JFLD)%METADATA ()
! Set owner
  CALL YLMETA%SET ("owner", IFROM (JFLD)-1)
  CALL YLMETA%FINAL ()
  CALL YLFLSG%ADD (YLFLDG (JFLD))

! Distributed field : created by space function
  YLFLDL (JFLD) = YDSTCO%CREATE_FIELD (NAME=TRIM (CDNAME (JFLD)), KIND=JPRB)
  CALL YLFLDL (JFLD)%DATA (ZFLDL)
  ZFLDL = 0._JPRB ! Not necessary
  CALL YLFLST%ADD (YLFLDL (JFLD))
ENDBLOCK
ENDDO

LLUNDEF = .TRUE.
ZUNDEF  = HUGE (1._JPRB)
IF (PRESENT (PUNDEF)) ZUNDEF = PUNDEF

DO JFLD = 1, INFLD
  IF (IFROM (JFLD) == MYPROC) THEN
  BLOCK
    REAL (KIND=JPRB), POINTER :: ZFLDG (:)
    CALL YLFLDG (JFLD)%DATA (ZFLDG)
    CALL FACILO (IREP, ILUN, CLPREF (JFLD), INIVAU (JFLD), CLSUFF (JFLD), ZFLDG, .FALSE., &
               & LDUNDF=LLUNDEF (JFLD), PUNDF=ZUNDEF (JFLD), LDREVERT=.FALSE.)
  ENDBLOCK
  ENDIF
ENDDO

CALL YDSTCO%SCATTER (YLFLSG, YLFLST)

CALL FAIRME (IREP, ILUN, 'KEEP')

! Add undef metadata

DO JFLD = 1, INFLD
  CALL YLCOMM%BROADCAST (ZUNDEF (JFLD), IFROM (JFLD)-1)
  CALL YLCOMM%BROADCAST (LLUNDEF (JFLD), IFROM (JFLD)-1)
ENDDO

DO JFLD = 1, INFLD
  IF (LLUNDEF (JFLD)) THEN
    BLOCK
      REAL (KIND=JPRB), POINTER :: ZFLDL (:)
      TYPE (ATLAS_METADATA) :: YLMETA
      YLMETA = YLFLDL (JFLD)%METADATA ()
      CALL YLMETA%SET ("undef", ZUNDEF (JFLD))
      CALL YLMETA%FINAL ()
      CALL YLFLDL (JFLD)%DATA (ZFLDL)
      IF (PRESENT (PSCALE)) THEN
        WHERE (ZFLDL /= ZUNDEF (JFLD)) 
          ZFLDL = ZFLDL * PSCALE
        ENDWHERE
      ENDIF
    ENDBLOCK
  ENDIF
ENDDO

DO JFLD = 1, INFLD
  CALL YLFLDG (JFLD)%FINAL ()
  CALL YLFLDL (JFLD)%FINAL ()
ENDDO

CALL YLFLSG%FINAL ()
CALL YLGRID%FINAL ()

CALL YLFLST%RETURN ()

END FUNCTION

SUBROUTINE WRITE (THIS, CDFILE, YDFLST, YDSTCO)

USE FCKIT_MODULE, ONLY : FCKIT_MPI_COMM

CLASS (ATLAS_FA_t),    INTENT (IN) :: THIS
CHARACTER (LEN=*),     INTENT (IN) :: CDFILE
TYPE (ATLAS_FIELDSET), INTENT (IN) :: YDFLST
TYPE (ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS), INTENT (IN) :: YDSTCO
TYPE (ATLAS_TRACE) :: YLTRAC_GA
TYPE (ATLAS_TRACE) :: YLTRAC_WR

#include "faieno.h"

INTEGER (KIND=JPIM), ALLOCATABLE :: ITO (:)
TYPE (ATLAS_FIELD),  ALLOCATABLE :: YLFLDL (:)
TYPE (ATLAS_FIELD),  ALLOCATABLE :: YLFLDG (:)

TYPE (ATLAS_STRUCTUREDGRID) :: YLGRID
TYPE (ATLAS_FIELDSET) :: YLFLSG
INTEGER (KIND=JPIM) :: MYPROC, NPROC, IPROC
INTEGER (KIND=JPIM) :: JFLD1, JFLD2, INFLD, JFLD
TYPE (FCKIT_MPI_COMM) :: YLCOMM
CHARACTER (LEN=128) :: CLFILENAME, CLPROC
INTEGER (KIND=JPIM) :: ILUN, IREP
TYPE (FACADR), POINTER :: YLCADR
LOGICAL :: LLMLAM, LLLTLN, LLMGLO

YLGRID = YDSTCO%GRID ()
YLCOMM = FCKIT_MPI_COMM ()
MYPROC = YLCOMM%RANK () + 1
NPROC  = YLCOMM%SIZE ()
INFLD  = YDFLST%SIZE ()

ALLOCATE (ITO (INFLD), YLFLDL (INFLD), YLFLDG (INFLD))

DO IPROC = 1, NPROC
  JFLD1 = 1 + ((IPROC-1) * INFLD) / NPROC
  JFLD2 = 0 + ((IPROC+0) * INFLD) / NPROC
  ITO (JFLD1:JFLD2) = IPROC
ENDDO

WRITE (CLPROC, '(".",I4.4)') MYPROC
CLFILENAME = TRIM (CDFILE)//TRIM (CLPROC)

ILUN = 77

IF (ANY (ITO == MYPROC)) THEN
  CALL OFA (ILUN, CLFILENAME, YLGRID)
  BLOCK
    CHARACTER (LEN=*), PARAMETER :: CLNOMC = 'c'
    INTEGER (KIND=JPIM) :: INGRIB, INARG1, INARG2, INARG3, INARG4, INARG5, IRANGC
    CALL FAVEUR (IREP, ILUN, INGRIB, INARG1, INARG2, INARG3, INARG4, INARG5)
    INGRIB = 123_JPIM
    CALL FAGOTE (IREP, ILUN, INGRIB, INARG1, INARG2, INARG3, INARG4, INARG5)

    CALL FANUCA (CLNOMC, IRANGC, .FALSE.)
    YLCADR => FA_COM_DEFAULT%CADRE (IRANGC)

    LLMLAM = YLCADR%LIMLAM
    LLLTLN = YLCADR%SINLAT(2) < 0 .AND. LLMLAM
    LLMGLO = (.NOT. LLMLAM) .AND. (.NOT. LLLTLN)

  ENDBLOCK
ENDIF

YLFLSG = ATLAS_FIELDSET ()

DO JFLD = 1, INFLD
BLOCK
  CHARACTER (LEN=16)  :: CLNOMA
  INTEGER (KIND=JPIM) :: ISIZEG
  TYPE (ATLAS_METADATA) :: YLMETG

! Distributed field 
  YLFLDL (JFLD) = YDFLST%FIELD (JFLD)

  CLNOMA = YLFLDL (JFLD)%NAME ()
! Global field; zero size if this proc does not write the field
  ISIZEG = 0
  IF (ITO (JFLD) == MYPROC) ISIZEG = INT (YLGRID%SIZE (), JPIM)
  YLFLDG (JFLD) = ATLAS_FIELD (NAME=CLNOMA, KIND=JPRB, SHAPE=[ISIZEG])
  YLMETG = YLFLDG (JFLD)%METADATA ()
! Set owner
  CALL YLMETG%SET ("owner", ITO (JFLD)-1)
  CALL YLMETG%FINAL ()
  CALL YLFLSG%ADD (YLFLDG (JFLD))

ENDBLOCK
ENDDO

YLTRAC_GA = ATLAS_TRACE (__FILE__, __LINE__, "ATLAS_FA:WRITE:GATHER")
CALL YDSTCO%GATHER (YDFLST, YLFLSG)
CALL YLTRAC_GA%FINAL ()

YLTRAC_WR = ATLAS_TRACE (__FILE__, __LINE__, "ATLAS_FA:WRITE:WRITE")
DO JFLD = 1, INFLD
  IF (ITO (JFLD) == MYPROC) THEN 
  BLOCK
    REAL (KIND=JPRB), POINTER :: ZFLDG (:)
    INTEGER (KIND=JPIM) :: INIVAU
    CHARACTER (LEN=:), ALLOCATABLE :: CLNOMA
    CHARACTER (LEN=16) :: CLSUFF, CLPREF
    LOGICAL :: LLUNDF
    REAL (KIND=JPRB) :: ZUNDF
    TYPE (ATLAS_METADATA) :: YLMETA

    ! See whether we have undef values
    YLMETA = YLFLDL (JFLD)%METADATA ()
    LLUNDF = YLMETA%HAS ("undef")
    IF (LLUNDF) CALL YLMETA%GET ("undef", ZUNDF)
    CALL YLMETA%FINAL ()

    ! Parse field name
    CLNOMA = YLFLDG (JFLD)%NAME ()
    CALL FAQUIN (IREP, ILUN, CLPREF, INIVAU, CLSUFF, CLNOMA, LEN_TRIM (CLNOMA))

    ! Write field
    CALL YLFLDG (JFLD)%DATA (ZFLDG)

    CALL FAIENO (IREP, ILUN, CLPREF, INIVAU, CLSUFF, ZFLDG, .FALSE., &
               & LDUNDF=LLUNDF, PUNDF=ZUNDF, LDREVERT=LLLTLN)

  ENDBLOCK
  ENDIF
ENDDO
CALL YLTRAC_WR%FINAL ()

IF (ANY (ITO == MYPROC)) THEN
  CALL FAIRME (IREP, ILUN, 'KEEP')
ENDIF

DO JFLD = 1, INFLD
  CALL YLFLDG (JFLD)%FINAL ()
  CALL YLFLDL (JFLD)%FINAL ()
ENDDO

CALL YLFLSG%FINAL ()
CALL YLGRID%FINAL ()

END SUBROUTINE

LOGICAL FUNCTION ISMGLO (YDGRID)

USE XRD_UNIX_ENV, ONLY : XRD_ISDIGIT

CLASS (ATLAS_STRUCTUREDGRID),  INTENT (IN) :: YDGRID

TYPE (ATLAS_CONFIG) :: YLCONF
CHARACTER (LEN=:), ALLOCATABLE :: CLPRTY, CLNAME, CLDOTY, CLYSPT
INTEGER (KIND=JPIM) :: J

YLCONF = YDGRID%SPEC ()

IF (YLCONF%GET ('domain.type', CLDOTY)) THEN
  IF (CLDOTY /= 'global') GOTO 999
ENDIF

IF (YLCONF%GET ('projection.type', CLPRTY)) THEN
  IF ((CLPRTY /= 'lonlat') .AND. (CLPRTY /= 'rotated_schmidt')) GOTO 999
ENDIF

IF (YLCONF%GET ('name', CLNAME)) THEN
  IF ((CLNAME (1:1) /= 'N') .AND. (CLNAME (1:1) /= 'O')) GOTO 999
  DO J = 2, LEN_TRIM (CLNAME)
    IF (.NOT. XRD_ISDIGIT (CLNAME (J:J))) GOTO 999
  ENDDO
ELSEIF (YLCONF%GET ("yspace.type", CLYSPT)) THEN
  IF (CLYSPT /= 'gaussian') GOTO 999
ELSE
  GOTO 999
ENDIF

ISMGLO = .TRUE.
CALL YLCONF%FINAL ()
RETURN

999 CONTINUE
ISMGLO = .FALSE.
CALL YLCONF%FINAL ()
RETURN

END FUNCTION 

LOGICAL FUNCTION ISMLAM (YDGRID)

USE XRD_UNIX_ENV, ONLY : XRD_ISDIGIT

CLASS (ATLAS_STRUCTUREDGRID),  INTENT (IN) :: YDGRID

TYPE (ATLAS_CONFIG) :: YLCONF
CHARACTER (LEN=:), ALLOCATABLE :: CLPRTY, CLNAME, CLDOTY
INTEGER (KIND=JPIM) :: J

YLCONF = YDGRID%SPEC ()

IF (YLCONF%GET ('projection.type', CLPRTY)) THEN
  IF (CLPRTY /= 'lambert_conformal_conic') GOTO 999
ENDIF

IF (YLCONF%GET ('domain.type', CLDOTY)) THEN
  IF (CLDOTY /= 'rectangular') GOTO 999
ENDIF

ISMLAM = .TRUE.
CALL YLCONF%FINAL ()
RETURN

999 CONTINUE
ISMLAM = .FALSE.
CALL YLCONF%FINAL ()
RETURN

END FUNCTION 

LOGICAL FUNCTION ISLTLN (YDGRID)

USE XRD_UNIX_ENV, ONLY : XRD_ISDIGIT

CLASS (ATLAS_STRUCTUREDGRID),  INTENT (IN) :: YDGRID

TYPE (ATLAS_CONFIG) :: YLCONF
CHARACTER (LEN=:), ALLOCATABLE :: CLPRTY, CLNAME, CLDOTY, CLDOUN, CLXSTY, CLYSTY
INTEGER (KIND=JPIM) :: J
LOGICAL :: LLXF

YLCONF = YDGRID%SPEC ()

IF (YLCONF%GET ('projection.type', CLPRTY)) THEN
  IF (CLPRTY /= 'lonlat') GOTO 999
ENDIF

IF (YLCONF%GET ('name', CLNAME)) THEN
  IF ((CLNAME (1:1) /= 'S') .AND. (CLNAME (1:1) /= 'L')) GOTO 999
  IF (.NOT. XRD_ISDIGIT (CLNAME (2:2))) GOTO 999
  LLXF = .FALSE.
  DO J = 3, LEN_TRIM (CLNAME)
    IF ((.NOT. LLXF) .AND. (CLNAME (J:J) == 'x')) THEN
      LLXF = .TRUE.
    ELSEIF (.NOT.XRD_ISDIGIT (CLNAME (J:J))) THEN
      GOTO 999
    ENDIF
  ENDDO
ELSEIF (YLCONF%GET ('domain.type', CLDOTY)) THEN
  IF (CLDOTY /= 'rectangular') GOTO 999
  IF (.NOT. YLCONF%GET ('domain.units', CLDOUN)) GOTO 999
  IF (CLDOUN /= 'degrees') GOTO 999
  IF (.NOT. YLCONF%GET ('xspace.type', CLXSTY)) GOTO 999
  IF (CLXSTY /= 'linear') GOTO 999
  IF (.NOT. YLCONF%GET ('yspace.type', CLYSTY)) GOTO 999
  IF (CLYSTY /= 'linear') GOTO 999
ELSE
  GOTO 999
ENDIF

ISLTLN = .TRUE.
CALL YLCONF%FINAL ()
RETURN

999 CONTINUE
ISLTLN = .FALSE.
CALL YLCONF%FINAL ()
RETURN

END FUNCTION

SUBROUTINE OFA (KLUN, CDFILENAME, YDGRID)

USE XRD_UNIX_ENV, ONLY : XRD_ISDIGIT

INTEGER (KIND=JPIM),           INTENT (IN) :: KLUN
CHARACTER (LEN=*),             INTENT (IN) :: CDFILENAME
CLASS (ATLAS_STRUCTUREDGRID),  INTENT (IN) :: YDGRID

TYPE (ATLAS_CONFIG) :: YLCONF

CHARACTER (LEN=*), PARAMETER   :: CLNOMC = 'c'
CHARACTER (LEN=:), ALLOCATABLE :: CLPRTY, CLDOTY
LOGICAL :: LLMGLO, LLMLAM, LLLTLN

YLCONF = YDGRID%SPEC ()

LLMGLO = ISMGLO (YDGRID)
LLMLAM = ISMLAM (YDGRID)
LLLTLN = ISLTLN (YDGRID)

IF (LLMGLO) THEN
  CALL OFA_GLO
ELSEIF (LLMLAM) THEN
  CALL OFA_LAM
ELSEIF (LLLTLN) THEN
  CALL OFA_LTL
ELSE
  CALL ABORT ('UNKNOWN GEOMETRY: '//YLCONF%JSON ())
ENDIF

BLOCK
  INTEGER (KIND=JPIM) :: INBARP, INBARI, IREP
  INBARP = 0; INBARI = 0
  CALL FAITOU (IREP, KLUN, .TRUE., TRIM (CDFILENAME), 'NEW', &
             & .TRUE., .TRUE., 2_JPIM, INBARP, INBARI, CLNOMC)
  CALL FACAGE (CLNOMC, .FALSE.)
  IF (LLMGLO) THEN
    CALL FAUTIF (IREP, KLUN, 'ARP')
  ELSEIF (LLMLAM) THEN
    CALL FAUTIF (IREP, KLUN, 'ALD')
  ELSEIF (LLLTLN) THEN
    CALL FAUTIF (IREP, KLUN, 'FULLPOS')
  ENDIF
ENDBLOCK

BLOCK
  INTEGER (KIND=JPIM) :: IDATEF (11), IREP
  IDATEF = [1990,  2, 15, 12,  0,   1,  0, 24,   1, 0, 0]
  CALL FANDAR (IREP, KLUN, IDATEF)
ENDBLOCK

CALL YLCONF%FINAL ()

CONTAINS

SUBROUTINE OFA_LTL

REAL (KIND=JPRB) :: ZAHYBR (2), ZBHYBR (2), ZSLAPO, ZCLOPO, ZSLOPO, ZCODIL, ZREFER, ZSINLA (18)
INTEGER (KIND=JPIM) :: INIVER, ITYPTR, ITRONC, INLATI, INXLON
INTEGER (KIND=JPIM) :: INLOPA (8), INOZPA (1)
REAL (KIND=JPRB) :: XMIN, XMAX, YMIN, YMAX
REAL (KIND=JPRB) :: DXINMETRES, DYINMETRES
REAL (KIND=JPRB) :: LOVINDEGREES, LADINDEGREES, LATIN1INDEGREES, LATIN2INDEGREES
INTEGER (KIND=JPIM) :: NUX, NUY, NX, NY
REAL (KIND=JPRB) :: ZLONW, ZLONE, ZLATN, ZLATS, ZLOND, ZLATD, ZLONC, ZLATC
CHARACTER (LEN=:), ALLOCATABLE :: CLDOTY
LOGICAL :: LLGLOBAL, LLFOUND

ZLONW =   0._JPRB
ZLONE = 360._JPRB
ZLATN = +90._JPRB
ZLATS = -90._JPRB
LLGLOBAL = .TRUE.

IF (YLCONF%GET ('domain.type', CLDOTY)) THEN
  LLGLOBAL = CLDOTY == 'global'
ENDIF

IF (LLGLOBAL) THEN
  IF (YLCONF%GET ('domain.west', ZLONW)) THEN
    ZLONW = MODULO (ZLONW, 360._JPRB)
  ENDIF
  ZLOND = 360._JPRB / REAL (YDGRID%NX (1), JPRB)
  IF (ZLONW > 0) ZLONW = ZLONW - 360._JPRB
  ZLONE = ZLONW + 360._JPRB - ZLOND
ELSE
  IF (YLCONF%GET ('domain.xmin', ZLONW)) THEN
    ZLONW = MODULO (ZLONW, 360._JPRB)
  ENDIF
  IF (YLCONF%GET ('domain.xmax', ZLONE)) THEN
    ZLONE = MODULO (ZLONE, 360._JPRB)
  ENDIF
  ZLOND = MODULO (ZLONE-ZLONW, 360._JPRB) / REAL (YDGRID%NX (1)-1, JPRB)
ENDIF

LLFOUND = YLCONF%GET ('domain.ymin', ZLATS)
LLFOUND = YLCONF%GET ('domain.ymax', ZLATN)

ZLATD = (ZLATN - ZLATS) / REAL (YDGRID%NY () - 1, JPRB)

ZLONC = ZLONW + (ZLOND * YDGRID%NX (1)) / 2._JPRB
ZLATC = ZLATS + (ZLATD * YDGRID%NY ( )) / 2._JPRB

ZLONW = ZLONW * DEG2RAD
ZLONE = ZLONE * DEG2RAD
ZLATN = ZLATN * DEG2RAD
ZLATS = ZLATS * DEG2RAD
ZLOND = ZLOND * DEG2RAD
ZLATD = ZLATD * DEG2RAD


INLATI = YDGRID%NY ( )
INXLON = YDGRID%NX (1)
ZSLAPO = 0._JPRB
ZCLOPO = 0._JPRB
ZSLOPO = 0._JPRB
ZCODIL = 0._JPRB
ZREFER = 0._JPRB
INIVER = 1_JPIM
ZAHYBR = 0._JPRB
ZBHYBR = 0._JPRB 
INLOPA = [10_JPIM, 0_JPIM, 1_JPIM, INXLON, 1_JPIM, INLATI, 0_JPIM, 0_JPIM]

ITRONC = +INLATI / 2 - 1
ITYPTR = -INXLON / 2 + 1

ZSINLA = [-1._JPRB, -9._JPRB, 0.0_JPRB, 0.0_JPRB,        &
          ZLOND, ZLATD, ZLONC, ZLATC,                    &
          0.0_JPRB, 0.0_JPRB, 0.0_JPRB, 0.0_JPRB,        &
          ZLONW, ZLATS, ZLONE, ZLATN, 0.0_JPRB, 0.0_JPRB]
          


CALL FACADE (CLNOMC, ITYPTR, ZSLAPO, ZCLOPO, ZSLOPO, &
&            ZCODIL, ITRONC, INLATI, INXLON, INLOPA, &
&            INOZPA, ZSINLA, INIVER, ZREFER, ZAHYBR, &
&            ZBHYBR, .FALSE.)

END SUBROUTINE OFA_LTL

SUBROUTINE OFA_LAM

REAL (KIND=JPRB) :: ZAHYBR (2), ZBHYBR (2), ZSLAPO, ZCLOPO, ZSLOPO, ZCODIL, ZREFER, ZSINLA (18)
INTEGER (KIND=JPIM) :: INIVER, ITYPTR, ITRONC, INLATI, INXLON
INTEGER (KIND=JPIM) :: INLOPA (8), INOZPA (1)
REAL (KIND=JPRB) :: XMIN, XMAX, YMIN, YMAX
REAL (KIND=JPRB) :: DXINMETRES, DYINMETRES
REAL (KIND=JPRB) :: LOVINDEGREES, LADINDEGREES, LATIN1INDEGREES, LATIN2INDEGREES
INTEGER (KIND=JPIM) :: NUX, NUY, NX, NY
REAL (KIND=JPRB) :: ZLONLATSW (2), ZLONLATNE (2)


#define get(x,y) \
IF (.NOT. YLCONF%GET (#x, y)) CALL ABORT ('CANNOT FIND '//#x)
get (projection.latitude0,  LADINDEGREES   ) 
get (projection.longitude0, LOVINDEGREES   ) 
get (projection.latitude1,  LATIN1INDEGREES) 
get (projection.latitude2,  LATIN2INDEGREES) 
get (domain.xmin,           XMIN           ) 
get (domain.xmax,           XMAX           ) 
get (domain.ymin,           YMIN           ) 
get (domain.ymax,           YMAX           ) 
get (xspace.N,              NX             ) 
get (yspace.N,              NY             ) 
#undef get

DXINMETRES = (XMAX - XMIN) / REAL (NX - 1, JPRB)
DYINMETRES = (YMAX - YMIN) / REAL (NY - 1, JPRB)

NUX =  NINT (-2 * XMIN / DXINMETRES)
NUY =  NINT (-2 * YMIN / DYINMETRES)

INLATI = NY
INXLON = NX
ZSLAPO = 0._JPRB
ZCLOPO = 0._JPRB
ZSLOPO = 0._JPRB
ZCODIL = 0._JPRB
ZREFER = 0._JPRB
INIVER = 1_JPIM
ZAHYBR = 0._JPRB
ZBHYBR = 0._JPRB 
INLOPA = [10_JPIM, 1_JPIM, 1_JPIM, NUX+1, 1_JPIM, NUY+1, 8_JPIM, 8_JPIM]
ITRONC = +INLATI / 2 - 1
ITYPTR = -INXLON / 2 + 1

ZLONLATSW = YDGRID%LONLAT (    1,     1)
ZLONLATNE = YDGRID%LONLAT (NUX+1, NUY+1)

ZSINLA = [-1._JPRB, SIN (DEG2RAD * LADINDEGREES), DEG2RAD * LOVINDEGREES, DEG2RAD * LADINDEGREES, &
       &  DEG2RAD * LOVINDEGREES, DEG2RAD * LADINDEGREES, DXINMETRES, DYINMETRES, &
       &  INXLON * DXINMETRES, INLATI * DYINMETRES, 0._JPRB, 0._JPRB, ZLONLATSW (1) * DEG2RAD, &
       &  ZLONLATSW (2) * DEG2RAD, ZLONLATNE (1) * DEG2RAD, ZLONLATNE (2) * DEG2RAD, 0._JPRB, 0._JPRB ]




CALL FACADE (CLNOMC, ITYPTR, ZSLAPO, ZCLOPO, ZSLOPO, &
&            ZCODIL, ITRONC, INLATI, INXLON, INLOPA, &
&            INOZPA, ZSINLA, INIVER, ZREFER, ZAHYBR, &
&            ZBHYBR, .FALSE.)

END SUBROUTINE OFA_LAM

SUBROUTINE OFA_GLO
REAL (KIND=JPRB) :: ZAHYBR (2), ZBHYBR (2), ZSLAPO, ZCLOPO, ZSLOPO, ZCODIL, ZREFER
INTEGER (KIND=JPIM) :: INIVER, ITYPTR, ITRONC, INLATI, INXLON
REAL (KIND=JPRB), ALLOCATABLE :: ZCENTRE (:), RMU (:)
CHARACTER (LEN=:), ALLOCATABLE :: CLPRTY
INTEGER (KIND=JPIM), ALLOCATABLE :: NLOENG (:), INOZPA (:)
INTEGER (KIND=JPIM) :: NDGLG, IGLG
LOGICAL :: LLFOUND

IF (.NOT. YLCONF%GET ('projection.type', CLPRTY)) THEN
  CALL ABORT ('UNKNOWN GEOMETRY'//YLCONF%JSON ())
ENDIF

IF (CLPRTY == 'rotated_schmidt') THEN
  LLFOUND = YLCONF%GET ("projection.north_pole",        ZCENTRE)
  LLFOUND = YLCONF%GET ("projection.stretching_factor", ZCODIL )
ELSE 
  ALLOCATE (ZCENTRE (2))
  ZCENTRE = [0._JPRB, 90._JPRB]
  ZCODIL = 1._JPRB
ENDIF

NDGLG  = YDGRID%NY ()
NLOENG = YDGRID%NX_ARRAY ()

INIVER = 1_JPIM
ZAHYBR = 0._JPRB
ZBHYBR = 0._JPRB
ITYPTR = 2_JPIM
!

ZSLAPO = SIN (ZCENTRE (2) * DEG2RAD)
ZCLOPO = COS (ZCENTRE (1) * DEG2RAD)
ZSLOPO = SIN (ZCENTRE (1) * DEG2RAD)
ITRONC = NDGLG-1
INLATI = NDGLG
INXLON = MAXVAL (NLOENG)
ALLOCATE (INOZPA (NDGLG))
INOZPA = MIN (ITRONC, NLOENG/2_JPIM-1_JPIM)
ZREFER = 1._JPRB

ALLOCATE (RMU (NDGLG))

DO IGLG = 1, NDGLG
  RMU (IGLG) = SIN (YDGRID%Y (IGLG) * DEG2RAD)
ENDDO

CALL FACADE (CLNOMC, ITYPTR, ZSLAPO, ZCLOPO, ZSLOPO, &
&            ZCODIL, ITRONC, INLATI, INXLON, NLOENG, &
&            INOZPA, RMU,    INIVER, ZREFER, ZAHYBR, &
&            ZBHYBR, .FALSE.)

    
END SUBROUTINE OFA_GLO

END SUBROUTINE OFA

END MODULE

