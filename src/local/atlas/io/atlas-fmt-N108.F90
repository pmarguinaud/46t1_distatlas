MODULE ATLAS_FMT_N108

USE ATLAS_FMT, ONLY : ATLAS_FMT_t

USE PARKIND1, ONLY : JPRB, JPIM, JPIA, JPIB
USE ATLAS_MODULE

#include "atlas-abort.h"

IMPLICIT NONE

TYPE, EXTENDS (ATLAS_FMT_t) :: ATLAS_FMT_N108_t

  INTEGER (KIND=JPIA) :: IFP = 0

CONTAINS

  PROCEDURE :: OPEN
  PROCEDURE :: CLOSE
  PROCEDURE :: GRID
  PROCEDURE :: READ    
  PROCEDURE :: WRITE   

END TYPE

PRIVATE

PUBLIC :: ATLAS_FMT_N108_t

INTEGER (KIND=JPIM), PARAMETER :: ILAT = 216, ILON = 432

CONTAINS

TYPE (ATLAS_STRUCTUREDGRID) FUNCTION GRID (THIS, CDFILE) RESULT (YLGRID)
CLASS (ATLAS_FMT_N108_t), INTENT (IN) :: THIS
CHARACTER (LEN=*),        INTENT (IN) :: CDFILE


BLOCK
  TYPE (ATLAS_CONFIG) :: YLCFGR, YLCFDO
  REAL (KIND=JPRB) :: ZLONW, ZLATS, ZLONE, ZLATN, ZLOND, ZLATD

  ZLOND = 360._JPRB / REAL (ILON, JPRB)
  ZLATD = 180._JPRB / REAL (ILAT, JPRB)
  ZLONW =   0._JPRB + ZLOND / 2._JPRB
  ZLONE = 360._JPRB - ZLOND / 2._JPRB
  ZLATS = -90._JPRB + ZLATD / 2._JPRB
  ZLATN = +90._JPRB - ZLATD / 2._JPRB

  YLCFGR = ATLAS_CONFIG ()
  YLCFDO = ATLAS_CONFIG ()

  CALL YLCFGR%SET ("nx", ILON)
  CALL YLCFGR%SET ("ny", ILAT)
  CALL YLCFGR%SET ("type", "shifted_lonlat")
  CALL YLCFDO%SET ("type", "global") 
  CALL YLCFDO%SET ("xmin", ZLONW)
  CALL YLCFDO%SET ("xmax", ZLONE+ZLOND)
  CALL YLCFDO%SET ("west", ZLOND / 2._JPRB)

  CALL YLCFDO%SET ("ymin", ZLATS)
  CALL YLCFDO%SET ("ymax", ZLATN)
  CALL YLCFDO%SET ("units", "degrees")
  CALL YLCFGR%SET ("domain", YLCFDO)

  YLGRID = ATLAS_STRUCTUREDGRID (YLCFGR)

  CALL YLCFGR%FINAL ()
  CALL YLCFDO%FINAL ()
ENDBLOCK

CALL YLGRID%RETURN ()

END FUNCTION

SUBROUTINE OPEN (THIS, CDFILE, YDGRID)
CLASS (ATLAS_FMT_N108_t),     INTENT (INOUT) :: THIS
CHARACTER (LEN=*),            INTENT (IN)    :: CDFILE
CLASS (ATLAS_STRUCTUREDGRID), INTENT (IN)    :: YDGRID
CALL FI_FOPEN (THIS%IFP, TRIM (CDFILE), "r")
IF (THIS%IFP == 0) THEN
  CALL ABORT ('ATLAS_FMT_N108:OPEN CANNOT OPEN '//TRIM (CDFILE))
ENDIF
END SUBROUTINE OPEN

SUBROUTINE CLOSE (THIS)
CLASS (ATLAS_FMT_N108_t),  INTENT (INOUT) :: THIS
INTEGER (KIND=JPIM) :: IERR
CALL FI_FCLOSE (IERR, THIS%IFP)
END SUBROUTINE


SUBROUTINE READ (THIS, CDNAME, PFLDG, LDUNDEF, PUNDEF)
CLASS (ATLAS_FMT_N108_t),  INTENT (IN)    :: THIS
CHARACTER (LEN=*),         INTENT (IN)    :: CDNAME
REAL (KIND=JPRB),          INTENT (OUT)   :: PFLDG (:)
LOGICAL,                   INTENT (INOUT) :: LDUNDEF
REAL (KIND=JPRB),          INTENT (INOUT) :: PUNDEF

INTEGER (KIND=JPIM) :: J, IMONTH
INTEGER (KIND=JPIM) :: IERR4, ILEN4
INTEGER (KIND=JPIB) :: IOFF8, IBLK8, IERR8, ILEN8

IBLK8 = ILAT * (8 + ILON * 8)

IF (TRIM (CDNAME) == 'LFrac') THEN
  IOFF8 = 0
ELSEIF (TRIM (CDNAME) == 'OrogG') THEN
  IOFF8 = 1
ELSEIF (TRIM (CDNAME) == 'IFrac') THEN
  IOFF8 = 2
ELSEIF (LCMPM (CDNAME, 'Temp_g', IMONTH)) THEN
  IOFF8 = 3 + 3 * (IMONTH - 1)
ELSEIF (LCMPM (CDNAME, 'Temp_d', IMONTH)) THEN
  IOFF8 = 4 + 3 * (IMONTH - 1)
ELSEIF (LCMPM (CDNAME, 'Temp_s', IMONTH)) THEN
  IOFF8 = 5 + 3 * (IMONTH - 1)
ELSE
  CALL ABORT ('ATLAS_FMT_N108:READ: UNEXPECTED FIELD '//TRIM (CDNAME))
ENDIF

IOFF8 = IOFF8 * IBLK8 
ILEN8 = ILON * 8

CALL FI_FSEEK (IERR4, THIS%IFP, IOFF8, 0_JPIM)

DO J = 1, ILAT

! Fortran unformatted control word
  CALL FI_FREAD (IERR8, ILEN4, 4_JPIB, 1_JPIB, THIS%IFP)
  CALL ISWAP (ILEN4, ILEN4, 4_JPIM, 1_JPIM)
  IF (ILEN4 /= ILEN8) CALL ABORT ('ATLAS_FMT_N108:READ: UNEXPECTED SIZE')

! Read IEEE data
  CALL FI_FREAD (IERR8, PFLDG (1+(J-1)*ILON), ILEN8, 1_JPIB, THIS%IFP)
  IF (IERR8 /= 1) CALL ABORT ('ATLAS_FMT_N108:READ: UNEXPECTED END OF FILE')
  CALL ISWAP (PFLDG (1+(J-1)*ILON), PFLDG (1+(J-1)*ILON), 8_JPIM, ILON)

! Fortran unformatted control word
  CALL FI_FREAD (IERR8, ILEN4, 4_JPIB, 1_JPIB, THIS%IFP)
  CALL ISWAP (ILEN4, ILEN4, 4_JPIM, 1_JPIM)
  IF (ILEN4 /= ILEN8) CALL ABORT ('ATLAS_FMT_N108:READ: UNEXPECTED SIZE')

ENDDO

CONTAINS

LOGICAL FUNCTION LCMPM (CDNAME1, CDNAME2, IMONTH) 

CHARACTER (LEN=*),   INTENT (IN)  :: CDNAME1, CDNAME2
INTEGER (KIND=JPIM), INTENT (OUT) :: IMONTH

INTEGER (KIND=JPIM) :: ILEN1, ILEN2

IMONTH = -1
LCMPM = .FALSE.

ILEN1 = LEN_TRIM (CDNAME1)
ILEN2 = LEN_TRIM (CDNAME2)

IF (ILEN1 /= ILEN2 + 4) RETURN
IF (CDNAME1 (1:ILEN2) /= TRIM (CDNAME2)) RETURN
IF (CDNAME1 (ILEN2+1:ILEN2+2) /= '.m') RETURN

READ (CDNAME1 (ILEN2+3:ILEN1), *) IMONTH

IF ((IMONTH < 1) .OR. (12 < IMONTH)) RETURN

LCMPM = .TRUE.

END FUNCTION LCMPM

END SUBROUTINE

SUBROUTINE WRITE (THIS, CDNAME, PFLDG, LDUNDEF, PUNDEF)
CLASS (ATLAS_FMT_N108_t), INTENT (IN)    :: THIS
CHARACTER (LEN=*),        INTENT (IN)    :: CDNAME
REAL (KIND=JPRB),         INTENT (IN)    :: PFLDG (:)
LOGICAL,                  INTENT (INOUT) :: LDUNDEF
REAL (KIND=JPRB),         INTENT (INOUT) :: PUNDEF

CALL ABORT ('ATLAS_FMT_N108:WRITE: NOT IMPLEMENTED')

END SUBROUTINE

END MODULE

