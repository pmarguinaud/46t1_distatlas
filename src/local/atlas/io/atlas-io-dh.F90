MODULE ATLAS_IO_DH

USE FCKIT_MODULE, ONLY : FCKIT_MPI_COMM

USE ATLAS_IO, ONLY : ATLAS_IO_t

USE PARKIND1, ONLY : JPRB, JPIM, JPIB, JPIA
USE ATLAS_MODULE

#include "atlas-abort.h"

IMPLICIT NONE

TYPE, EXTENDS (ATLAS_IO_t) :: ATLAS_IO_DH_t

! Domain restriction
  REAL (KIND=JPRB) :: ZLONW = -180._JPRB, ZLONE = +180._JPRB
  REAL (KIND=JPRB) :: ZLATS =  -90._JPRB, ZLATN =  +90._JPRB

CONTAINS
  PROCEDURE :: GRID
  PROCEDURE :: READ    
  PROCEDURE :: WRITE   
END TYPE

PRIVATE

PUBLIC :: ATLAS_IO_DH_t

INTERFACE ATLAS_IO_DH_t
  MODULE PROCEDURE ATLAS_IO_DH_t_ctor
END INTERFACE 

TYPE HDR_t
  REAL (KIND=JPRB) :: RUNDEF = HUGE (0._JPRB)
  REAL (KIND=JPRB) :: ZWEST = -999, ZEAST = -999, ZNORTH = -999, ZSOUTH = -999
  INTEGER (KIND=JPIM) :: ICOLS = -999, IROWS = -999, IWIDTH = -999
  CHARACTER (LEN=256) :: CLCOMMENT = ''
END TYPE HDR_t

TYPE RES_t
  LOGICAL :: LLGLOBAL = .TRUE.
  INTEGER (KIND=JPIM) :: ICOLS, ICOL1, ICOL2
  INTEGER (KIND=JPIM) :: IROWS, IROW1, IROW2
  REAL (KIND=JPRB) :: ZLOND, ZLATD, ZLONW, ZLONE, ZLATS, ZLATN
END TYPE RES_t

CONTAINS

FUNCTION ATLAS_IO_DH_t_ctor (YDGRID) RESULT (THIS)

TYPE (ATLAS_STRUCTUREDGRID), INTENT (IN) :: YDGRID

TYPE (ATLAS_IO_DH_t) :: THIS
TYPE (ATLAS_LONLATRECTANGULARDOMAIN) :: YLBB
REAL (KIND=JPRB)  :: ZDM
TYPE (ATLAS_CONFIG) :: YLCONF
CHARACTER (LEN=:), ALLOCATABLE :: CLDOTY
INTEGER (KIND=JPIM) :: I, INX, INY, INM

YLCONF = YDGRID%SPEC ()

IF (YLCONF%GET ('domain.type', CLDOTY)) THEN
  IF (CLDOTY == 'global') GOTO 999
ENDIF

YLBB = YDGRID%LONLAT_BOUNDING_BOX ()

THIS%ZLONW = YLBB%WEST  (); THIS%ZLONE = YLBB%EAST  ()
THIS%ZLATS = YLBB%SOUTH (); THIS%ZLATN = YLBB%NORTH ()

#if 0
PRINT *, " THIS%ZLONW = ", THIS%ZLONW
PRINT *, " THIS%ZLONE = ", THIS%ZLONE
PRINT *, " THIS%ZLATS = ", THIS%ZLATS
PRINT *, " THIS%ZLATN = ", THIS%ZLATN
#endif

INY = YDGRID%NY ()
INX = YDGRID%NX (1)

DO I = 1, INY
  INX = MIN (YDGRID%NX (I), INX)
ENDDO

INM = MIN (INX, INY)
ZDM = MAX (MODULO (THIS%ZLONE - THIS%ZLONW, 360._JPRB), THIS%ZLATN - THIS%ZLATS)

#if 0
PRINT *, " ZDM = ", ZDM
PRINT *, " INM = ", INM
PRINT *, ZDM / INM
#endif


999 CONTINUE

CALL YLCONF%FINAL ()

END FUNCTION ATLAS_IO_DH_t_ctor

TYPE (RES_t) FUNCTION RES (THIS, YDHDR) RESULT (YLRES)
CLASS (ATLAS_IO_DH_t), INTENT (IN) :: THIS
TYPE (HDR_t) :: YDHDR
REAL (KIND=JPRB) :: ZMARGIN = 1._JPRB ! extends domain by 1 degree

YLRES%LLGLOBAL = (THIS%ZLONE - THIS%ZLONW == 360._JPRB) &
  & .AND.  (THIS%ZLATS ==  -90._JPRB) .AND.  (THIS%ZLATN ==  +90._JPRB) 

IF (.NOT. YLRES%LLGLOBAL) THEN
  YLRES%ZLOND = MODULO (YDHDR%ZEAST  - YDHDR%ZWEST , 360._JPRB) / YDHDR%ICOLS
  
  IF (YLRES%ZLOND == 0._JPRB) THEN
    YLRES%ZLOND = 360._JPRB / YDHDR%ICOLS
  ENDIF
  
  YLRES%ZLATD = (YDHDR%ZNORTH - YDHDR%ZSOUTH) / YDHDR%IROWS

  YLRES%ICOL1 = MAX (          1, FLOOR   (0.5_JPRB + (THIS%ZLONW - ZMARGIN - YDHDR%ZWEST) / YLRES%ZLOND))
  YLRES%ICOL2 = MIN (YDHDR%ICOLS, CEILING (0.5_JPRB + (THIS%ZLONE + ZMARGIN - YDHDR%ZWEST) / YLRES%ZLOND))
  YLRES%IROW1 = MAX (          1, FLOOR   (0.5_JPRB + (90._JPRB - (THIS%ZLATN + ZMARGIN)) / YLRES%ZLATD))
  YLRES%IROW2 = MIN (YDHDR%IROWS, CEILING (0.5_JPRB + (90._JPRB - (THIS%ZLATS - ZMARGIN)) / YLRES%ZLATD))

  ! Atlas does not like odd dimensions
  IF (MODULO (YLRES%ICOL2 - YLRES%ICOL1 + 1, 2) == 1) YLRES%ICOL2 = YLRES%ICOL2 + 1
  IF (MODULO (YLRES%IROW2 - YLRES%IROW1 + 1, 2) == 1) YLRES%IROW2 = YLRES%IROW2 + 1

  YLRES%ZLONW = YLRES%ZLOND * (YLRES%ICOL1 - 0.5_JPRB) + YDHDR%ZWEST
  YLRES%ZLONE = YLRES%ZLOND * (YLRES%ICOL2 - 0.5_JPRB) + YDHDR%ZWEST
  YLRES%ZLATS = 90.0_JPRB - YLRES%ZLATD * (YLRES%IROW1 - 0.5_JPRB)
  YLRES%ZLATN = 90.0_JPRB - YLRES%ZLATD * (YLRES%IROW2 - 0.5_JPRB)

  YLRES%ICOLS = YLRES%ICOL2 - YLRES%ICOL1 + 1
  YLRES%IROWS = YLRES%IROW2 - YLRES%IROW1 + 1

ENDIF

END FUNCTION RES

TYPE (ATLAS_STRUCTUREDGRID) FUNCTION GRID (THIS, CDFILE) RESULT (YLGRID)
CLASS (ATLAS_IO_DH_t), INTENT (IN) :: THIS
CHARACTER (LEN=*),  INTENT (IN) :: CDFILE

TYPE (HDR_t) :: YLHDR
TYPE (RES_t) :: YLRES

YLHDR = HDR (CDFILE)
YLRES = RES (THIS, YLHDR)

IF (YLRES%LLGLOBAL) THEN
BLOCK
  TYPE (ATLAS_CONFIG) :: YLCFGR, YLCFDO
  YLCFGR = ATLAS_CONFIG ()
  YLCFDO = ATLAS_CONFIG ()
  CALL YLCFGR%SET ("nx", YLHDR%ICOLS)
  CALL YLCFGR%SET ("ny", YLHDR%IROWS)
  CALL YLCFGR%SET ("type", "shifted_lonlat")
  CALL YLCFDO%SET ("type", "global")
  CALL YLCFDO%SET ("units", "degrees")
  CALL YLCFDO%SET ("west", YLHDR%ZWEST)
  CALL YLCFGR%SET ("domain", YLCFDO)
  YLGRID = ATLAS_STRUCTUREDGRID (YLCFGR)
  CALL YLCFGR%FINAL ()
  CALL YLCFDO%FINAL ()
ENDBLOCK
ELSE
BLOCK
  YLGRID = ATLAS_REGIONALGRID (NX=YLRES%ICOLS, NY=YLRES%IROWS, &
         & NORTH=YLRES%ZLATN, WEST=YLRES%ZLONW, SOUTH=YLRES%ZLATS, EAST=YLRES%ZLONE)
ENDBLOCK
ENDIF

CALL YLGRID%RETURN ()

END FUNCTION

TYPE (ATLAS_FIELDSET) FUNCTION READ (THIS, CDFILE, CDNAME, YDSTCO, PUNDEF, PSCALE) RESULT (YLFLST)
CLASS (ATLAS_IO_DH_t), INTENT (IN) :: THIS
CHARACTER (LEN=*),  INTENT (IN) :: CDFILE
CHARACTER (LEN=*),  INTENT (IN) :: CDNAME (:)
TYPE (ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS), INTENT (IN) :: YDSTCO
REAL (KIND=JPRB),   INTENT (IN), OPTIONAL :: PUNDEF, PSCALE
TYPE (ATLAS_FIELD) :: YLFLD


YLFLST = ATLAS_FIELDSET ()

YLFLD = DIR (THIS, CDFILE, YDSTCO, PUNDEF, PSCALE)
CALL YLFLD%RENAME (CDNAME (1))

CALL YLFLST%ADD (YLFLD)

CALL YLFLD%FINAL ()
CALL YLFLST%RETURN ()

END FUNCTION

SUBROUTINE WRITE (THIS, CDFILE, YDFLST, YDSTCO)
CLASS (ATLAS_IO_DH_t),    INTENT (IN) :: THIS
CHARACTER (LEN=*),     INTENT (IN) :: CDFILE
TYPE (ATLAS_FIELDSET), INTENT (IN) :: YDFLST
TYPE (ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS), INTENT (IN) :: YDSTCO

CALL ABORT ('ATLAS_IO_DH:WRITE NOT IMPLEMENTED')

END SUBROUTINE

TYPE (HDR_t) FUNCTION HDR (CDFILE) RESULT (YLHDR)

CHARACTER (LEN=*), INTENT (IN)  :: CDFILE

CHARACTER (LEN=256) :: CLLINE
INTEGER (KIND=JPIA) :: IFP
INTEGER (KIND=JPIB) :: ISIZE
INTEGER (KIND=JPIM) :: IERR

CALL FI_FOPEN (IFP, TRIM (CDFILE)//'.hdr', "r")

CALL FI_GETLINE (CLLINE, ISIZE, IFP)

YLHDR%CLCOMMENT = CLLINE

DO 
  CALL FI_GETLINE (CLLINE, ISIZE, IFP)
  IF (ISIZE == -1) EXIT
  IF (CLLINE (1:7) == 'nodata:'             ) READ (CLLINE ( 8:), *) YLHDR%RUNDEF
  IF (CLLINE (1:6) == 'north:'              ) READ (CLLINE ( 7:), *) YLHDR%ZNORTH
  IF (CLLINE (1:6) == 'south:'              ) READ (CLLINE ( 7:), *) YLHDR%ZSOUTH
  IF (CLLINE (1:5) == 'west:'               ) READ (CLLINE ( 6:), *) YLHDR%ZWEST
  IF (CLLINE (1:5) == 'east:'               ) READ (CLLINE ( 6:), *) YLHDR%ZEAST
  IF (CLLINE (1:5) == 'rows:'               ) READ (CLLINE ( 6:), *) YLHDR%IROWS
  IF (CLLINE (1:5) == 'cols:'               ) READ (CLLINE ( 6:), *) YLHDR%ICOLS
  IF (CLLINE (1:19) == 'recordtype: integer') READ (CLLINE (20:), *) YLHDR%IWIDTH
ENDDO

999 CONTINUE

CALL FI_FCLOSE (IERR, IFP)

SELECT CASE (YLHDR%IWIDTH)
  CASE ( 8)
    IF (YLHDR%RUNDEF < 0) YLHDR%RUNDEF = YLHDR%RUNDEF + 256._JPRB
  CASE DEFAULT
END SELECT

END FUNCTION

FUNCTION DIR (THIS, CDFILE, YDFSSC, PUNDEF, PSCALE) RESULT (YLFLD)

TYPE (ATLAS_FIELD) :: YLFLD

CLASS (ATLAS_IO_DH_t),                        INTENT (IN) :: THIS
CHARACTER (LEN=*),                            INTENT (IN) :: CDFILE
TYPE (ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS), INTENT (IN) :: YDFSSC
REAL (KIND=JPRB),                             INTENT (IN), OPTIONAL :: PUNDEF, PSCALE

INTEGER (KIND=JPIM), ALLOCATABLE :: ISIZE (:), IOFFS (:)
INTEGER (KIND=JPIM) :: IPROC, INX, NPROC, IROWLENG, ICOLLENG

INTEGER*1, ALLOCATABLE :: IL1 (:)
INTEGER*2, ALLOCATABLE :: IL2 (:)
INTEGER (KIND=JPIM) :: IOFF, JLAT,  IRANK, I
INTEGER (KIND=JPIM) :: IROW, IROW1, IROW2
INTEGER (KIND=JPIM) :: ICOL, ICOL1, ICOL2
REAL (KIND=JPRB), POINTER :: ZDATA (:)
TYPE (ATLAS_STRUCTUREDGRID) :: YLGRID
TYPE (HDR_t) :: YLHDR
TYPE (RES_t) :: YLRES
TYPE (FCKIT_MPI_COMM) :: YLCOMM
TYPE (ATLAS_METADATA) :: YLMETA
INTEGER (KIND=JPIA) :: IFP
INTEGER (KIND=JPIM) :: IERR
INTEGER (KIND=JPIB) :: IOFF8, ILEN8, IERR8

YLHDR = HDR (CDFILE)
YLRES = RES (THIS, YLHDR)

YLCOMM = FCKIT_MPI_COMM ()
IRANK = YLCOMM%RANK ()
NPROC = YLCOMM%SIZE ()

YLGRID = YDFSSC%GRID ()


YLFLD = ATLAS_FIELD (NAME=TRIM (CDFILE), KIND=JPRB, SHAPE=[YDFSSC%SIZE ()])

CALL YLFLD%DATA (ZDATA)

ALLOCATE (ISIZE (NPROC), IOFFS (NPROC + 1))

IF (NPROC > 1) THEN
  CALL YLCOMM%ALLGATHER ([YDFSSC%SIZE_OWNED ()], ISIZE, 1, &
                       & [(1, I = 0, YLCOMM%SIZE ())],     &
                       & [(I, I = 0, YLCOMM%SIZE ())]);
ELSE
  ISIZE = YDFSSC%SIZE_OWNED ()
ENDIF

IOFFS (1) = 0
DO IPROC = 2, NPROC+1
  IOFFS (IPROC) = IOFFS (IPROC-1) + ISIZE (IPROC-1)
ENDDO

IPROC = IRANK + 1

INX = YLGRID%NX (1)

IF (MODULO (IOFFS (IPROC), INX) /= 0) THEN
  CALL ABORT ('DIR: DISTRIBUTION MISMATCH')
ENDIF

IF (YLRES%LLGLOBAL) THEN
  IROW1 = 1 + IOFFS (IPROC+0) / INX
  IROW2 = 0 + IOFFS (IPROC+1) / INX
  ICOL1 = 1
  ICOL2 = YLHDR%ICOLS
ELSE
  IROW1 = YLRES%IROW1 - 0 + IOFFS (IPROC+0) / INX
  IROW2 = YLRES%IROW1 - 1 + IOFFS (IPROC+1) / INX
  ICOL1 = YLRES%ICOL1
  ICOL2 = YLRES%ICOL2
ENDIF

IF (SIZE (ZDATA) < INX * (IROW2-IROW1+1)) THEN
  CALL ABORT ('DIR: ZDATA IS TOO SMALL')
ENDIF


CALL FI_FOPEN (IFP, TRIM (CDFILE)//'.dir', "r")

IROWLENG = (YLHDR%ICOLS * YLHDR%IWIDTH) / 8
ICOLLENG = YLHDR%IWIDTH / 8

SELECT CASE (YLHDR%IWIDTH)

  CASE ( 8)
  
    ALLOCATE (IL1 (INX))

    IOFF = 0
    DO IROW = IROW1, IROW2
      IOFF8 = (IROW-1)*IROWLENG+(ICOL1-1)*ICOLLENG
      ILEN8 = INX
      CALL FI_FSEEK (IERR, IFP, IOFF8, 0_JPIM)
      CALL FI_FREAD (IERR8, IL1, ILEN8, 1_JPIB, IFP)
      WHERE (IL1 < 0)
        ZDATA (IOFF+1:IOFF+INX) = IL1 + 256
      ELSEWHERE
        ZDATA (IOFF+1:IOFF+INX) = IL1 
      ENDWHERE
      IOFF = IOFF + INX
    ENDDO

  CASE (16)

    ALLOCATE (IL2 (INX))

    IOFF = 0
    DO IROW = IROW1, IROW2
      IOFF8 = (IROW-1)*IROWLENG+(ICOL1-1)*ICOLLENG
      ILEN8 = INX * 2
      CALL FI_FSEEK (IERR, IFP, IOFF8, 0_JPIM)
      CALL FI_FREAD (IERR8, IL2, ILEN8, 1_JPIB, IFP)
      CALL ISWAP (IL2, IL2, 2_JPIM, INT (INX, JPIM))
      ZDATA (IOFF+1:IOFF+INX) = IL2 
      IOFF = IOFF + INX
    ENDDO

  CASE DEFAULT

    STOP

END SELECT

CALL FI_FCLOSE (IERR, IFP)

CALL YLCOMM%FINAL ()
CALL YLGRID%FINAL ()

IF (PRESENT (PSCALE)) THEN
  WHERE (ZDATA /= YLHDR%RUNDEF)
    ZDATA = ZDATA * PSCALE
  END WHERE
ENDIF

IF (PRESENT (PUNDEF)) THEN
  WHERE (ZDATA == YLHDR%RUNDEF)
    ZDATA = PUNDEF
  END WHERE
  YLHDR%RUNDEF = PUNDEF
ENDIF

YLMETA = YLFLD%METADATA ()
CALL YLMETA%SET ("undef", YLHDR%RUNDEF)
CALL YLMETA%FINAL ()

CALL YLFLD%RETURN ()

END FUNCTION

END MODULE

