MODULE ATLAS_IO_GATHSCAT

USE FCKIT_MODULE, ONLY : FCKIT_MPI_COMM

USE ATLAS_IO, ONLY : ATLAS_IO_t
USE ATLAS_FMT, ONLY : ATLAS_FMT_t

USE PARKIND1, ONLY : JPRB, JPIM
USE ATLAS_MODULE

#include "atlas-abort.h"

IMPLICIT NONE

TYPE, EXTENDS (ATLAS_IO_t) :: ATLAS_IO_GATHSCAT_t

  CLASS (ATLAS_FMT_t), POINTER :: YLFMT => NULL ()
  INTEGER (KIND=JPIM) :: NPRC = -1, NFLD = -1

CONTAINS

  PROCEDURE :: GRID
  PROCEDURE :: READ    
  PROCEDURE :: WRITE   

  PROCEDURE, PRIVATE :: WRITESET
  PROCEDURE, PRIVATE :: READSET

END TYPE

PRIVATE

PUBLIC :: ATLAS_IO_GATHSCAT_t

INTERFACE ATLAS_IO_GATHSCAT_t
  MODULE PROCEDURE :: ATLAS_IO_GATHSCAT_t_ctor
END INTERFACE

CONTAINS

TYPE (ATLAS_IO_GATHSCAT_t) FUNCTION ATLAS_IO_GATHSCAT_t_ctor (YLFMT, KPRC, KFLD) RESULT (THIS)
CLASS (ATLAS_FMT_t), TARGET :: YLFMT
INTEGER (KIND=JPIM), OPTIONAL, INTENT (IN) :: KPRC, KFLD

THIS%YLFMT => YLFMT

IF (PRESENT (KPRC)) THIS%NPRC = KPRC
IF (PRESENT (KFLD)) THIS%NFLD = KFLD

END FUNCTION

TYPE (ATLAS_STRUCTUREDGRID) FUNCTION GRID (THIS, CDFILE) RESULT (YLGRID)
CLASS (ATLAS_IO_GATHSCAT_t), INTENT (IN) :: THIS
CHARACTER (LEN=*),           INTENT (IN) :: CDFILE

YLGRID = THIS%YLFMT%GRID (CDFILE)

CALL YLGRID%RETURN ()

END FUNCTION

TYPE (ATLAS_FIELDSET) FUNCTION READ (THIS, CDFILE, CDNAME, YDSTCO, PUNDEF, PSCALE) RESULT (YLFLST)

USE FCKIT_MODULE, ONLY : FCKIT_MPI_COMM

CLASS (ATLAS_IO_GATHSCAT_t),                  INTENT (IN) :: THIS
CHARACTER (LEN=*),                            INTENT (IN) :: CDFILE
CHARACTER (LEN=*),                            INTENT (IN) :: CDNAME (:)
TYPE (ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS), INTENT (IN) :: YDSTCO
REAL (KIND=JPRB), OPTIONAL,                   INTENT (IN) :: PUNDEF, PSCALE

INTEGER (KIND=JPIM) :: INFLD, ISFLD, JFLD, JFLD1, JFLD2, IFLD
TYPE (ATLAS_FIELDSET) YLFLST_

YLFLST = ATLAS_FIELDSET ()
INFLD  = SIZE (CDNAME)
ISFLD  = INFLD
IF (THIS%NFLD > 0) ISFLD = THIS%NFLD

DO JFLD = 1, INFLD, ISFLD
  JFLD1 = JFLD
  JFLD2 = MIN (INFLD, JFLD+ISFLD-1)
  YLFLST_ = THIS%READSET (CDFILE, CDNAME (JFLD1:JFLD2), YDSTCO, PUNDEF, PSCALE)
  DO IFLD = 1, YLFLST_%SIZE ()
    CALL YLFLST%ADD (YLFLST_%FIELD (IFLD))
  ENDDO
  CALL YLFLST_%FINAL ()
ENDDO

END FUNCTION

TYPE (ATLAS_FIELDSET) FUNCTION READSET (THIS, CDFILE, CDNAME, YDSTCO, PUNDEF, PSCALE) RESULT (YLFLST)

USE FCKIT_MODULE, ONLY : FCKIT_MPI_COMM

CLASS (ATLAS_IO_GATHSCAT_t),                  INTENT (IN) :: THIS
CHARACTER (LEN=*),                            INTENT (IN) :: CDFILE
CHARACTER (LEN=*),                            INTENT (IN) :: CDNAME (:)
TYPE (ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS), INTENT (IN) :: YDSTCO
REAL (KIND=JPRB), OPTIONAL,                   INTENT (IN) :: PUNDEF, PSCALE

INTEGER (KIND=JPIM) :: MYPROC, NPROC, IPROC
INTEGER (KIND=JPIM) :: JFLD1, JFLD2, INFLD, JFLD
INTEGER (KIND=JPIM) :: IFROM (SIZE (CDNAME))
TYPE (ATLAS_FIELD)  :: YLFLDL (SIZE (CDNAME))
TYPE (ATLAS_FIELD)  :: YLFLDG (SIZE (CDNAME))
TYPE (ATLAS_FIELDSET) :: YLFLSG
TYPE (FCKIT_MPI_COMM) :: YLCOMM
TYPE (ATLAS_STRUCTUREDGRID) :: YLGRID
LOGICAL, ALLOCATABLE :: LLUNDEF (:)
REAL (KIND=JPRB), ALLOCATABLE :: ZUNDEF (:)

YLGRID = YDSTCO%GRID ()
YLCOMM = FCKIT_MPI_COMM ()
MYPROC = YLCOMM%RANK () + 1
NPROC  = YLCOMM%SIZE ()
INFLD  = SIZE (CDNAME)

ALLOCATE (LLUNDEF (INFLD), ZUNDEF (INFLD))

YLFLST = ATLAS_FIELDSET ()
YLFLSG = ATLAS_FIELDSET ()

DO IPROC = 1, NPROC
  JFLD1 = 1 + ((IPROC-1) * INFLD) / NPROC
  JFLD2 = 0 + ((IPROC+0) * INFLD) / NPROC
  IFROM (JFLD1:JFLD2) = IPROC
ENDDO

CALL THIS%YLFMT%OPEN (CDFILE, YLGRID)

DO JFLD = 1, INFLD
BLOCK
  TYPE (ATLAS_METADATA) :: YLMETA
  REAL (KIND=JPRB), POINTER :: ZFLDL (:)
  INTEGER (KIND=JPIM) :: ISIZEG

! Global field; zero size if this proc does not read the field
  ISIZEG = 0
  IF (IFROM (JFLD) == MYPROC) ISIZEG = INT (YLGRID%SIZE (), JPIM)
  YLFLDG (JFLD) = ATLAS_FIELD (NAME=TRIM (CDNAME (JFLD)), KIND=JPRB, SHAPE=[ISIZEG])
  YLMETA = YLFLDG (JFLD)%METADATA ()
! Set owner
  CALL YLMETA%SET ("owner", IFROM (JFLD)-1)
  CALL YLMETA%FINAL ()
  CALL YLFLSG%ADD (YLFLDG (JFLD))

! Distributed field : created by space function
  YLFLDL (JFLD) = YDSTCO%CREATE_FIELD (NAME=TRIM (CDNAME (JFLD)), KIND=JPRB)
  CALL YLFLDL (JFLD)%DATA (ZFLDL)
  ZFLDL = 0._JPRB ! Not necessary
  CALL YLFLST%ADD (YLFLDL (JFLD))
ENDBLOCK
ENDDO

LLUNDEF = .TRUE.
ZUNDEF  = HUGE (1._JPRB)
IF (PRESENT (PUNDEF)) ZUNDEF = PUNDEF

DO JFLD = 1, INFLD
  IF (IFROM (JFLD) == MYPROC) THEN
  BLOCK
    REAL (KIND=JPRB), POINTER :: ZFLDG (:)
    CALL YLFLDG (JFLD)%DATA (ZFLDG)
    CALL THIS%YLFMT%READ (CDNAME (JFLD), ZFLDG, LLUNDEF (JFLD), ZUNDEF (JFLD))
  ENDBLOCK
  ENDIF
ENDDO

CALL YDSTCO%SCATTER (YLFLSG, YLFLST)

CALL THIS%YLFMT%CLOSE ()

! Add undef metadata

DO JFLD = 1, INFLD
  CALL YLCOMM%BROADCAST (ZUNDEF (JFLD), IFROM (JFLD)-1)
  CALL YLCOMM%BROADCAST (LLUNDEF (JFLD), IFROM (JFLD)-1)
ENDDO

DO JFLD = 1, INFLD
  IF (LLUNDEF (JFLD)) THEN
    BLOCK
      REAL (KIND=JPRB), POINTER :: ZFLDL (:)
      TYPE (ATLAS_METADATA) :: YLMETA
      YLMETA = YLFLDL (JFLD)%METADATA ()
      CALL YLMETA%SET ("undef", ZUNDEF (JFLD))
      CALL YLMETA%FINAL ()
      CALL YLFLDL (JFLD)%DATA (ZFLDL)
      IF (PRESENT (PSCALE)) THEN
        WHERE (ZFLDL /= ZUNDEF (JFLD)) 
          ZFLDL = ZFLDL * PSCALE
        ENDWHERE
      ENDIF
    ENDBLOCK
  ENDIF
ENDDO

DO JFLD = 1, INFLD
  CALL YLFLDG (JFLD)%FINAL ()
  CALL YLFLDL (JFLD)%FINAL ()
ENDDO

CALL YLFLSG%FINAL ()
CALL YLGRID%FINAL ()

CALL YLFLST%RETURN ()

END FUNCTION

SUBROUTINE WRITESET (THIS, CDFILE, YDFLST, YDSTCO, KFLD1, KFLD2)

USE FCKIT_MODULE, ONLY : FCKIT_MPI_COMM

CLASS (ATLAS_IO_GATHSCAT_t),                  INTENT (IN) :: THIS
CHARACTER (LEN=*),                            INTENT (IN) :: CDFILE
TYPE (ATLAS_FIELDSET),                        INTENT (IN) :: YDFLST
TYPE (ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS), INTENT (IN) :: YDSTCO
INTEGER (KIND=JPIM),                          INTENT (IN) :: KFLD1, KFLD2
TYPE (ATLAS_TRACE) :: YLTRAC_GA
TYPE (ATLAS_TRACE) :: YLTRAC_WR


INTEGER (KIND=JPIM), ALLOCATABLE :: ITO (:)
TYPE (ATLAS_FIELD),  ALLOCATABLE :: YLFLDL (:)
TYPE (ATLAS_FIELD),  ALLOCATABLE :: YLFLDG (:)

TYPE (ATLAS_STRUCTUREDGRID) :: YLGRID
TYPE (ATLAS_FIELDSET) :: YLFLSG, YLFLST
INTEGER (KIND=JPIM) :: MYPROC, NPROC, IPROC, IPROCS
INTEGER (KIND=JPIM) :: JFLD1, JFLD2, INFLD, JFLD
TYPE (FCKIT_MPI_COMM) :: YLCOMM
CHARACTER (LEN=128) :: CLFILENAME, CLPROC

YLGRID = YDSTCO%GRID ()
YLCOMM = FCKIT_MPI_COMM ()
MYPROC = YLCOMM%RANK () + 1
NPROC  = YLCOMM%SIZE ()
INFLD  = KFLD2 - KFLD1 + 1

ALLOCATE (ITO (INFLD), YLFLDL (INFLD), YLFLDG (INFLD))


IF (THIS%NPRC > 0) THEN
  IPROCS = NPROC / THIS%NPRC
ELSE
  IPROCS = 1
ENDIF

DO IPROC = 1, NPROC, IPROCS
  JFLD1 =             1 + ((IPROC       -1) * INFLD) / NPROC
  JFLD2 = MIN (INFLD, 0 + ((IPROC+IPROCS-1) * INFLD) / NPROC)
  ITO (JFLD1:JFLD2) = IPROC
ENDDO

IF (THIS%NPRC == 1) THEN
  CLFILENAME = TRIM (CDFILE)
ELSE
  WRITE (CLPROC, '(".",I4.4)') MYPROC
  CLFILENAME = TRIM (CDFILE)//TRIM (CLPROC)
ENDIF

IF (ANY (ITO == MYPROC)) THEN
  CALL THIS%YLFMT%OPEN (CLFILENAME, YLGRID)
ENDIF

YLFLSG = ATLAS_FIELDSET ()
YLFLST = ATLAS_FIELDSET ()

DO JFLD = 1, INFLD
BLOCK
  CHARACTER (LEN=16)  :: CLNOMA
  INTEGER (KIND=JPIM) :: ISIZEG
  TYPE (ATLAS_METADATA) :: YLMETG

! Distributed field 
  YLFLDL (JFLD) = YDFLST%FIELD (JFLD+KFLD1-1)

  CLNOMA = YLFLDL (JFLD)%NAME ()
! Global field; zero size if this proc does not write the field
  ISIZEG = 0
  IF (ITO (JFLD) == MYPROC) ISIZEG = INT (YLGRID%SIZE (), JPIM)
  YLFLDG (JFLD) = ATLAS_FIELD (NAME=CLNOMA, KIND=JPRB, SHAPE=[ISIZEG])
  YLMETG = YLFLDG (JFLD)%METADATA ()
! Set owner
  CALL YLMETG%SET ("owner", ITO (JFLD)-1)
  CALL YLMETG%FINAL ()
  CALL YLFLSG%ADD (YLFLDG (JFLD))
  CALL YLFLST%ADD (YLFLDL (JFLD))

ENDBLOCK
ENDDO

YLTRAC_GA = ATLAS_TRACE (__FILE__, __LINE__, "ATLAS_IO_GATHSCAT:WRITE:GATHER")
CALL YDSTCO%GATHER (YLFLST, YLFLSG)
CALL YLTRAC_GA%FINAL ()

YLTRAC_WR = ATLAS_TRACE (__FILE__, __LINE__, "ATLAS_IO_GATHSCAT:WRITE:WRITE")
DO JFLD = 1, INFLD
  IF (ITO (JFLD) == MYPROC) THEN 
  BLOCK
    REAL (KIND=JPRB), POINTER :: ZFLDG (:)
    CHARACTER (LEN=:), ALLOCATABLE :: CLNOMA
    LOGICAL :: LLUNDEF
    REAL (KIND=JPRB) :: ZUNDEF
    TYPE (ATLAS_METADATA) :: YLMETA

    ! See whether we have undef values
    YLMETA = YLFLDL (JFLD)%METADATA ()
    LLUNDEF = YLMETA%HAS ("undef")
    IF (LLUNDEF) CALL YLMETA%GET ("undef", ZUNDEF)
    CALL YLMETA%FINAL ()

    ! Write field
    CLNOMA = YLFLDG (JFLD)%NAME ()
    CALL YLFLDG (JFLD)%DATA (ZFLDG)

    CALL THIS%YLFMT%WRITE (CLNOMA, ZFLDG, LLUNDEF, ZUNDEF)

  ENDBLOCK
  ENDIF
ENDDO
CALL YLTRAC_WR%FINAL ()

IF (ANY (ITO == MYPROC)) THEN
  CALL THIS%YLFMT%CLOSE ()
ENDIF

DO JFLD = 1, INFLD
  CALL YLFLDG (JFLD)%FINAL ()
  CALL YLFLDL (JFLD)%FINAL ()
ENDDO

CALL YLFLSG%FINAL ()
CALL YLFLST%FINAL ()
CALL YLGRID%FINAL ()

END SUBROUTINE

SUBROUTINE WRITE (THIS, CDFILE, YDFLST, YDSTCO)

CLASS (ATLAS_IO_GATHSCAT_t),                  INTENT (IN) :: THIS
CHARACTER (LEN=*),                            INTENT (IN) :: CDFILE
TYPE (ATLAS_FIELDSET),                        INTENT (IN) :: YDFLST
TYPE (ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS), INTENT (IN) :: YDSTCO

INTEGER (KIND=JPIM) :: INFLD, JFLD, ISFLD, JFLD1, JFLD2

INFLD = YDFLST%SIZE ()
ISFLD = INFLD

IF (THIS%NFLD > 0) ISFLD = THIS%NFLD

DO JFLD = 1, INFLD, ISFLD
  JFLD1 = JFLD
  JFLD2 = MIN (INFLD, JFLD+ISFLD-1)
  CALL THIS%WRITESET (CDFILE, YDFLST, YDSTCO, JFLD1, JFLD2)
ENDDO

END SUBROUTINE

END MODULE

