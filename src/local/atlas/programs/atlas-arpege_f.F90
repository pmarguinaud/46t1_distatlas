PROGRAM ATLAS_ARPEGE_F

USE PARKIND1, ONLY : JPIM, JPRB
USE INTERPOLATION4_MOD
USE INTERPOLATIONA_MOD
USE GRADIENT_MOD
USE ATLAS_IO_FA, ONLY : ATLAS_IO_FA_t
USE ATLAS_FMT_FA, ONLY : ISMGLO, ISMLAM, ISLTLN
USE FCKIT_MODULE, ONLY : FCKIT_MPI_COMM
USE ATLAS_MODULE  
USE ATLAS_TRACE_MODULE
USE XRD_GETOPTIONS

#include "atlas-abort.h"

!

IMPLICIT NONE

REAL (KIND=JPRB), PARAMETER :: RPI = 2.0_JPRB * ASIN (1.0_JPRB), &
                             & R2PI = 2._JPRB * RPI,             &
                             & RAD2DEG = 180._JPRB / RPI,        &
                             & DEG2RAD = RPI / 180._JPRB

TYPE (ATLAS_STRUCTUREDGRID)                  :: YLGRID1
TYPE (ATLAS_STRUCTUREDGRID)                  :: YLGRID2
TYPE (ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS) :: YLFSSC1
TYPE (ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS) :: YLFSSC2
TYPE (ATLAS_GRIDDISTRIBUTION)                :: YLDIST1
TYPE (ATLAS_GRIDDISTRIBUTION)                :: YLDIST2
TYPE (INTERPOLATION4)                        :: YLINTE4
TYPE (INTERPOLATIONA)                        :: YLINTEA
TYPE (ATLAS_FIELDSET)                        :: YLFLDS1
TYPE (ATLAS_FIELDSET)                        :: YLFLDS1UV
TYPE (ATLAS_FIELDSET)                        :: YLFLDS1GT
TYPE (ATLAS_FIELDSET)                        :: YLFLDS1GC
TYPE (ATLAS_FIELDSET)                        :: YLFLDS2
TYPE (ATLAS_FIELDSET)                        :: YLFLDS1HD
TYPE (ATLAS_FIELDSET)                        :: YLFLDS2IA
TYPE (ATLAS_FIELDSET)                        :: YLFLDS2I4
TYPE (FCKIT_MPI_COMM)                        :: YLCOMM
TYPE (ATLAS_TRACE)                           :: YLTRAC
TYPE (ATLAS_IO_FA_t)                         :: YLFAIO

INTEGER (KIND=JPIM) :: I
INTEGER (KIND=JPIM) :: NPROC, IRANK

CHARACTER (LEN=128) :: CLGRID1, CLGRID2
LOGICAL :: LLWRITE1, LLWRITE2, LLINTERP4, LLINTERPA, LLLIGHT1, LLLIGHT2, LLGRADIENT, LLXY1
LOGICAL :: LLROTATE, LLHALFDIFF

CALL INITOPTIONS 

CLGRID1 = "L80x40"       ; CALL GETOPTION ('--grid1', CLGRID1)
CLGRID2 = "N16"          ; CALL GETOPTION ('--grid2', CLGRID2)

CALL GETOPTION ('--xy1',     LLXY1    )
CALL GETOPTION ('--light1',  LLLIGHT1 )
CALL GETOPTION ('--light2',  LLLIGHT2 )

LLWRITE1 = .FALSE.
CALL GETOPTION ('--write1',  LLWRITE1 )
LLWRITE2 = .FALSE.
CALL GETOPTION ('--write2',  LLWRITE2 )

CALL GETOPTION ('--interp4', LLINTERP4)
CALL GETOPTION ('--interpA', LLINTERPA)
CALL GETOPTION ('--gradient', LLGRADIENT)
CALL GETOPTION ('--rotate', LLROTATE)
CALL GETOPTION ('--halfdiff', LLHALFDIFF)

CALL CHECKOPTIONS

CALL ATLAS_LIBRARY%INITIALISE ()

YLTRAC = ATLAS_TRACE (__FILE__, __LINE__, "MAIN")

YLCOMM = FCKIT_MPI_COMM ()
NPROC  = YLCOMM%SIZE ()
IRANK  = YLCOMM%RANK ()

CALL LINUX_BIND (IRANK, NPROC)

CALL CREATE_GRID (YLGRID1, CLGRID1)
CALL CREATE_GRID (YLGRID2, CLGRID2)

CALL CREATE_DIST (YLGRID1, YLDIST1, LLLIGHT1)
CALL CREATE_DIST (YLGRID2, YLDIST2, LLLIGHT2)

BLOCK
  TYPE (ATLAS_CONFIG) :: YLCONF
  YLCONF = ATLAS_CONFIG ()
  CALL YLCONF%SET ("halo", 1)
  CALL YLCONF%SET ("periodic_points", .TRUE.)
  YLFSSC1 = ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS (YLGRID1, YLDIST1, YLCONF)
  CALL YLCONF%FINAL ()
ENDBLOCK

YLFSSC2 = ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS (YLGRID2, YLDIST2)

IF (LLINTERP4) YLINTE4 = INTERPOLATION4 (YLDIST1, YLFSSC1, YLDIST2, YLFSSC2)
IF (LLINTERPA) YLINTEA = INTERPOLATIONA (YLDIST1, YLFSSC1, YLDIST2, YLFSSC2, LDOPENMP=.TRUE.)

CALL GETXYZ (YLFLDS1, YLFSSC1, YLGRID1, LLXY1)
CALL GETUV  (YLFLDS1UV, YLFSSC1, YLGRID1)

IF (LLROTATE) THEN
  CALL YLFAIO%WRITE ('UV1.fa', YLFLDS1UV, YLFSSC1)
ENDIF

IF (LLGRADIENT) THEN
  CALL GETXYZGRAD (YLFLDS1GT,  YLFSSC1, YLGRID1, LLXY1)
ENDIF

IF (LLINTERP4)  YLFLDS2I4 = YLINTE4%INTERPOLATE (YLFLDS1)
IF (LLINTERPA)  YLFLDS2IA = YLINTEA%INTERPOLATE (YLFLDS1)
IF (LLGRADIENT) YLFLDS1GC = GRADIENT (YLFSSC1, YLFLDS1)

IF (LLROTATE) THEN
  CALL ROTATE (YLFSSC1, YLGRID2, YLFLDS1UV)
ENDIF

IF (LLROTATE) THEN
  CALL YLFAIO%WRITE ('UV1R.fa', YLFLDS1UV, YLFSSC1)
ENDIF

IF (LLHALFDIFF) THEN
  YLFLDS1HD = HALFDIFF (YLFSSC1, YLFLDS1)
ENDIF

IF (LLWRITE1) THEN
  CALL YLFAIO%WRITE ('XYZ1.fa', YLFLDS1, YLFSSC1)
  IF (LLGRADIENT) THEN
    CALL YLFAIO%WRITE ('XYZ1GT.fa', YLFLDS1GT, YLFSSC1)
    CALL YLFAIO%WRITE ('XYZ1GC.fa', YLFLDS1GC, YLFSSC1)
  ENDIF
ENDIF

IF (LLWRITE2) THEN
  IF (LLINTERP4) CALL YLFAIO%WRITE ('XYZ2I4.fa', YLFLDS2I4, YLFSSC2)
  IF (LLINTERPA) CALL YLFAIO%WRITE ('XYZ2IA.fa', YLFLDS2IA, YLFSSC2)
ENDIF

CALL YLFLDS1UV%FINAL ()

IF (LLHALFDIFF) THEN
  CALL YLFAIO%WRITE ('HALFDIFF1.fa', YLFLDS1HD, YLFSSC1)
ENDIF

CALL YLFLDS1  %FINAL ()
CALL YLFLDS1GC%FINAL ()
CALL YLFLDS1GT%FINAL ()
CALL YLFLDS2  %FINAL ()
CALL YLFLDS2I4%FINAL ()
CALL YLFLDS2IA%FINAL ()

IF (LLINTERP4) CALL YLINTE4%FINAL ()
IF (LLINTERPA) CALL YLINTEA%FINAL ()

CALL YLTRAC%FINAL ()

CALL ATLAS_LIBRARY%FINALISE()


WRITE (*, *) "--- STOP ---"

CONTAINS

SUBROUTINE GETUV (YDFLDS, YDFSSC, YDGRID)

TYPE (ATLAS_FIELDSET)                        :: YDFLDS
TYPE (ATLAS_STRUCTUREDGRID)                  :: YDGRID
TYPE (ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS) :: YDFSSC

TYPE (ATLAS_FIELD) :: YLUX, YLUY
TYPE (ATLAS_FIELD) :: YLVX, YLVY
REAL (KIND=JPRB), POINTER :: UX (:), UY (:), VX (:), VY (:)

YDFLDS = ATLAS_FIELDSET ()

YLUX = ATLAS_FIELD (NAME="SURFUX", KIND=JPRB, SHAPE=[YDFSSC%SIZE ()])
YLUY = ATLAS_FIELD (NAME="SURFUY", KIND=JPRB, SHAPE=[YDFSSC%SIZE ()])
YLVX = ATLAS_FIELD (NAME="SURFVX", KIND=JPRB, SHAPE=[YDFSSC%SIZE ()])
YLVY = ATLAS_FIELD (NAME="SURFVY", KIND=JPRB, SHAPE=[YDFSSC%SIZE ()])

CALL YLUX%DATA (UX)
CALL YLUY%DATA (UY)
CALL YLVX%DATA (VX)
CALL YLVY%DATA (VY)

UX (:) = 1._JPRB
UY (:) = 0._JPRB
VX (:) = 0._JPRB
VY (:) = 1._JPRB

CALL YDFLDS%ADD (YLUX)
CALL YDFLDS%ADD (YLUY)
CALL YDFLDS%ADD (YLVX)
CALL YDFLDS%ADD (YLVY)

END SUBROUTINE

SUBROUTINE GETXYZ (YDFLDS, YDFSSC, YDGRID, LDXY)

TYPE (ATLAS_FIELDSET)                        :: YDFLDS
TYPE (ATLAS_STRUCTUREDGRID)                  :: YDGRID
TYPE (ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS) :: YDFSSC
LOGICAL                                      :: LDXY

TYPE (ATLAS_FIELD) :: YLX, YLY, YLZ
REAL (KIND=JPRB) :: LONLAT (2),LONLATTMP(2),TMP1,TMP2, COSLON, SINLON, COSLAT, SINLAT
REAL (KIND=JPRB), POINTER :: X (:), Y (:), Z (:)
INTEGER (KIND=JPIM) :: IX, IY, JLOC

YDFLDS = ATLAS_FIELDSET ()

YLX = ATLAS_FIELD (NAME="SURFX", KIND=JPRB, SHAPE=[YDFSSC%SIZE ()])
YLY = ATLAS_FIELD (NAME="SURFY", KIND=JPRB, SHAPE=[YDFSSC%SIZE ()])
YLZ = ATLAS_FIELD (NAME="SURFZ", KIND=JPRB, SHAPE=[YDFSSC%SIZE ()])

CALL YLX%DATA (X)
CALL YLY%DATA (Y)
CALL YLZ%DATA (Z)

JLOC = 1
DO IY = YDFSSC%J_BEGIN (), YDFSSC%J_END ()
  DO IX = YDFSSC%I_BEGIN (IY), YDFSSC%I_END (IY)
    IF (LDXY) THEN
      LONLAT = YDGRID%XY     (IX, IY)
    ELSE
      LONLAT = YDGRID%LONLAT (IX, IY) * DEG2RAD
    ENDIF
    LONLAT = YDGRID%LONLAT (IX, IY) * DEG2RAD
    COSLON = COS (LONLAT (1)); SINLON = SIN (LONLAT (1))
    COSLAT = COS (LONLAT (2)); SINLAT = SIN (LONLAT (2))
    X (JLOC) = COSLON * COSLAT
    Y (JLOC) = SINLON * COSLAT
    Z (JLOC) =          SINLAT
    JLOC = JLOC + 1
  ENDDO
ENDDO

CALL YDFLDS%ADD (YLX)
CALL YDFLDS%ADD (YLY)
CALL YDFLDS%ADD (YLZ)

END SUBROUTINE

SUBROUTINE GETXYZGRAD (YDFLDS, YDFSSC, YDGRID, LDXY)

TYPE (ATLAS_FIELDSET)                        :: YDFLDS
TYPE (ATLAS_STRUCTUREDGRID)                  :: YDGRID
TYPE (ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS) :: YDFSSC
LOGICAL                                      :: LDXY

TYPE (ATLAS_FIELD) :: YLX_DX, YLY_DX, YLZ_DX
TYPE (ATLAS_FIELD) :: YLX_DY, YLY_DY, YLZ_DY
REAL (KIND=JPRB) :: LONLAT (2), COSLON, SINLON, COSLAT, SINLAT
REAL (KIND=JPRB), POINTER :: X_DX (:), Y_DX (:), Z_DX (:)
REAL (KIND=JPRB), POINTER :: X_DY (:), Y_DY (:), Z_DY (:)
INTEGER (KIND=JPIM) :: IX, IY, JLOC

YDFLDS = ATLAS_FIELDSET ()

YLX_DX = ATLAS_FIELD (NAME="SURFX.DX", KIND=JPRB, SHAPE=[YDFSSC%SIZE ()])
YLY_DX = ATLAS_FIELD (NAME="SURFY.DX", KIND=JPRB, SHAPE=[YDFSSC%SIZE ()])
YLZ_DX = ATLAS_FIELD (NAME="SURFZ.DX", KIND=JPRB, SHAPE=[YDFSSC%SIZE ()])
YLX_DY = ATLAS_FIELD (NAME="SURFX.DY", KIND=JPRB, SHAPE=[YDFSSC%SIZE ()])
YLY_DY = ATLAS_FIELD (NAME="SURFY.DY", KIND=JPRB, SHAPE=[YDFSSC%SIZE ()])
YLZ_DY = ATLAS_FIELD (NAME="SURFZ.DY", KIND=JPRB, SHAPE=[YDFSSC%SIZE ()])

CALL YLX_DX%DATA (X_DX)
CALL YLY_DX%DATA (Y_DX)
CALL YLZ_DX%DATA (Z_DX)
CALL YLX_DY%DATA (X_DY)
CALL YLY_DY%DATA (Y_DY)
CALL YLZ_DY%DATA (Z_DY)

JLOC = 1
DO IY = YDFSSC%J_BEGIN (), YDFSSC%J_END ()
  DO IX = YDFSSC%I_BEGIN (IY), YDFSSC%I_END (IY)

    IF (LDXY) THEN
      LONLAT = YDGRID%XY     (IX, IY) * DEG2RAD
    ELSE
      LONLAT = YDGRID%LONLAT (IX, IY) * DEG2RAD
    ENDIF
    COSLON = COS (LONLAT (1)); SINLON = SIN (LONLAT (1))
    COSLAT = COS (LONLAT (2)); SINLAT = SIN (LONLAT (2))

    X_DX (JLOC) = DEG2RAD * - SINLON * COSLAT
    X_DY (JLOC) = DEG2RAD * - COSLON * SINLAT
    Y_DX (JLOC) = DEG2RAD * + COSLON * COSLAT
    Y_DY (JLOC) = DEG2RAD * - SINLON * SINLAT
    Z_DX (JLOC) = DEG2RAD *           0._JPRB
    Z_DY (JLOC) = DEG2RAD *            COSLAT

    JLOC = JLOC + 1
  ENDDO
ENDDO

CALL YDFLDS%ADD (YLX_DX)
CALL YDFLDS%ADD (YLY_DX)
CALL YDFLDS%ADD (YLZ_DX)
CALL YDFLDS%ADD (YLX_DY)
CALL YDFLDS%ADD (YLY_DY)
CALL YDFLDS%ADD (YLZ_DY)

END SUBROUTINE

SUBROUTINE CREATE_GRID (YDGRID, CDGRID)

TYPE (ATLAS_STRUCTUREDGRID) :: YDGRID
CHARACTER (LEN=*)           :: CDGRID

LOGICAL :: LLEXIST

TYPE GRID_OPTIONS_t
  INTEGER (KIND=JPIM) :: NLOEN (30000) = 0
  INTEGER (KIND=JPIM) :: NDLON = 0, NDGLG = 0
  LOGICAL :: LELAM    = .FALSE.
  LOGICAL :: LROTATED = .FALSE. 
  LOGICAL :: LSTRETCH = .FALSE.
  REAL (KIND=JPRB) :: RSTRETCH = 1._JPRB
  REAL (KIND=JPRB) :: RLONCENT = 0._JPRB  ! Degrees
  REAL (KIND=JPRB) :: RLATCENT = 90._JPRB ! Degrees

  REAL (KIND=JPRB) :: DXINMETRES = 10000._JPRB
  REAL (KIND=JPRB) :: DYINMETRES = 10000._JPRB

  REAL (KIND=JPRB) :: LADINDEGREES    = 46.2_JPRB
  REAL (KIND=JPRB) :: LATIN1INDEGREES = 46.2_JPRB
  REAL (KIND=JPRB) :: LATIN2INDEGREES = 46.2_JPRB
  REAL (KIND=JPRB) :: LOVINDEGREES    =  2.0_JPRB
  INTEGER (KIND=JPIM) :: NUX, NUY

END TYPE GRID_OPTIONS_t

TYPE (GRID_OPTIONS_t) :: YLGROPT

NAMELIST / NAMGRID / YLGROPT

INQUIRE (FILE=CDGRID, EXIST=LLEXIST)

IF (LLEXIST) THEN

  IF (INDEX (CDGRID, "fort.4") > 0) THEN
    OPEN (4, FILE=TRIM (CDGRID), FORM="FORMATTED")
    READ (4, NAMGRID)
    CLOSE (4)

    IF (YLGROPT%LELAM) THEN

      YDGRID = ATLAS_REGIONALGRID (NX=YLGROPT%NDLON, NY=YLGROPT%NDGLG,                                &
             & XY_MIN=[-YLGROPT%NUX / 2 * YLGROPT%DXINMETRES, -YLGROPT%NUY / 2 * YLGROPT%DYINMETRES], &
             & DX=YLGROPT%DXINMETRES, DY=YLGROPT%DYINMETRES,                                          &
             & PROJECTION=ATLAS_LAMBERTCONFORMALCONICPROJECTION (YLGROPT%LOVINDEGREES,                &
             & YLGROPT%LADINDEGREES, YLGROPT%LATIN1INDEGREES, YLGROPT%LATIN2INDEGREES))



    ELSE
      IF (YLGROPT%RLONCENT /= 0._JPRB .OR. YLGROPT%RLATCENT /= 90._JPRB) THEN
         YDGRID = ATLAS_REDUCEDGAUSSIANGRID (YLGROPT%NLOEN (1:YLGROPT%NDGLG),  &
                & PROJECTION=ATLAS_ROTATEDSCHMIDTPROJECTION (YLGROPT%RSTRETCH, &
                & [YLGROPT%RLONCENT, YLGROPT%RLATCENT], 180._JPRB))
      ELSE
        YDGRID = ATLAS_REDUCEDGAUSSIANGRID (YLGROPT%NLOEN (1:YLGROPT%NDGLG))
      ENDIF
    ENDIF


  ELSE
    YDGRID = YLFAIO%GRID (CDGRID)
  ENDIF
ELSE
  IF (CDGRID (1:1) == "X") THEN
    BLOCK
      INTEGER (KIND=JPIM) :: J, NX, NY
      TYPE (ATLAS_CONFIG) :: YLCFGR, YLCFDO

      DO J = 2, LEN_TRIM (CDGRID)
        IF (CDGRID (J:J) == "x") GOTO 100
      ENDDO
      STOP
100   CONTINUE

      READ (CDGRID (2:J-1), *) NX
      READ (CDGRID (J+1: ), *) NY

      YLCFGR = ATLAS_CONFIG ()
      YLCFDO = ATLAS_CONFIG ()
      CALL YLCFGR%SET ("nx", NX)
      CALL YLCFGR%SET ("ny", NY)
      CALL YLCFGR%SET ("type", "shifted_lonlat")
      CALL YLCFDO%SET ("type", "rectangular")
      CALL YLCFDO%SET ("units", "degrees")
      CALL YLCFDO%SET ("xmin", -180.0_JPRB)
      CALL YLCFDO%SET ("xmax", +180.0_JPRB)
      CALL YLCFDO%SET ("ymin", - 90.0_JPRB)
      CALL YLCFDO%SET ("ymax", + 90.0_JPRB)
      CALL YLCFGR%SET ("domain", YLCFDO)

      YDGRID = ATLAS_STRUCTUREDGRID (YLCFGR)
      
      CALL YLCFGR%FINAL ()
      CALL YLCFDO%FINAL ()
    ENDBLOCK
  ELSE
    YDGRID = ATLAS_STRUCTUREDGRID (CDGRID)
  ENDIF
ENDIF

END SUBROUTINE

SUBROUTINE CREATE_DIST (YDGRID, YDDIST, LDLIGHT)

TYPE (ATLAS_STRUCTUREDGRID)   :: YDGRID
TYPE (ATLAS_GRIDDISTRIBUTION) :: YDDIST
LOGICAL, OPTIONAL             :: LDLIGHT

TYPE (ATLAS_CONFIG) :: YLCONF

CHARACTER (LEN=64)  :: CLDIST
LOGICAL             :: LLLIGHT

IF (ISMGLO (YDGRID)) THEN
  CLDIST = "equal_regions"
ELSE
  CLDIST = "checkerboard"
ENDIF

LLLIGHT = .FALSE.
IF (PRESENT (LDLIGHT)) LLLIGHT = LDLIGHT

YLCONF = ATLAS_CONFIG() 

SELECT CASE (CLDIST)
  CASE ('checkerboard') 
    IF (LLLIGHT) THEN
      CALL YLCONF%SET ('type', 'regular_bands')
      CALL YLCONF%SET ('blocksize', INT (YDGRID%NX (1)))
    ELSE
      CALL YLCONF%SET ('type', 'checkerboard')
    ENDIF
  CASE ('equal_regions')
    CALL YLCONF%SET ('type', 'equal_regions')
  CASE DEFAULT
    CALL ABORT ('UNKNOWN DISTRIBUTION TYPE :'//TRIM (CLDIST))
END SELECT 

YDDIST = ATLAS_GRIDDISTRIBUTION (YDGRID, YLCONF)

CALL YLCONF%FINAL ()

END SUBROUTINE

END

