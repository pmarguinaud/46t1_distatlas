PROGRAM ATLAS_CLIM

USE PARKIND1, ONLY : JPIM, JPRB
USE ATLAS_FA, ONLY : ATLAS_FA_t
USE ATLAS_DH, ONLY : ATLAS_DH_t
USE FCKIT_MODULE, ONLY : FCKIT_MPI_COMM
USE INTERPOLATIONA_MOD
USE INTERPOLATION4_MOD
USE ATLAS_MODULE  
USE ATLAS_HELPER
USE ATLAS_TRACE_MODULE
USE XRD_GETOPTIONS
USE READCOVERS_MOD

!

#include "atlas-abort.h"

IMPLICIT NONE

REAL (KIND=JPRB), PARAMETER :: RPI = 2.0_JPRB * ASIN (1.0_JPRB)
REAL (KIND=JPRB), PARAMETER :: RA = 6371229._JPRB
REAL (KIND=JPRB), PARAMETER :: RG = 9.80665_JPRB
REAL (KIND=JPRB), PARAMETER :: XKARMAN = 0.4_JPRB
REAL (KIND=JPRB), PARAMETER :: XCDZ0EFF = 0.8_JPRB
REAL (KIND=JPRB), PARAMETER :: ZUNDEF = HUGE (1._JPRB)
INTEGER (KIND=JPIM), PARAMETER :: INCOVR = 256_JPIM
LOGICAL, PARAMETER :: LGARDEN = .FALSE., LWATER_TO_NATURE = .FALSE., LTOWN_TO_ROCK = .FALSE.

#include "atlas-compute-covers.h"
#include "atlas-compute-sso.h"
#include "atlas-compute-aos.h"

TYPE (ATLAS_FA_t)              :: YLFAIO
TYPE (ATLAS_DH_t)              :: YLDHIO
TYPE (ATLAS_STRUCTUREDGRID)    :: YLGRID1
TYPE (ATLAS_STRUCTUREDGRID)    :: YLGRID2
TYPE (ATLAS_TRACE)             :: YLTRAC
! Grids of input files

TYPE (ATLAS_STRUCTUREDGRID)                  :: YLGRID_OROG
TYPE (ATLAS_STRUCTUREDGRID)                  :: YLGRID_SABL
TYPE (ATLAS_STRUCTUREDGRID)                  :: YLGRID_ARGI
TYPE (ATLAS_STRUCTUREDGRID)                  :: YLGRID_COVR

! Functionspaces

TYPE (ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS) :: YLFSSC1
TYPE (ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS) :: YLFSSC2

! Distributions (of grids on MPI tasks)

TYPE (ATLAS_GRIDDISTRIBUTION)                :: YLDIST1
TYPE (ATLAS_GRIDDISTRIBUTION)                :: YLDIST2

! Interpolation (source grid -> target grid)

TYPE (INTERPOLATIONA)                        :: YLINTEA

! Field sets

TYPE (ATLAS_FIELDSET)                        :: YLFLDS2

! Communicator

TYPE (FCKIT_MPI_COMM)                        :: YLCOMM

INTEGER (KIND=JPIM) :: I, JFLD
INTEGER (KIND=JPIM) :: NPROC, IRANK


! Atlas fields for target geometry

TYPE (ATLAS_FIELD), ALLOCATABLE :: YLFL2 (:)

! Pointers to access data of target fields

TYPE (PTR),         ALLOCATABLE :: YLPT2 (:)

INTEGER (KIND=JPIM) :: INFLD

TYPE (ATLAS_FIELD)    :: YLOROG1, YLARGI1, YLSABL1, YLCOVR1
TYPE (ATLAS_FIELDSET) :: YLCOVR2S, YLAOSP2S
REAL (KIND=JPRB), POINTER, DIMENSION (:) :: ZOROG1, ZARGI1, ZSABL1, ZCOVR1

! Indices of all fields

INTEGER (KIND=JPIM) :: JGEOPOTENTIEL
INTEGER (KIND=JPIM) :: JVARGEOPDIR, JSSO_SLOPE, JVARGEOPANI, JETGEOPOTENT, JZ0RELFOISG
INTEGER (KIND=JPIM) :: JPROPURBANIS, JPROPTERRE
INTEGER (KIND=JPIM) :: JINDTERREMER, JPROPSABLE, JPROPARGILE


CALL INITOPTIONS ()
CALL CHECKOPTIONS ()

CALL ATLAS_LIBRARY%INITIALISE ()

YLTRAC = ATLAS_TRACE (__FILE__, __LINE__, "ATLAS_CLIM")

YLCOMM = FCKIT_MPI_COMM ()
NPROC  = YLCOMM%SIZE ()
IRANK  = YLCOMM%RANK ()

CALL LINUX_BIND (IRANK, NPROC)

YLGRID2 = GRID_FROM_NAMELIST ()

YLDHIO = ATLAS_DH_t (YLGRID2)

! Create source grids & check compatibility

YLGRID_OROG = YLDHIO%GRID ("SURFGEOPOTENTIEL")
YLGRID_ARGI = YLDHIO%GRID ("SURFPROP.ARGILE" )
YLGRID_SABL = YLDHIO%GRID ("SURFPROP.SABLE"  )
YLGRID_COVR = YLDHIO%GRID ("SFX.COVER"       )

IF (.NOT. (GRID_EQ (YLGRID_OROG, YLGRID_ARGI))) CALL ABORT ("GEOMETRY MISMATCH")
IF (.NOT. (GRID_EQ (YLGRID_OROG, YLGRID_SABL))) CALL ABORT ("GEOMETRY MISMATCH")
IF (.NOT. (GRID_EQ (YLGRID_OROG, YLGRID_COVR))) CALL ABORT ("GEOMETRY MISMATCH")

YLGRID1 = YLGRID_OROG

! Not needed anymore, finalize

CALL YLGRID_OROG%FINAL ()
CALL YLGRID_ARGI%FINAL ()
CALL YLGRID_SABL%FINAL ()
CALL YLGRID_COVR%FINAL ()

! Create distributions for both source & target grids

CALL CREATE_DIST (YLGRID1, YLDIST1, .TRUE.)
CALL CREATE_DIST (YLGRID2, YLDIST2)

! Create functionspaces

BLOCK
  TYPE (ATLAS_CONFIG) :: YLCONF
  YLCONF = ATLAS_CONFIG ()
  CALL YLCONF%SET ("halo", 1)
  YLFSSC1 = ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS (YLGRID1, YLDIST1, YLCONF)
  YLFSSC2 = ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS (YLGRID2, YLDIST2, YLCONF)
  CALL YLCONF%FINAL ()
ENDBLOCK

! Define indices for all fields

INFLD = 0

#define ADDFLD(J) INFLD = INFLD + 1; J = INFLD

ADDFLD (JGEOPOTENTIEL); ADDFLD (JPROPSABLE  ); ADDFLD (JPROPARGILE ); 
ADDFLD (JVARGEOPDIR  ); ADDFLD (JSSO_SLOPE  ); ADDFLD (JVARGEOPANI ); ADDFLD (JETGEOPOTENT); 
ADDFLD (JINDTERREMER ); ADDFLD (JPROPURBANIS); ADDFLD (JPROPTERRE  ); ADDFLD (JZ0RELFOISG );

#undef ADDFLD

! Allocate fields & pointers

ALLOCATE (YLFL2 (INFLD), YLPT2 (INFLD))

YLFLDS2 = ATLAS_FIELDSET ()

! Create interpolation object (source -> target)

YLINTEA = INTERPOLATIONA (YLDIST1, YLFSSC1, YLDIST2, YLFSSC2, LDOPENMP=.TRUE.)

! Read input fields on source geometry

YLOROG1 = RNS1 ("SURFGEOPOTENTIEL", PSCALE=RG); CALL YLOROG1%DATA (ZOROG1)
YLARGI1 = RNS1 ("SURFPROP.ARGILE"            ); CALL YLARGI1%DATA (ZARGI1)
YLSABL1 = RNS1 ("SURFPROP.SABLE"             ); CALL YLSABL1%DATA (ZSABL1)
YLCOVR1 = RNS1 ("SFX.COVER"                  ); CALL YLCOVR1%DATA (ZCOVR1)


YLCOVR2S = ATLAS_COMPUTE_COVERS (YLFSSC1, YLFSSC2, YLCOVR1, YLINTEA, LDOPENMP=.TRUE.) 


! Set missing values of orography

!$OMP WORKSHARE
WHERE (ZCOVR1 == 1._JPRB) ! Sea 
  ZOROG1 = ZUNDEF
ENDWHERE
!$OMP END WORKSHARE

CALL INS2 (JINDTERREMER, NEWFLD (YLFSSC2, "SURFIND.TERREMER"))

BLOCK
  TYPE (ATLAS_FIELD) :: YLCOVR2
  REAL (KIND=JPRB), POINTER :: ZCOVR2 (:)

  YLCOVR2 = YLCOVR2S%FIELD ("COVER001")
  CALL YLCOVR2%DATA (ZCOVR2)

!$OMP WORKSHARE
  WHERE (ZCOVR2 > 0.5_JPRB)
    YLPT2 (JINDTERREMER)%ZDATA = 0._JPRB
  ELSE WHERE
    YLPT2 (JINDTERREMER)%ZDATA = 1._JPRB
  END WHERE
!$OMP END WORKSHARE

  CALL YLCOVR2%FINAL ()

ENDBLOCK

! Interpolate fields using box averaging

BLOCK
  TYPE (ATLAS_FIELDSET) :: YLFLDS1
  TYPE (ATLAS_FIELDSET) :: YLFLDS2I

  YLFLDS1 = ATLAS_FIELDSET ()

  CALL YLFLDS1%ADD (YLOROG1)
  CALL YLFLDS1%ADD (YLARGI1)
  CALL YLFLDS1%ADD (YLSABL1)
  YLFLDS2I = YLINTEA%INTERPOLATE (YLFLDS1)
  CALL YLFLDS1%FINAL ()

! Insert interpolated fields in the list of fields of target geometry

  CALL INS2 (JGEOPOTENTIEL, YLFLDS2I%FIELD ("SURFGEOPOTENTIEL"))
  CALL INS2 (JPROPSABLE   , YLFLDS2I%FIELD ("SURFPROP.SABLE"  ))
  CALL INS2 (JPROPARGILE  , YLFLDS2I%FIELD ("SURFPROP.ARGILE" ))

  CALL YLFLDS2I%FINAL ()
ENDBLOCK

BLOCK
  TYPE (ATLAS_FIELDSET) :: YLFLDS2SSO
  TYPE (ATLAS_FIELD)    :: YLFLD2

  YLFLDS2SSO = ATLAS_COMPUTE_SSO (YLFSSC1, YLFSSC2, YLOROG1, YLFL2 (JGEOPOTENTIEL), YLINTEA, LDOPENMP=.TRUE., LDROTATE=.TRUE.) 

  YLFLD2 = YLFLDS2SSO%FIELD ("SSO_DIR"  ); CALL YLFLD2%RENAME ("SURFVAR.GEOP.DIR"); CALL INS2 (JVARGEOPDIR , YLFLD2)
  YLFLD2 = YLFLDS2SSO%FIELD ("SSO_ANIS" ); CALL YLFLD2%RENAME ("SURFVAR.GEOP.ANI"); CALL INS2 (JVARGEOPANI , YLFLD2)
  YLFLD2 = YLFLDS2SSO%FIELD ("SSO_STDEV"); CALL YLFLD2%RENAME ("SURFET.GEOPOTENT"); CALL INS2 (JETGEOPOTENT, YLFLD2)


!$OMP WORKSHARE
  WHERE (YLPT2 (JVARGEOPANI)%ZDATA /= ZUNDEF)
    YLPT2 (JVARGEOPANI)%ZDATA (:) = YLPT2 (JVARGEOPANI)%ZDATA (:) ** 2
  END WHERE
!$OMP END WORKSHARE

!$OMP WORKSHARE
  WHERE (YLPT2 (JVARGEOPDIR)%ZDATA /= ZUNDEF)
    YLPT2 (JVARGEOPDIR)%ZDATA (:) = YLPT2 (JVARGEOPDIR)%ZDATA (:) * RPI / 180._JPRB
  END WHERE
!$OMP END WORKSHARE

ENDBLOCK

! Add enveloppe

!$OMP WORKSHARE 
  WHERE (YLPT2 (JGEOPOTENTIEL)%ZDATA (:) /= ZUNDEF)
    YLPT2 (JGEOPOTENTIEL)%ZDATA (:) = YLPT2 (JGEOPOTENTIEL)%ZDATA (:) + YLPT2 (JETGEOPOTENT)%ZDATA
  ENDWHERE
!$OMP END WORKSHARE

BLOCK
  TYPE (INTERPOLATION4) :: YLINTE4
  REAL (KIND=JPRB) :: ZLOC2 (YLFSSC2%SIZE ())
  REAL (KIND=JPRB), POINTER, DIMENSION (:) :: ZAOSIP2, ZAOSIM2, ZAOSJP2, ZAOSJM2, &
                                            & ZHO2IP2, ZHO2IM2, ZHO2JP2, ZHO2JM2
  TYPE (ATLAS_FIELD) :: YLFLD2

  YLINTE4 = INTERPOLATION4 (YLDIST2, YLFSSC2, YLDIST1, YLFSSC1)
  YLAOSP2S = ATLAS_COMPUTE_AOS (YLFSSC1, YLFSSC2, YLOROG1, YLFL2 (JGEOPOTENTIEL), YLINTEA, YLINTE4, LDOPENMP=.TRUE.) 

#define GF(n, z) YLFLD2 = YLAOSP2S%FIELD (#n); CALL YLFLD2%DATA (z); CALL YLFLD2%FINAL ()
  GF (AOSIP, ZAOSIP2)
  GF (AOSIM, ZAOSIM2)
  GF (AOSJP, ZAOSJP2)
  GF (AOSJM, ZAOSJM2)
  GF (HO2IP, ZHO2IP2)
  GF (HO2IM, ZHO2IM2)
  GF (HO2JP, ZHO2JP2)
  GF (HO2JM, ZHO2JM2)
#undef GF

  CALL INS2 (JZ0RELFOISG, NEWFLD (YLFSSC2, "SURFZ0REL.FOIS.G" ))

  WHERE (YLPT2 (JGEOPOTENTIEL)%ZDATA /= ZUNDEF)
    ZLOC2 (:) = 0.25_JPRB * XCDZ0EFF / (2._JPRB * XKARMAN**2) &
            & * (ZAOSIP2 (:) + ZAOSIM2 (:) + ZAOSJP2 (:) + ZAOSJM2 (:))        
    WHERE (ZLOC2 (:) > 0._JPRB)
      YLPT2 (JZ0RELFOISG)%ZDATA = 0.25_JPRB * (ZHO2IP2 (:) + ZHO2IM2 (:) + ZHO2JP2 (:) + ZHO2JM2 (:)) &
                              & * EXP (-SQRT (1._JPRB / ZLOC2 (:)))
      YLPT2 (JZ0RELFOISG)%ZDATA = MAX (YLPT2 (JZ0RELFOISG)%ZDATA (:), 1E-10_JPRB)
    ELSEWHERE
      YLPT2 (JZ0RELFOISG)%ZDATA = 0._JPRB
    END WHERE
  ELSE WHERE
    YLPT2 (JZ0RELFOISG)%ZDATA = ZUNDEF
  END WHERE


  CALL YLINTE4%FINAL ()
ENDBLOCK

CALL COMPUTE_FRACTIONS

! Fix missing values: orography parameters, set to zero

BLOCK
  INTEGER (KIND=JPIM) :: IZS (5)
  IZS = [JGEOPOTENTIEL,  JVARGEOPDIR, JVARGEOPANI,  JETGEOPOTENT, JZ0RELFOISG]

  DO JFLD = 1, SIZE (IZS)
!$OMP WORKSHARE 
    WHERE (YLPT2 (IZS (JFLD))%ZDATA == ZUNDEF)
      YLPT2 (IZS (JFLD))%ZDATA = 0._JPRB
    ENDWHERE
!$OMP END WORKSHARE
  ENDDO

ENDBLOCK

CALL YLFAIO%WRITE ('Const.Clim', YLFLDS2, YLFSSC2)

DO JFLD = 1, INFLD
  CALL YLFL2 (JFLD)%FINAL ()
ENDDO

CALL YLCOVR2S%FINAL ()
CALL YLAOSP2S%FINAL ()
CALL YLOROG1%FINAL ()
CALL YLARGI1%FINAL ()
CALL YLSABL1%FINAL ()
CALL YLCOVR1%FINAL ()
CALL YLFLDS2%FINAL ()
CALL YLINTEA%FINAL ()
CALL YLGRID1%FINAL ()
CALL YLDIST1%FINAL ()
CALL YLDIST2%FINAL ()
CALL YLFSSC1%FINAL ()
CALL YLFSSC2%FINAL ()



CALL YLTRAC%FINAL ()

CALL ATLAS_LIBRARY%FINALISE()

WRITE (*, *) "--- STOP ---"

CONTAINS

SUBROUTINE COMPUTE_FRACTIONS

TYPE (ATLAS_FIELD) :: YLFL2 (INCOVR)
REAL (KIND=JPRB) :: ZFRAC_MER (YLFSSC2%SIZE ()), ZFRAC_EAU (YLFSSC2%SIZE ())
TYPE (COVERS_t) :: YLCOVERS
LOGICAL, ALLOCATABLE :: LCOVER (:)
INTEGER (KIND=JPIM) :: ICOVR

REAL (KIND=JPRB) :: ZAVGCOVR2 (INCOVR)
REAL (KIND=JPRB) :: ZMINCOVR2 (INCOVR)
REAL (KIND=JPRB) :: ZMAXCOVR2 (INCOVR)

DO ICOVR = 1, INCOVR
  YLFL2 (ICOVR) = YLCOVR2S%FIELD (ICOVR)
ENDDO

! Create fractions fields

CALL INS2 (JPROPURBANIS, NEWFLD (YLFSSC2, "SURFPROP.URBANIS" ))
CALL INS2 (JPROPTERRE,   NEWFLD (YLFSSC2, "SURFPROP.TERRE"   ))

CALL READCOVERS (YLCOVERS, 1, LGARDEN, LWATER_TO_NATURE, LTOWN_TO_ROCK)
CALL FIELDSTAT (YLFSSC2, YLFL2, PMIN=ZMINCOVR2, PMAX=ZMAXCOVR2, PAVG=ZAVGCOVR2)

ALLOCATE (LCOVER (YLCOVERS%JPCOVER))
LCOVER = .FALSE.

LCOVER = ZAVGCOVR2 > 0._JPRB

CALL MAKEFRAC (ZFRAC_MER                 , YLFL2, YLCOVERS%XDATA_SEA  , LCOVER)
CALL MAKEFRAC (ZFRAC_EAU                 , YLFL2, YLCOVERS%XDATA_WATER, LCOVER)
CALL MAKEFRAC (YLPT2 (JPROPURBANIS)%ZDATA, YLFL2, YLCOVERS%XDATA_TOWN , LCOVER)

!$OMP WORKSHARE
  YLPT2 (JPROPTERRE)%ZDATA = 1._JPRB - (ZFRAC_MER + ZFRAC_EAU)
!$OMP END WORKSHARE

END SUBROUTINE

SUBROUTINE MAKEFRAC (PFRAC, YDCOVER, PDATA, LDCOVER)

REAL (KIND=JPRB),   INTENT (OUT) :: PFRAC (:)
TYPE (ATLAS_FIELD), INTENT (IN)  :: YDCOVER (:)
REAL (KIND=JPRB),   INTENT (IN)  :: PDATA (:)
LOGICAL,            INTENT (IN)  :: LDCOVER (:)

TYPE (PTR) :: YLPTR (SIZE (YDCOVER))

INTEGER (KIND=JPIM) :: JLOC, JCOV, INCOV
REAL (KIND=JPRB) :: ZSUM

INCOV = SIZE (YDCOVER)

DO JCOV = 1, INCOV
  CALL YDCOVER (JCOV)%DATA (YLPTR (JCOV)%ZDATA)
ENDDO

! 1D computation

!$OMP PARALLEL DO PRIVATE (JLOC, ZSUM, JCOV) 
DO JLOC = 1, SIZE (PFRAC)
  PFRAC (JLOC) = 0._JPRB
  ZSUM = 0._JPRB
  DO JCOV = 1, INCOV
    IF (LDCOVER (JCOV)) THEN
      PFRAC (JLOC) = PFRAC (JLOC) + YLPTR (JCOV)%ZDATA (JLOC) * PDATA (JCOV)
      ZSUM         = ZSUM + YLPTR (JCOV)%ZDATA (JLOC)
    ENDIF
  ENDDO
  PFRAC (JLOC) = PFRAC (JLOC) / ZSUM
ENDDO
!$OMP END PARALLEL DO

END SUBROUTINE

FUNCTION RNS1 (CDNAME, PSCALE) RESULT (YLFL)

CHARACTER (LEN=*),   INTENT (IN) :: CDNAME
REAL (KIND=JPRB),    INTENT (IN), OPTIONAL :: PSCALE

TYPE (ATLAS_FIELDSET) :: YLFS
TYPE (ATLAS_FIELD) :: YLFL

! Read a field on source geometry, and insert it in the list #1

YLFS = YLDHIO%READ (CDNAME, [CDNAME], YLFSSC1, PUNDEF=ZUNDEF, PSCALE=PSCALE)

YLFL = YLFS%FIELD (1)

CALL YLFS%FINAL ()

CALL YLFL%RETURN ()

END FUNCTION

SUBROUTINE INS2 (KRANK, YDFL)

INTEGER (KIND=JPIM), INTENT (IN) :: KRANK
TYPE (ATLAS_FIELD),  INTENT (IN) :: YDFL

! Insert a field in list #2 (target)

IF (.NOT. YLFL2 (KRANK)%IS_NULL ()) CALL ABORT ('FIELD ALREADY EXISTS')
IF (YDFL%SIZE () /= YLFSSC2%SIZE ()) CALL ABORT ('SIZE MISMATCH')
YLFL2 (KRANK) = YDFL
CALL YDFL%DATA (YLPT2 (KRANK)%ZDATA)
CALL YLFLDS2%ADD (YDFL)

END SUBROUTINE

END PROGRAM

