PROGRAM ATLAS_CLIM

USE PARKIND1, ONLY : JPIM, JPRB
USE ATLAS_IO_GATHSCAT, ONLY : ATLAS_IO_GATHSCAT_t
USE ATLAS_FMT_FA, ONLY : ATLAS_FMT_FA_t
USE FCKIT_MODULE, ONLY : FCKIT_MPI_COMM
USE INTERPOLATIONA_MOD
USE INTERPOLATION4_MOD
USE ATLAS_MODULE  
USE ATLAS_HELPER
USE ATLAS_TRACE_MODULE
USE XRD_GETOPTIONS
USE READCOVERS_MOD

!

#include "atlas-abort.h"

IMPLICIT NONE

REAL (KIND=JPRB), PARAMETER :: RPI = 2.0_JPRB * ASIN (1.0_JPRB)
REAL (KIND=JPRB), PARAMETER :: RA = 6371229._JPRB
REAL (KIND=JPRB), PARAMETER :: RG = 9.80665_JPRB
REAL (KIND=JPRB), PARAMETER :: XKARMAN = 0.4_JPRB
REAL (KIND=JPRB), PARAMETER :: XCDZ0EFF = 0.8_JPRB
REAL (KIND=JPRB), PARAMETER :: ZUNDEF = HUGE (1._JPRB)
REAL (KIND=JPRB), PARAMETER :: SMASK = 0.5_JPRB

! From sucst

REAL (KIND=JPRB), PARAMETER :: RKBOL = 1.380658E-23_JPRB
REAL (KIND=JPRB), PARAMETER :: RNAVO = 6.0221367E+23_JPRB
REAL (KIND=JPRB), PARAMETER :: R     = RNAVO * RKBOL
REAL (KIND=JPRB), PARAMETER :: RMD   = 28.9644_JPRB
REAL (KIND=JPRB), PARAMETER :: RMV   = 18.0153_JPRB
REAL (KIND=JPRB), PARAMETER :: RD    = 1000._JPRB * R / RMD
REAL (KIND=JPRB), PARAMETER :: RV    = 1000._JPRB * R / RMV
REAL (KIND=JPRB), PARAMETER :: RCPV  = 4._JPRB  * RV
REAL (KIND=JPRB), PARAMETER :: RETV  = RV / RD - 1.0_JPRB
REAL (KIND=JPRB), PARAMETER :: RCW   = 4218._JPRB
REAL (KIND=JPRB), PARAMETER :: RCS   = 2106._JPRB
REAL (KIND=JPRB), PARAMETER :: RTT   = 273.16_JPRB
REAL (KIND=JPRB), PARAMETER :: RLVTT = 2.5008E+6_JPRB
REAL (KIND=JPRB), PARAMETER :: RLSTT = 2.8345E+6_JPRB
REAL (KIND=JPRB), PARAMETER :: RESTT = 611.14_JPRB
REAL (KIND=JPRB), PARAMETER :: RGAMW = (RCW - RCPV) / RV
REAL (KIND=JPRB), PARAMETER :: RBETW = RLVTT / RV + RGAMW * RTT
REAL (KIND=JPRB), PARAMETER :: RALPW = LOG (RESTT) + RBETW / RTT + RGAMW * LOG (RTT)
REAL (KIND=JPRB), PARAMETER :: RGAMS = (RCS - RCPV) / RV
REAL (KIND=JPRB), PARAMETER :: RBETS = RLSTT / RV + RGAMS * RTT
REAL (KIND=JPRB), PARAMETER :: RALPS = LOG (RESTT) + RBETS / RTT + RGAMS * LOG (RTT)
REAL (KIND=JPRB), PARAMETER :: RGAMD = RGAMS - RGAMW
REAL (KIND=JPRB), PARAMETER :: RBETD = RBETS - RBETW
REAL (KIND=JPRB), PARAMETER :: RALPD = RALPS - RALPW

! 
INTEGER (KIND=JPIM), PARAMETER :: NTPLAC = 5, NTPMER = 1, NTPGLA = 2, NTPDES = 3
!


INTEGER (KIND=JPIM), PARAMETER :: INCOVR = 256_JPIM
LOGICAL, PARAMETER :: LGARDEN = .FALSE., LWATER_TO_NATURE = .FALSE., LTOWN_TO_ROCK = .FALSE.

#include "atlas-compute-covers.h"
#include "atlas-compute-sso.h"
#include "atlas-compute-aos.h"

TYPE (ATLAS_IO_GATHSCAT_t)                :: YLFAIO
TYPE (ATLAS_FMT_FA_t),             TARGET :: YLFMFA
TYPE (ATLAS_STRUCTUREDGRID)               :: YLGRID2
TYPE (ATLAS_TRACE)                        :: YLTRAC

! Functionspaces

TYPE (ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS) :: YLFSSC2

! Distributions (of grids on MPI tasks)

TYPE (ATLAS_GRIDDISTRIBUTION)                :: YLDIST2


! Communicator

TYPE (FCKIT_MPI_COMM)                        :: YLCOMM

INTEGER (KIND=JPIM) :: I, JFLD
INTEGER (KIND=JPIM) :: NPROC, IRANK


! Atlas fields for target geometry

TYPE (ATLAS_FIELD), ALLOCATABLE :: YLFL2 (:)
TYPE (ATLAS_FIELD), ALLOCATABLE :: YLFL2M (:, :)

! Pointers to access data of target fields

TYPE (PTR),         ALLOCATABLE :: YLPT2 (:)
TYPE (PTR),         ALLOCATABLE :: YLPT2M (:, :)

INTEGER (KIND=JPIM) :: INFLD, INFLDM

! Indices of all fields

INTEGER (KIND=JPIM) :: JGEOPOTENTIEL
INTEGER (KIND=JPIM) :: JVARGEOPDIR, JSSO_SLOPE, JVARGEOPANI, JETGEOPOTENT, JZ0RELFOISG, JZ0FOISG
INTEGER (KIND=JPIM) :: JPROPURBANIS, JPROPTERRE
INTEGER (KIND=JPIM) :: JINDTERREMER, JPROPSABLE, JPROPARGILE
INTEGER (KIND=JPIM) :: JINDVEGDOMI, JALBEDOSOLNU, JEMISSIVITE, JEPAISOLMAX, JALBEDO
INTEGER (KIND=JPIM) :: JPROPVEGMAX, JALBEDOCOMPL, JPROPVEGETAT, JEPAISSOL

INTEGER (KIND=JPIM) :: JSURFTEMPERATURE, JPROFTEMPERATURE, JSURFPROPRMAXEA , JPROFPROPRMAXEA
INTEGER (KIND=JPIM) :: JSURFRESERVNEIGE, JRELATEMPERATURE, JRELAPROPRMAXEA , JSURFALBEDO
INTEGER (KIND=JPIM) :: JSURFEMISSIVITE , JSURFZ0FOISG    , JSURFINDFOLIAIRE, JSURFRESISTOMIN
INTEGER (KIND=JPIM) :: JSURFGZ0THERM   , JSURFZ0VEGFOISG , JSURFALBEDOVEG

CALL INITOPTIONS ()
CALL CHECKOPTIONS ()

YLFAIO = ATLAS_IO_GATHSCAT_t (YLFMFA)

CALL ATLAS_LIBRARY%INITIALISE ()

YLTRAC = ATLAS_TRACE (__FILE__, __LINE__, "ATLAS_CLIM")

YLCOMM = FCKIT_MPI_COMM ()
NPROC  = YLCOMM%SIZE ()
IRANK  = YLCOMM%RANK ()

CALL LINUX_BIND (IRANK, NPROC)

YLGRID2 = GRID_FROM_NAMELIST ()

! Create distributions for both source & target grids

CALL CREATE_DIST (YLGRID2, YLDIST2)

! Create functionspaces

BLOCK
  TYPE (ATLAS_CONFIG) :: YLCONF
  YLCONF = ATLAS_CONFIG ()
  CALL YLCONF%SET ("halo", 1)
  YLFSSC2 = ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS (YLGRID2, YLDIST2, YLCONF)
  CALL YLCONF%FINAL ()
ENDBLOCK

! Define indices for all fields

INFLD = 0

#define ADDFLD(J) INFLD = INFLD + 1; J = INFLD

ADDFLD (JGEOPOTENTIEL); ADDFLD (JPROPSABLE  ); ADDFLD (JPROPARGILE ); ADDFLD (JVARGEOPDIR  ); 
ADDFLD  (JSSO_SLOPE  ); ADDFLD (JVARGEOPANI ); ADDFLD (JETGEOPOTENT); ADDFLD (JINDTERREMER ); 
ADDFLD (JPROPURBANIS ); ADDFLD (JPROPTERRE  ); ADDFLD (JZ0RELFOISG ); ADDFLD (JZ0FOISG     ); 
ADDFLD (JINDVEGDOMI  ); ADDFLD (JALBEDOSOLNU); ADDFLD (JEMISSIVITE ); ADDFLD (JEPAISOLMAX  ); 
ADDFLD (JALBEDO      ); ADDFLD (JPROPVEGMAX ); ADDFLD (JALBEDOCOMPL); ADDFLD (JEPAISSOL    ); 
ADDFLD (JPROPVEGETAT);  
#undef ADDFLD

INFLDM = 0

#define ADDFLD(J) INFLDM = INFLDM + 1; J = INFLDM

ADDFLD (JSURFTEMPERATURE); ADDFLD (JPROFTEMPERATURE); 
ADDFLD (JSURFPROPRMAXEA ); ADDFLD (JPROFPROPRMAXEA );
ADDFLD (JSURFRESERVNEIGE); ADDFLD (JRELATEMPERATURE);
ADDFLD (JRELAPROPRMAXEA ); ADDFLD (JSURFALBEDO     );
ADDFLD (JSURFEMISSIVITE ); ADDFLD (JSURFZ0FOISG    );
ADDFLD (JSURFINDFOLIAIRE); ADDFLD (JSURFRESISTOMIN );
ADDFLD (JSURFGZ0THERM   ); ADDFLD (JSURFZ0VEGFOISG );
ADDFLD (JSURFALBEDOVEG  );

#undef ADDFLD

! Allocate fields & pointers

ALLOCATE (YLFL2 (INFLD), YLPT2 (INFLD), YLFL2M (INFLDM, 12), YLPT2M (INFLDM, 12))

CALL INCLI1

CALL INCLI2

CALL INCLI3

CALL INCLI4

BLOCK
  INTEGER (KIND=JPIM) :: IMONTH
  CHARACTER (LEN=4) :: CLMONTH

! Write common fields

  CALL WRFLS (YLFAIO, YLFL2, 'Const.Clim', YLFSSC2)

! Write per month fields

  DO IMONTH = 1, 12
    WRITE (CLMONTH, '(".m",I2.2)') IMONTH
    CALL WRFLS (YLFAIO, YLFL2M (:, IMONTH), 'Const.Clim'//TRIM (CLMONTH), YLFSSC2)
  ENDDO

  DO JFLD = 1, INFLD
    CALL YLFL2 (JFLD)%FINAL ()
  ENDDO

  DO IMONTH = 1, 12
    DO JFLD = 1, INFLD
      CALL YLFL2M (JFLD, IMONTH)%FINAL ()
    ENDDO
  ENDDO
ENDBLOCK


CALL YLGRID2%FINAL ()
CALL YLDIST2%FINAL ()
CALL YLFSSC2%FINAL ()

CALL YLTRAC%FINAL ()

CALL ATLAS_LIBRARY%FINALISE()

WRITE (*, *) "--- STOP ---"

CONTAINS

SUBROUTINE WRFLS (YDIO, YDFLS, CDFILE, YDFSSC)

USE ATLAS_IO, ONLY : ATLAS_IO_t

CLASS (ATLAS_IO_t),  INTENT (INOUT) :: YDIO
TYPE (ATLAS_FIELD),  INTENT (IN)    :: YDFLS (:)
CHARACTER (LEN=*),   INTENT (IN)    :: CDFILE
TYPE (ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS), INTENT (IN) :: YDFSSC

TYPE (ATLAS_FIELDSET) :: YLFLDS
INTEGER (KIND=JPIM) :: JFLD

YLFLDS = ATLAS_FIELDSET ()

DO JFLD = 1, SIZE (YDFLS)
  IF (YDFLS (JFLD)%IS_NULL ()) CYCLE
  CALL YLFLDS%ADD (YDFLS (JFLD))
ENDDO

CALL YDIO%WRITE (CDFILE, YLFLDS, YDFSSC)

CALL YLFLDS%FINAL ()

END SUBROUTINE

SUBROUTINE INCLI4

INTEGER (KIND=JPIM) :: IMONTH

DO IMONTH = 1, 12
  CALL INS2 (JSURFINDFOLIAIRE, YLFL2M (:, IMONTH), YLPT2M (:, IMONTH), NEWFLD (YLFSSC2, "SURFIND.FOLIAIRE" ))
  CALL INS2 (JSURFRESISTOMIN , YLFL2M (:, IMONTH), YLPT2M (:, IMONTH), NEWFLD (YLFSSC2, "SURFRESI.STO.MIN" ))
  CALL INS2 (JSURFGZ0THERM   , YLFL2M (:, IMONTH), YLPT2M (:, IMONTH), NEWFLD (YLFSSC2, "SURFGZ0.THERM   " ))
  CALL INS2 (JSURFZ0VEGFOISG , YLFL2M (:, IMONTH), YLPT2M (:, IMONTH), NEWFLD (YLFSSC2, "SURFZ0VEG.FOIS.G" ))
  CALL INS2 (JSURFALBEDOVEG  , YLFL2M (:, IMONTH), YLPT2M (:, IMONTH), NEWFLD (YLFSSC2, "SURFALBEDO.VEG  " ))

  YLPT2M (JSURFINDFOLIAIRE, IMONTH)%ZDATA = 0._JPRB
  YLPT2M (JSURFRESISTOMIN , IMONTH)%ZDATA = 0._JPRB
  YLPT2M (JSURFGZ0THERM   , IMONTH)%ZDATA = 0._JPRB
  YLPT2M (JSURFZ0VEGFOISG , IMONTH)%ZDATA = 0._JPRB
  YLPT2M (JSURFALBEDOVEG  , IMONTH)%ZDATA = 0._JPRB

ENDDO

END SUBROUTINE

SUBROUTINE INCLI3

USE ATLAS_FMT_N108, ONLY : ATLAS_FMT_N108_t


REAL (KIND=JPRB), PARAMETER :: RDTDZ1 = -6.5E-3_JPRB, ZGST = RDTDZ1 / RG

TYPE (ATLAS_FMT_N108_t), TARGET :: YLN108FM
TYPE (ATLAS_IO_GATHSCAT_t)      :: YLN108IO

TYPE (ATLAS_FIELDSET) :: YLFLDS108N1
TYPE (ATLAS_FIELDSET) :: YLFLDS108N2

TYPE (ATLAS_GRIDDISTRIBUTION) :: YLDIST108N
TYPE (ATLAS_STRUCTUREDGRID)   :: YLGRID108N
TYPE (ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS) :: YLFSSC108N

REAL (KIND=JPRB), POINTER :: ZLFRAC1 (:), ZOROGG1 (:), ZIFRAC1 (:)
TYPE (PTR) :: YLPTEMPG1 (12), YLPTEMPD1 (12), YLPTEMPS1 (12)

REAL (KIND=JPRB), POINTER :: ZLFRAC2 (:), ZOROGG2 (:), ZIFRAC2 (:)
TYPE (PTR) :: YLPTEMPG2 (12), YLPTEMPD2 (12), YLPTEMPS2 (12)

INTEGER (KIND=JPIM) :: JFLD, IMONTH

TYPE (INTERPOLATION4) :: YLINTE4

CHARACTER (LEN=16) :: CLNAME (39)
CHARACTER (LEN=4) :: CLMONTH

REAL (KIND=JPRB) :: SODELX (0:9)

REAL (KIND=JPRB) :: FOHU, FOWR, FOSN
REAL (KIND=JPRB) :: PTDARG, PHUARG, PXARG, PYARG
REAL (KIND=JPRB) :: ZNEI1, ZNEI2, ZNEI3, ZNEI4, ZNEI5
REAL (KIND=JPRB), PARAMETER :: ZEPS = 1.E-10_JPRB

#include "fcttrm.func.h"

! Relative humidity function (from Td and T).
FOHU (PTDARG, PTARG) = ES (PTDARG) / ES (PTARG)

! Soil relative water content function (from surface relative humidity).
FOWR (PHUARG) = ACOS (1.0_JPRB - 2.0_JPRB * PHUARG) / RPI

! Empirical snow climatology function.
FOSN (PXARG, PYARG) = MAX (0.0_JPRB, (ZNEI2 * PXARG) / (ZNEI3 - PXARG) &
& + ZNEI4 * (1.0_JPRB - COS (RPI * PYARG)) / 2.0_JPRB)  

!  to saturate the quantity of non-permanent snow.
ZNEI1 = 0.04_JPRB
!  Relative snow equivalent for a small partial permanent ice cover.
ZNEI2 = 10._JPRB
!  ZNEI2/(ZNEI3-1.) gives the maximum snow equivalent for total permanent
!  ice cover.
ZNEI3 = 1.0001_JPRB
!  Maximum non-permanent snow value.
ZNEI4 = 1000._JPRB
!  Permanent snow value on ice cap.
ZNEI5 = 10000._JPRB

BLOCK
  INTEGER (KIND=JPIM) :: J
  SODELX(0) =1.0_JPRB / SQRT (1.0_JPRB + 2.0_JPRB * RPI)
  DO J = 1, 9
    SODELX (J) = SODELX (J-1) * 2.0_JPRB * RPI
  ENDDO
ENDBLOCK

YLN108IO = ATLAS_IO_GATHSCAT_t (YLN108FM)

YLGRID108N = YLN108FM%GRID ('N108_GL')
CALL CREATE_DIST (YLGRID108N, YLDIST108N)

BLOCK
  TYPE (ATLAS_CONFIG) :: YLCONF
  YLCONF = ATLAS_CONFIG ()
  CALL YLCONF%SET ("halo", 1)
  YLFSSC108N = ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS (YLGRID108N, YLDIST108N, YLCONF)
  CALL YLCONF%FINAL ()
ENDBLOCK


CLNAME (1:3) = ['LFrac           ', 'OrogG           ', 'IFrac           ']

DO IMONTH = 1, 12
  WRITE (CLMONTH, '(".",I3.3)') IMONTH
  CLNAME (3+(IMONTH-1)*3+1) = 'Temp_g'//CLMONTH
  CLNAME (3+(IMONTH-1)*3+2) = 'Temp_d'//CLMONTH
  CLNAME (3+(IMONTH-1)*3+3) = 'Temp_s'//CLMONTH
ENDDO

YLFLDS108N1 = YLN108IO%READ ('N108_GL', CLNAME, YLFSSC108N, PUNDEF=ZUNDEF)

BLOCK
  TYPE (ATLAS_FIELD) :: YLF
 
  YLF = YLFLDS108N1%FIELD ('LFrac'); CALL YLF%DATA (ZLFRAC1); CALL YLF%FINAL ()  
  YLF = YLFLDS108N1%FIELD ('OrogG'); CALL YLF%DATA (ZOROGG1); CALL YLF%FINAL ()  
  YLF = YLFLDS108N1%FIELD ('IFrac'); CALL YLF%DATA (ZIFRAC1); CALL YLF%FINAL ()  

  DO IMONTH = 1, 12
    WRITE (CLMONTH, '(".",I3.3)') IMONTH
    YLF = YLFLDS108N1%FIELD ('Temp_g'//CLMONTH); CALL YLF%DATA (YLPTEMPG1 (IMONTH)%ZDATA); CALL YLF%FINAL ()
    YLF = YLFLDS108N1%FIELD ('Temp_d'//CLMONTH); CALL YLF%DATA (YLPTEMPD1 (IMONTH)%ZDATA); CALL YLF%FINAL ()
    YLF = YLFLDS108N1%FIELD ('Temp_d'//CLMONTH); CALL YLF%DATA (YLPTEMPS1 (IMONTH)%ZDATA); CALL YLF%FINAL ()
  ENDDO
ENDBLOCK

DO IMONTH = 1, 12
  YLPTEMPG1  (IMONTH)%ZDATA = YLPTEMPG1  (IMONTH)%ZDATA - ZGST * ZOROGG1
  YLPTEMPD1 (IMONTH)%ZDATA = YLPTEMPD1 (IMONTH)%ZDATA - ZGST * ZOROGG1
ENDDO

YLINTE4 = INTERPOLATION4 (YLDIST108N, YLFSSC108N, YLDIST2, YLFSSC2)

YLFLDS108N2 = YLINTE4%INTERPOLATE (YLFLDS108N1)

BLOCK
  TYPE (ATLAS_FIELD) :: YLF
 
  YLF = YLFLDS108N2%FIELD ('LFrac'); CALL YLF%DATA (ZLFRAC2); CALL YLF%FINAL ()  
  YLF = YLFLDS108N2%FIELD ('OrogG'); CALL YLF%DATA (ZOROGG2); CALL YLF%FINAL ()  
  YLF = YLFLDS108N2%FIELD ('IFrac'); CALL YLF%DATA (ZIFRAC2); CALL YLF%FINAL ()  

  DO IMONTH = 1, 12
    WRITE (CLMONTH, '(".",I3.3)') IMONTH
    YLF = YLFLDS108N2%FIELD ('Temp_g'//CLMONTH); CALL YLF%DATA (YLPTEMPG2 (IMONTH)%ZDATA); CALL YLF%FINAL ()
    YLF = YLFLDS108N2%FIELD ('Temp_d'//CLMONTH); CALL YLF%DATA (YLPTEMPD2 (IMONTH)%ZDATA); CALL YLF%FINAL ()
    YLF = YLFLDS108N2%FIELD ('Temp_s'//CLMONTH); CALL YLF%DATA (YLPTEMPS2 (IMONTH)%ZDATA); CALL YLF%FINAL ()
  ENDDO
ENDBLOCK


BLOCK
  INTEGER (KIND=JPIM) :: JLOC2
  REAL (KIND=JPRB) :: ZTS, ZTD, ZHU, ZWR, ZXSN, ZYSN
  
  DO IMONTH = 1, 12
    CALL INS2 (JSURFTEMPERATURE, YLFL2M (:, IMONTH), YLPT2M (:, IMONTH), NEWFLD (YLFSSC2, "SURFTEMPERATURE" ))
    CALL INS2 (JPROFTEMPERATURE, YLFL2M (:, IMONTH), YLPT2M (:, IMONTH), NEWFLD (YLFSSC2, "PROFTEMPERATURE" ))
    CALL INS2 (JSURFPROPRMAXEA , YLFL2M (:, IMONTH), YLPT2M (:, IMONTH), NEWFLD (YLFSSC2, "SURFPROP.RMAX.EA"))
    CALL INS2 (JPROFPROPRMAXEA , YLFL2M (:, IMONTH), YLPT2M (:, IMONTH), NEWFLD (YLFSSC2, "PROFPROP.RMAX.EA"))
    CALL INS2 (JSURFRESERVNEIGE, YLFL2M (:, IMONTH), YLPT2M (:, IMONTH), NEWFLD (YLFSSC2, "SURFRESERV.NEIGE"))
    CALL INS2 (JRELATEMPERATURE, YLFL2M (:, IMONTH), YLPT2M (:, IMONTH), NEWFLD (YLFSSC2, "RELATEMPERATURE" ))
    CALL INS2 (JRELAPROPRMAXEA , YLFL2M (:, IMONTH), YLPT2M (:, IMONTH), NEWFLD (YLFSSC2, "RELAPROP.RMAX.EA"))

    CALL INS2 (JSURFALBEDO     , YLFL2M (:, IMONTH), YLPT2M (:, IMONTH), NEWFLD (YLFSSC2, "SURFALBEDO"      ))
    CALL INS2 (JSURFEMISSIVITE , YLFL2M (:, IMONTH), YLPT2M (:, IMONTH), NEWFLD (YLFSSC2, "SURFEMISSIVITE"  ))
    CALL INS2 (JSURFZ0FOISG    , YLFL2M (:, IMONTH), YLPT2M (:, IMONTH), NEWFLD (YLFSSC2, "SURFZ0.FOIS.G"   ))

    DO JLOC2 = 1, YLFSSC2%SIZE_OWNED ()
      IF (YLPT2 (JINDTERREMER)%ZDATA (JLOC2) >= SMASK) THEN
        ZTS = YLPTEMPG2 (IMONTH)%ZDATA (JLOC2) + ZGST * YLPT2 (JGEOPOTENTIEL)%ZDATA (JLOC2)
        ZTD = YLPTEMPD2 (IMONTH)%ZDATA (JLOC2) + ZGST * YLPT2 (JGEOPOTENTIEL)%ZDATA (JLOC2)
        YLPT2M (JSURFTEMPERATURE, IMONTH)%ZDATA (JLOC2) = ZTS
        ZHU = FOHU (MIN (ZTD, ZTS), ZTS)
        ZWR = FOWR (MAX (0.0_JPRB, MIN (1.0_JPRB, ZHU)))
        ZXSN = MAX (0.0_JPRB, MIN (1.0_JPRB, ZIFRAC2 (JLOC2) / MAX (ZEPS, ZLFRAC2 (JLOC2))))
        ZYSN = MAX (0.0_JPRB, MIN (1.0_JPRB, ZNEI1 * ZWR * (RTT-ZTS)))
        YLPT2M (JSURFPROPRMAXEA,  IMONTH)%ZDATA (JLOC2) = ZWR
        YLPT2M (JSURFRESERVNEIGE, IMONTH)%ZDATA (JLOC2) = FOSN (ZXSN, ZYSN)
      ELSE
        YLPT2M (JSURFTEMPERATURE, IMONTH)%ZDATA (JLOC2) = YLPTEMPS2 (IMONTH)%ZDATA (JLOC2) + ZGST * YLPT2 (JGEOPOTENTIEL)%ZDATA (JLOC2)
        YLPT2M (JSURFPROPRMAXEA,  IMONTH)%ZDATA (JLOC2) = 1.0_JPRB
        YLPT2M (JSURFRESERVNEIGE, IMONTH)%ZDATA (JLOC2) = 0.0_JPRB
      ENDIF
    ENDDO
  ENDDO
ENDBLOCK

BLOCK
  INTEGER (KIND=JPIM) :: JLOC2, IMONTH
  REAL (KIND=JPRB) :: ZTSHT, ZWSHT
  REAL (KIND=JPRB) :: ZRES (YLFSSC2%SIZE_OWNED (), 2*12)
  REAL (KIND=JPRB), PARAMETER :: PPWSHT = 0.1969_JPRB

  ZTSHT = (SODELX(0) + SODELX (1)) / (2.0_JPRB * SQRT (365._JPRB))
  CALL INCLAGA (YLPT2M (JSURFTEMPERATURE, :), YLPT2M (JPROFTEMPERATURE, :), ZTSHT)

  ZWSHT = PPWSHT
  CALL INCLAGA (YLPT2M (JSURFPROPRMAXEA , :), YLPT2M (JPROFPROPRMAXEA , :), ZWSHT)

!  No lag over sea
  DO IMONTH = 1, 12
    DO JLOC2 = 1, YLFSSC2%SIZE_OWNED ()
      IF (YLPT2 (JINDTERREMER)%ZDATA (JLOC2) < SMASK) THEN
        YLPT2M (JPROFTEMPERATURE, IMONTH)%ZDATA (JLOC2) = YLPT2M (JSURFTEMPERATURE, IMONTH)%ZDATA (JLOC2)
        YLPT2M (JPROFPROPRMAXEA , IMONTH)%ZDATA (JLOC2) = YLPT2M (JSURFPROPRMAXEA , IMONTH)%ZDATA (JLOC2)
      ENDIF
    ENDDO
  ENDDO

!  Relaxation temperature and moisture (new schemes)
  DO IMONTH = 1, 12
    YLPT2M (JRELATEMPERATURE, IMONTH)%ZDATA = YLPT2M (JPROFTEMPERATURE, IMONTH)%ZDATA 
    YLPT2M (JRELAPROPRMAXEA , IMONTH)%ZDATA = YLPT2M (JPROFPROPRMAXEA , IMONTH)%ZDATA 
  ENDDO

ENDBLOCK

BLOCK
  INTEGER (KIND=JPIM) :: IMONTH, JLOC2, ITP
  REAL (KIND=JPRB), PARAMETER :: SALBB  = 0.65_JPRB, SALBM = 0.07_JPRB,  SEMIB = 0.97_JPRB,  &
                               & SEMIM  = 0.96_JPRB, SZZ0B = 0.001_JPRB, SZZ0M = 0.001_JPRB, &
                               & TMERGL = 271.23_JPRB
  REAL (KIND=JPRB), POINTER :: ZALB, ZEMI, ZZ0G
LOGICAL :: LLDBG
  DO IMONTH = 1, 12
    DO JLOC2 = 1, YLFSSC2%SIZE_OWNED ()
      ITP = NINT (YLPT2 (JINDVEGDOMI)%ZDATA (JLOC2))
!  Increased snow fraction on ice-cap
      IF (ITP == NTPGLA) THEN
        YLPT2M (JSURFRESERVNEIGE, IMONTH)%ZDATA (JLOC2) = ZNEI5
      ELSE
        YLPT2M (JSURFRESERVNEIGE, IMONTH)%ZDATA (JLOC2) = MIN (ZNEI4, YLPT2M (JSURFRESERVNEIGE, IMONTH)%ZDATA (JLOC2))
      ENDIF
      ZALB => YLPT2M (JSURFALBEDO    , IMONTH)%ZDATA (JLOC2)
      ZEMI => YLPT2M (JSURFEMISSIVITE, IMONTH)%ZDATA (JLOC2)
      ZZ0G => YLPT2M (JSURFZ0FOISG   , IMONTH)%ZDATA (JLOC2)
!  On water : albedo, emissivity and roughness length
      IF (ITP == NTPMER .OR. ITP == NTPLAC) THEN
        IF (YLPT2M (JSURFTEMPERATURE, IMONTH)%ZDATA (JLOC2) <= TMERGL) THEN
          ZALB = SALBB
          ZEMI = SEMIB
          ZZ0G = SZZ0B * RG
        ELSE
          ZALB = SALBM
          ZEMI = SEMIM
          ZZ0G = SZZ0M * RG
        ENDIF
      ELSE
        ZALB = YLPT2 (JALBEDO    )%ZDATA (JLOC2)
        ZEMI = YLPT2 (JEMISSIVITE)%ZDATA (JLOC2)
        ZZ0G = YLPT2 (JZ0FOISG   )%ZDATA (JLOC2)
      ENDIF
    ENDDO
  ENDDO
ENDBLOCK

CALL YLFAIO%WRITE ('N108', YLFLDS108N2, YLFSSC2)

END SUBROUTINE

SUBROUTINE INCLAGA (YDSURF, YDPROF, PSHT)

TYPE (PTR) :: YDSURF (:)
TYPE (PTR) :: YDPROF (:)
REAL (KIND=JPRB), INTENT (IN) :: PSHT

#include "inclag.intfb.h"

INTEGER (KIND=JPIM) :: JLOC2, IMONTH, NGPTOT2
REAL (KIND=JPRB) :: ZTSHT
REAL (KIND=JPRB) :: ZRES (YLFSSC2%SIZE_OWNED (), 2*12)

NGPTOT2 = YLFSSC2%SIZE_OWNED () 

DO IMONTH = 1, 12
  DO JLOC2 = 1, NGPTOT2
    ZRES (JLOC2, 1+2*(IMONTH-1)) = YDSURF (IMONTH)%ZDATA (JLOC2) 
  ENDDO
ENDDO

CALL INCLAG (ZRES, PSHT, NGPTOT2, NGPTOT2, 2*12_JPIM, 2_JPIM)

DO IMONTH = 1, 12
  DO JLOC2 = 1, NGPTOT2
    YDPROF (IMONTH)%ZDATA (JLOC2) = ZRES (JLOC2, 2+2*(IMONTH-1))
  ENDDO
ENDDO

END SUBROUTINE INCLAGA


SUBROUTINE INCLI1

USE ATLAS_IO_DH, ONLY : ATLAS_IO_DH_t

TYPE (ATLAS_IO_DH_t)                      :: YLDHIO

TYPE (ATLAS_GRIDDISTRIBUTION)             :: YLDIST1
TYPE (ATLAS_STRUCTUREDGRID)               :: YLGRID1

! Grids of input files

TYPE (ATLAS_STRUCTUREDGRID)               :: YLGRID_OROG
TYPE (ATLAS_STRUCTUREDGRID)               :: YLGRID_SABL
TYPE (ATLAS_STRUCTUREDGRID)               :: YLGRID_ARGI
TYPE (ATLAS_STRUCTUREDGRID)               :: YLGRID_COVR


TYPE (ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS) :: YLFSSC1

! Interpolation (source grid -> target grid)

TYPE (INTERPOLATIONA)                        :: YLINTEA

TYPE (ATLAS_FIELDSET) :: YLCOVR2S, YLAOSP2S
TYPE (ATLAS_FIELD)    :: YLOROG1, YLARGI1, YLSABL1, YLCOVR1
REAL (KIND=JPRB), POINTER, DIMENSION (:) :: ZOROG1, ZARGI1, ZSABL1, ZCOVR1

YLDHIO = ATLAS_IO_DH_t (YLGRID2)

! Create source grids & check compatibility

YLGRID_OROG = YLDHIO%GRID ("SURFGEOPOTENTIEL")
YLGRID_ARGI = YLDHIO%GRID ("SURFPROP.ARGILE" )
YLGRID_SABL = YLDHIO%GRID ("SURFPROP.SABLE"  )
YLGRID_COVR = YLDHIO%GRID ("SFX.COVER"       )

IF (.NOT. (GRID_EQ (YLGRID_OROG, YLGRID_ARGI))) CALL ABORT ("GEOMETRY MISMATCH")
IF (.NOT. (GRID_EQ (YLGRID_OROG, YLGRID_SABL))) CALL ABORT ("GEOMETRY MISMATCH")
IF (.NOT. (GRID_EQ (YLGRID_OROG, YLGRID_COVR))) CALL ABORT ("GEOMETRY MISMATCH")

YLGRID1 = YLGRID_OROG

CALL CREATE_DIST (YLGRID1, YLDIST1, .TRUE.)

! Not needed anymore, finalize

CALL YLGRID_OROG%FINAL ()
CALL YLGRID_ARGI%FINAL ()
CALL YLGRID_SABL%FINAL ()
CALL YLGRID_COVR%FINAL ()

BLOCK
  TYPE (ATLAS_CONFIG) :: YLCONF
  YLCONF = ATLAS_CONFIG ()
  CALL YLCONF%SET ("halo", 1)
  YLFSSC1 = ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS (YLGRID1, YLDIST1, YLCONF)
  CALL YLCONF%FINAL ()
ENDBLOCK

! Create interpolation object (source -> target)

YLINTEA = INTERPOLATIONA (YLDIST1, YLFSSC1, YLDIST2, YLFSSC2, LDOPENMP=.TRUE.)

! Read input fields on source geometry

YLOROG1 = RNS1 (YLDHIO, YLFSSC1, "SURFGEOPOTENTIEL", PSCALE=RG); CALL YLOROG1%DATA (ZOROG1)
YLARGI1 = RNS1 (YLDHIO, YLFSSC1, "SURFPROP.ARGILE"            ); CALL YLARGI1%DATA (ZARGI1)
YLSABL1 = RNS1 (YLDHIO, YLFSSC1, "SURFPROP.SABLE"             ); CALL YLSABL1%DATA (ZSABL1)
YLCOVR1 = RNS1 (YLDHIO, YLFSSC1, "SFX.COVER"                  ); CALL YLCOVR1%DATA (ZCOVR1)

YLCOVR2S = ATLAS_COMPUTE_COVERS (YLFSSC1, YLFSSC2, YLCOVR1, YLINTEA, LDOPENMP=.TRUE.) 

! Set missing values of orography

!$OMP WORKSHARE
WHERE (ZCOVR1 == 1._JPRB) ! Sea 
  ZOROG1 = ZUNDEF
ENDWHERE
!$OMP END WORKSHARE

CALL INS2 (JINDTERREMER, YLFL2, YLPT2, NEWFLD (YLFSSC2, "SURFIND.TERREMER"))

BLOCK
  TYPE (ATLAS_FIELD) :: YLCOVR2
  REAL (KIND=JPRB), POINTER :: ZCOVR2 (:)

  YLCOVR2 = YLCOVR2S%FIELD ("COVER001")
  CALL YLCOVR2%DATA (ZCOVR2)

!$OMP WORKSHARE
  WHERE (ZCOVR2 > SMASK)
    YLPT2 (JINDTERREMER)%ZDATA = 0._JPRB
  ELSE WHERE
    YLPT2 (JINDTERREMER)%ZDATA = 1._JPRB
  END WHERE
!$OMP END WORKSHARE

  CALL YLCOVR2%FINAL ()

ENDBLOCK

! Interpolate fields using box averaging

BLOCK
  TYPE (ATLAS_FIELDSET) :: YLFLDS1
  TYPE (ATLAS_FIELDSET) :: YLFLDS2I

  YLFLDS1 = ATLAS_FIELDSET ()

  CALL YLFLDS1%ADD (YLOROG1)
  CALL YLFLDS1%ADD (YLARGI1)
  CALL YLFLDS1%ADD (YLSABL1)
  YLFLDS2I = YLINTEA%INTERPOLATE (YLFLDS1)
  CALL YLFLDS1%FINAL ()

! Insert interpolated fields in the list of fields of target geometry

  CALL INS2 (JGEOPOTENTIEL, YLFL2, YLPT2, YLFLDS2I%FIELD ("SURFGEOPOTENTIEL"))
  CALL INS2 (JPROPSABLE   , YLFL2, YLPT2, YLFLDS2I%FIELD ("SURFPROP.SABLE"  ))
  CALL INS2 (JPROPARGILE  , YLFL2, YLPT2, YLFLDS2I%FIELD ("SURFPROP.ARGILE" ))

  CALL YLFLDS2I%FINAL ()
ENDBLOCK

BLOCK
  TYPE (ATLAS_FIELDSET) :: YLFLDS2SSO
  TYPE (ATLAS_FIELD)    :: YLFLD2

  YLFLDS2SSO = ATLAS_COMPUTE_SSO (YLFSSC1, YLFSSC2, YLOROG1, YLFL2 (JGEOPOTENTIEL), YLINTEA, LDOPENMP=.TRUE., LDROTATE=.TRUE.) 

  YLFLD2 = YLFLDS2SSO%FIELD ("SSO_DIR"  ); CALL YLFLD2%RENAME ("SURFVAR.GEOP.DIR"); CALL INS2 (JVARGEOPDIR , YLFL2, YLPT2, YLFLD2)
  YLFLD2 = YLFLDS2SSO%FIELD ("SSO_ANIS" ); CALL YLFLD2%RENAME ("SURFVAR.GEOP.ANI"); CALL INS2 (JVARGEOPANI , YLFL2, YLPT2, YLFLD2)
  YLFLD2 = YLFLDS2SSO%FIELD ("SSO_STDEV"); CALL YLFLD2%RENAME ("SURFET.GEOPOTENT"); CALL INS2 (JETGEOPOTENT, YLFL2, YLPT2, YLFLD2)


!$OMP WORKSHARE
  WHERE (YLPT2 (JVARGEOPANI)%ZDATA /= ZUNDEF)
    YLPT2 (JVARGEOPANI)%ZDATA (:) = YLPT2 (JVARGEOPANI)%ZDATA (:) ** 2
  END WHERE
!$OMP END WORKSHARE

!$OMP WORKSHARE
  WHERE (YLPT2 (JVARGEOPDIR)%ZDATA /= ZUNDEF)
    YLPT2 (JVARGEOPDIR)%ZDATA (:) = YLPT2 (JVARGEOPDIR)%ZDATA (:) * RPI / 180._JPRB
  END WHERE
!$OMP END WORKSHARE

ENDBLOCK

! Add enveloppe

!$OMP WORKSHARE 
  WHERE (YLPT2 (JGEOPOTENTIEL)%ZDATA (:) /= ZUNDEF)
    YLPT2 (JGEOPOTENTIEL)%ZDATA (:) = YLPT2 (JGEOPOTENTIEL)%ZDATA (:) + YLPT2 (JETGEOPOTENT)%ZDATA
  ENDWHERE
!$OMP END WORKSHARE

BLOCK
  TYPE (INTERPOLATION4) :: YLINTE4
  REAL (KIND=JPRB) :: ZLOC2 (YLFSSC2%SIZE ())
  REAL (KIND=JPRB), POINTER, DIMENSION (:) :: ZAOSIP2, ZAOSIM2, ZAOSJP2, ZAOSJM2, &
                                            & ZHO2IP2, ZHO2IM2, ZHO2JP2, ZHO2JM2
  TYPE (ATLAS_FIELD) :: YLFLD2

  YLINTE4 = INTERPOLATION4 (YLDIST2, YLFSSC2, YLDIST1, YLFSSC1)
  YLAOSP2S = ATLAS_COMPUTE_AOS (YLFSSC1, YLFSSC2, YLOROG1, YLFL2 (JGEOPOTENTIEL), YLINTEA, YLINTE4, LDOPENMP=.TRUE.) 

#define GF(n, z) YLFLD2 = YLAOSP2S%FIELD (#n); CALL YLFLD2%DATA (z); CALL YLFLD2%FINAL ()
  GF (AOSIP, ZAOSIP2)
  GF (AOSIM, ZAOSIM2)
  GF (AOSJP, ZAOSJP2)
  GF (AOSJM, ZAOSJM2)
  GF (HO2IP, ZHO2IP2)
  GF (HO2IM, ZHO2IM2)
  GF (HO2JP, ZHO2JP2)
  GF (HO2JM, ZHO2JM2)
#undef GF

  CALL INS2 (JZ0RELFOISG, YLFL2, YLPT2, NEWFLD (YLFSSC2, "SURFZ0REL.FOIS.G" ))
  CALL INS2 (JZ0FOISG,    YLFL2, YLPT2, NEWFLD (YLFSSC2, "SURFZ0.FOIS.G"    ))

  WHERE (YLPT2 (JGEOPOTENTIEL)%ZDATA /= ZUNDEF)
    ZLOC2 (:) = 0.25_JPRB * XCDZ0EFF / (2._JPRB * XKARMAN**2) &
            & * (ZAOSIP2 (:) + ZAOSIM2 (:) + ZAOSJP2 (:) + ZAOSJM2 (:))        
    WHERE (ZLOC2 (:) > 0._JPRB)
      YLPT2 (JZ0RELFOISG)%ZDATA = 0.25_JPRB * (ZHO2IP2 (:) + ZHO2IM2 (:) + ZHO2JP2 (:) + ZHO2JM2 (:)) &
                              & * EXP (-SQRT (1._JPRB / ZLOC2 (:)))
      YLPT2 (JZ0RELFOISG)%ZDATA = MAX (YLPT2 (JZ0RELFOISG)%ZDATA (:), 1E-10_JPRB)
    ELSEWHERE
      YLPT2 (JZ0RELFOISG)%ZDATA = 0._JPRB
    END WHERE
  ELSE WHERE
    YLPT2 (JZ0RELFOISG)%ZDATA = ZUNDEF
  END WHERE

  YLPT2 (JZ0FOISG)%ZDATA = YLPT2 (JZ0RELFOISG)%ZDATA

  CALL YLINTE4%FINAL ()
ENDBLOCK

CALL COMPUTE_FRACTIONS (YLCOVR2S)

! Fix missing values: orography parameters, set to zero

BLOCK
  INTEGER (KIND=JPIM) :: IZS (6)
  IZS = [JGEOPOTENTIEL,  JVARGEOPDIR, JVARGEOPANI,  JETGEOPOTENT, JZ0RELFOISG, JZ0FOISG]

  DO JFLD = 1, SIZE (IZS)
!$OMP WORKSHARE 
    WHERE (YLPT2 (IZS (JFLD))%ZDATA == ZUNDEF)
      YLPT2 (IZS (JFLD))%ZDATA = 0._JPRB
    ENDWHERE
!$OMP END WORKSHARE
  ENDDO

ENDBLOCK

! Fix missing values : clay & sand

!$OMP WORKSHARE
WHERE (YLPT2 (JPROPSABLE)%ZDATA == ZUNDEF)
  YLPT2 (JPROPSABLE)%ZDATA = 0._JPRB
END WHERE
!$OMP END WORKSHARE
!$OMP WORKSHARE
WHERE (YLPT2 (JPROPARGILE)%ZDATA == ZUNDEF)
  YLPT2 (JPROPARGILE)%ZDATA = 0._JPRB
END WHERE
!$OMP END WORKSHARE

CALL YLCOVR2S%FINAL ()
CALL YLAOSP2S%FINAL ()
CALL YLOROG1%FINAL ()
CALL YLARGI1%FINAL ()
CALL YLSABL1%FINAL ()
CALL YLCOVR1%FINAL ()
CALL YLINTEA%FINAL ()
CALL YLGRID1%FINAL ()
CALL YLDIST1%FINAL ()
CALL YLFSSC1%FINAL ()

END SUBROUTINE INCLI1

SUBROUTINE INCLI2

USE ATLAS_FMT_SOIL_AND_VEG, ONLY : ATLAS_FMT_SOIL_AND_VEG_t

TYPE (INTERPOLATION4) :: YLINTEG
TYPE (ATLAS_FIELDSET) :: YLFSG1, YLFSG2
TYPE (ATLAS_FIELD) :: YLF

TYPE (ATLAS_IO_GATHSCAT_t)                :: YLFBIO
TYPE (ATLAS_FMT_SOIL_AND_VEG_t),   TARGET :: YLFMFB
TYPE (ATLAS_STRUCTUREDGRID)               :: YLGRIDG

TYPE (ATLAS_GRIDDISTRIBUTION)                :: YLDISTG
TYPE (ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS) :: YLFSSCG

INTEGER (KIND=JPIM) :: IDITP (5)
CHARACTER (LEN=16) :: CLNAMG (14)
INTEGER (KIND=JPIM) :: JFLD
TYPE (PTR), ALLOCATABLE :: YLPTG2 (:)
INTEGER (KIND=JPIM) :: Jwpl_GL, Jtpl_GL, Jsnl_GL, Jz0v_GL, Jvgx_GL, Jsab_GL, Jrsm_GL
INTEGER (KIND=JPIM) :: Jitp_GL, Jemi_GL, Jdps_GL, Jdpr_GL, Jarg_GL, Jalv_GL, Jalb_GL
INTEGER (KIND=JPIM) :: Jitp1GL, Jitp2GL, Jitp3GL, Jitp4GL, Jitp5GL
INTEGER (KIND=JPIM) :: INFLDG

INFLDG = 0

#define ADDFLD(J) INFLDG = INFLDG + 1; J = INFLDG

ADDFLD (Jwpl_GL      ); ADDFLD (Jtpl_GL     ); ADDFLD (Jsnl_GL     ); ADDFLD (Jz0v_GL     ); 
ADDFLD (Jvgx_GL      ); ADDFLD (Jsab_GL     ); ADDFLD (Jrsm_GL     ); ADDFLD (Jitp_GL     ); 
ADDFLD (Jemi_GL      ); ADDFLD (Jdps_GL     ); ADDFLD (Jdpr_GL     ); ADDFLD (Jarg_GL     ); 
ADDFLD (Jalv_GL      ); ADDFLD (Jalb_GL     );
ADDFLD (Jitp1GL      ); ADDFLD (Jitp2GL     ); ADDFLD (Jitp3GL     ); ADDFLD (Jitp4GL     ); 
ADDFLD (Jitp5GL      ); 

#undef ADDFLD

ALLOCATE (YLPTG2 (INFLDG))

YLFBIO = ATLAS_IO_GATHSCAT_t (YLFMFB)

YLGRIDG = YLFMFB%GRID ("wpl_GL")

CALL CREATE_DIST (YLGRIDG, YLDISTG)

BLOCK
  TYPE (ATLAS_CONFIG) :: YLCONF
  YLCONF = ATLAS_CONFIG ()
  CALL YLCONF%SET ("halo", 1)
  YLFSSCG = ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS (YLGRIDG, YLDISTG, YLCONF)
  CALL YLCONF%FINAL ()
ENDBLOCK

CLNAMG = ['wpl_GL          ', 'tpl_GL          ', 'snl_GL          ', 'z0v_GL          ', &
       &  'vgx_GL          ', 'sab_GL          ', 'rsm_GL          ', 'itp_GL          ', &
       &  'emi_GL          ', 'dps_GL          ', 'dpr_GL          ', 'arg_GL          ', &
       &  'alv_GL          ', 'alb_GL          ']

YLINTEG = INTERPOLATION4 (YLDISTG, YLFSSCG, YLDIST2, YLFSSC2)

YLFSG1 = YLFBIO%READ ('', CLNAMG, YLFSSCG, PUNDEF=ZUNDEF)

! Create fields of density for each type

BLOCK
  TYPE (PTR) :: YLITP (5)
  TYPE (ATLAS_FIELD) :: YLITP1
  REAL (KIND=JPRB), POINTER :: ZITP1 (:)
  INTEGER (KIND=JPIM) :: JLOC1, JTYP1

  DO JFLD = 1, 5
    BLOCK
      TYPE (ATLAS_FIELD) :: YLF
      CHARACTER (LEN=16) :: CLNAME
      WRITE (CLNAME, '("itp_GL.",I3.3)') JFLD
      YLF = NEWFLD (YLFSSCG, CLNAME, ZUNDEF)
      CALL YLFSG1%ADD (YLF)
      CALL YLF%DATA (YLITP (JFLD)%ZDATA)
      YLITP (JFLD)%ZDATA = 0._JPRB
      CALL YLF%FINAL ()
    ENDBLOCK
  ENDDO

  YLITP1 = YLFSG1%FIELD ('itp_GL')
  CALL YLITP1%DATA (ZITP1)
  DO JLOC1 = 1, YLFSSCG%SIZE_OWNED ()
    JTYP1 = NINT (ZITP1 (JLOC1))
    IF ((JTYP1 < 1) .OR. (5 < JTYP1)) THEN
      WRITE (0, *) 'ATLAS_CLIM: UNEXPECTED VALUE FOR itp_GL: ', JLOC1, JTYP1, ZITP1 (JLOC1)
      CALL ABORT ('ATLAS_CLIM: UNEXPECTED VALUE FOR itp_GL')
    ENDIF
    YLITP (JTYP1)%ZDATA (JLOC1) = 1._JPRB
  ENDDO
  CALL YLITP1%FINAL ()
ENDBLOCK

YLFSG2 = YLINTEG%INTERPOLATE (YLFSG1)

! Add to final list

DO JFLD = 1, YLFSG2%SIZE ()
  YLF = YLFSG2%FIELD (JFLD)
  CALL YLF%DATA (YLPTG2 (JFLD)%ZDATA)
  CALL YLF%FINAL ()
ENDDO

IDITP = [Jitp1GL, Jitp2GL, Jitp3GL, Jitp4GL, Jitp5GL]

YLF = YLFSG2%FIELD ('alb_GL'); CALL YLF%RENAME ('SURFALBEDO.SOLNU'); CALL INS2 (JALBEDOSOLNU, YLFL2, YLPT2, YLF); CALL YLF%FINAL ()
YLF = YLFSG2%FIELD ('emi_GL'); CALL YLF%RENAME ('SURFEMISSIVITE'  ); CALL INS2 (JEMISSIVITE , YLFL2, YLPT2, YLF); CALL YLF%FINAL ()
YLF = YLFSG2%FIELD ('dps_GL'); CALL YLF%RENAME ('SURFEPAI.SOL.MAX'); CALL INS2 (JEPAISOLMAX , YLFL2, YLPT2, YLF); CALL YLF%FINAL ()

! Find vegetation dominant index

CALL INS2 (JINDVEGDOMI, YLFL2, YLPT2, NEWFLD (YLFSSC2, 'SURFIND.VEG.DOMI'))

BLOCK
  REAL (KIND=JPRB) :: IVS, IVD, ZITP
  REAL (KIND=JPRB) :: ZMAX1, ZMAX2
  INTEGER (KIND=JPIM) :: JLOC2, JT, ILSM

  DO JLOC2 = 1, YLFSSC2%SIZE_OWNED ()

    ZMAX1 = 0.0_JPRB; ZMAX2 = 0.0_JPRB
    IVD   = 0_JPIM  ; IVS   = 0_JPIM

    DO JT = 1, 5
      ZITP = YLPTG2 (IDITP (JT))%ZDATA (JLOC2)
      IF (ZITP > ZMAX1) THEN
        ZMAX1 = ZITP
        IVD = JT
      ENDIF
    ENDDO
    DO JT = 1, 5
      IF (JT == IVD) CYCLE
      ZITP = YLPTG2 (IDITP (JT))%ZDATA (JLOC2)
      IF (ZITP > ZMAX2) THEN
        ZMAX2 = ZITP
        IVS = JT
      ENDIF
    ENDDO

    ILSM = NINT (YLPT2 (JINDTERREMER)%ZDATA (JLOC2))

    IF (ILSM == 0 .AND. IVD /= NTPLAC) IVD = NTPMER
    IF ((IVD == NTPMER .OR. IVD == NTPLAC) .AND. (ILSM == 1)) THEN
      IF (IVS == 0) THEN
        IVD = NTPDES
      ELSE
        IVD = IVS
      ENDIF
    ENDIF

    YLPT2 (JINDVEGDOMI)%ZDATA (JLOC2) = REAL (IVD, JPRB)

  ENDDO
ENDBLOCK

CALL INS2 (JEPAISSOL,    YLFL2, YLPT2, NEWFLD (YLFSSC2, 'SURFEPAIS.SOL'   ))
CALL INS2 (JPROPVEGMAX,  YLFL2, YLPT2, NEWFLD (YLFSSC2, 'SURFPROP.VEG.MAX'))
CALL INS2 (JPROPVEGETAT, YLFL2, YLPT2, NEWFLD (YLFSSC2, 'SURFPROP.VEGETAT'))

BLOCK
  INTEGER (KIND=JPIM) :: JLOC2
  TYPE (ATLAS_FIELD) :: YLVGX, YLDPR
  REAL (KIND=JPRB), POINTER :: ZVGX (:), ZDPR (:)
  REAL (KIND=JPRB) :: ZV, ZD, ZEPAISOLMAX
  REAL (KIND=JPRB), PARAMETER :: SVEG = 0.02_JPRB
  YLVGX = YLFSG2%FIELD ('vgx_GL'); CALL YLVGX%DATA (ZVGX)
  YLDPR = YLFSG2%FIELD ('dpr_GL'); CALL YLDPR%DATA (ZDPR)
  DO JLOC2 = 1, YLFSSC2%SIZE_OWNED ()
    ZV = ZVGX (JLOC2)
    ZD = ZDPR (JLOC2)
    ZV = MAX (0.0_JPRB, MIN (1.0_JPRB, ZV))
    IF (ZV < SVEG) ZV = 0.0_JPRB
    ZEPAISOLMAX = YLPT2 (JEPAISOLMAX)%ZDATA (JLOC2)
    YLPT2 (JEPAISSOL   )%ZDATA (JLOC2) = ZV * MIN (ZD, ZEPAISOLMAX) &
                                       & + (1.0_JPRB - ZV) * ZEPAISOLMAX 
    YLPT2 (JPROPVEGMAX )%ZDATA (JLOC2) = ZV
    YLPT2 (JPROPVEGETAT)%ZDATA (JLOC2) = ZV
  ENDDO
  CALL YLVGX%FINAL ()
  CALL YLDPR%FINAL ()
ENDBLOCK  

! Final calculations

BLOCK
  INTEGER (KIND=JPIM) :: JLOC2
  INTEGER (KIND=JPIM) :: IV

  REAL (KIND=JPRB), PARAMETER :: SALBG =  0.75_JPRB, SALBM =  0.07_JPRB, SARGN =  3.00_JPRB, &
                               & SDEPN =  0.10_JPRB, SDEPX =  8.00_JPRB, SEMIG =  0.98_JPRB, &
                               & SEMIN =  0.90_JPRB, SSABN =  6.00_JPRB, SARGX = 58.00_JPRB, &
                               & SALBN =  0.05_JPRB, SALBX =  0.80_JPRB, SEMIX =  1.00_JPRB, &
                               & SEMIM =  0.96_JPRB, SSABX = 92.00_JPRB

  DO JLOC2 = 1, YLFSSC2%SIZE_OWNED ()
    IV = NINT (YLPT2 (JINDVEGDOMI)%ZDATA (JLOC2))
    IF (IV < 1 .OR. IV > 5) THEN
      WRITE (0, *) 'UNEXPECTED VEGETATION INDEX', JLOC2, IV
      CALL ABORT ('UNEXPECTED VEGETATION INDEX')
    ENDIF
    SELECT CASE (IV)
      CASE (NTPMER, NTPLAC)

        YLPT2 (JALBEDOSOLNU)%ZDATA (JLOC2) = SALBM
        YLPT2 (JEMISSIVITE )%ZDATA (JLOC2) = SEMIM
        YLPT2 (JEPAISOLMAX )%ZDATA (JLOC2) = SDEPX
        YLPT2 (JPROPARGILE )%ZDATA (JLOC2) = SARGN
        YLPT2 (JPROPSABLE  )%ZDATA (JLOC2) = SSABN
        YLPT2 (JPROPVEGMAX )%ZDATA (JLOC2) = 0.0_JPRB
        YLPT2 (JEPAISSOL   )%ZDATA (JLOC2) = SDEPX
        YLPT2 (JPROPURBANIS)%ZDATA (JLOC2) = 0.0_JPRB

      CASE (NTPGLA) 
      
        YLPT2 (JALBEDOSOLNU)%ZDATA (JLOC2) = SALBG
        YLPT2 (JEMISSIVITE )%ZDATA (JLOC2) = SEMIG
        YLPT2 (JEPAISOLMAX )%ZDATA (JLOC2) = SDEPN
        YLPT2 (JPROPARGILE )%ZDATA (JLOC2) = SARGN
        YLPT2 (JPROPSABLE  )%ZDATA (JLOC2) = SSABN
        YLPT2 (JPROPVEGMAX )%ZDATA (JLOC2) = 0.0_JPRB
        YLPT2 (JEPAISSOL   )%ZDATA (JLOC2) = SDEPN
        YLPT2 (JPROPURBANIS)%ZDATA (JLOC2) = 0.0_JPRB

      CASE DEFAULT

        BLOCK
          REAL (KIND=JPRB) :: ZZARG, ZZSAB, ZSUM

          ZZARG = MAX (SARGN, MIN (SARGX, YLPT2 (JPROPARGILE )%ZDATA (JLOC2)))
          ZZSAB = MAX (SSABN, MIN (SSABX, YLPT2 (JPROPSABLE  )%ZDATA (JLOC2)))
          ZSUM  = MAX (100._JPRB, ZZARG + ZZSAB) / 100._JPRB

          YLPT2 (JALBEDOSOLNU)%ZDATA (JLOC2) = MAX (SALBN,MIN (SALBX, YLPT2 (JALBEDOSOLNU)%ZDATA (JLOC2)))
          YLPT2 (JEMISSIVITE )%ZDATA (JLOC2) = MAX (SEMIN,MIN (SEMIX, YLPT2 (JEMISSIVITE )%ZDATA (JLOC2)))
          YLPT2 (JEPAISOLMAX )%ZDATA (JLOC2) = MAX (SDEPN,MIN (SDEPX, YLPT2 (JEPAISOLMAX )%ZDATA (JLOC2)))
          YLPT2 (JPROPARGILE )%ZDATA (JLOC2) = ZZARG / ZSUM
          YLPT2 (JPROPSABLE  )%ZDATA (JLOC2) = ZZSAB / ZSUM
          YLPT2 (JPROPVEGMAX )%ZDATA (JLOC2) = YLPT2 (JPROPVEGMAX)%ZDATA (JLOC2) * YLPT2 (JPROPTERRE)%ZDATA (JLOC2)
          YLPT2 (JEPAISSOL   )%ZDATA (JLOC2) = MAX (SDEPN, MIN (YLPT2 (JEPAISOLMAX )%ZDATA (JLOC2), YLPT2 (JEPAISSOL   )%ZDATA (JLOC2)))
          YLPT2 (JPROPURBANIS)%ZDATA (JLOC2) = MIN (1.0_JPRB - YLPT2 (JPROPVEGMAX )%ZDATA (JLOC2), YLPT2 (JPROPURBANIS)%ZDATA (JLOC2))
        ENDBLOCK

    END SELECT
  ENDDO
ENDBLOCK

! Other albedo fields
CALL INS2 (JALBEDO     , YLFL2, YLPT2, NEWFLD (YLFSSC2, 'SURFALBEDO'      ))
CALL INS2 (JALBEDOCOMPL, YLFL2, YLPT2, NEWFLD (YLFSSC2, 'SURFALBEDO.COMPL'))

!$OMP WORKSHARE
YLPT2 (JALBEDO     )%ZDATA = YLPT2 (JALBEDOSOLNU)%ZDATA
!$OMP END WORKSHARE
!$OMP WORKSHARE
YLPT2 (JALBEDOCOMPL)%ZDATA = YLPT2 (JALBEDOSOLNU)%ZDATA
!$OMP END WORKSHARE


CALL YLFSG1 %FINAL ()
CALL YLFSG2 %FINAL ()
CALL YLINTEG%FINAL ()
CALL YLGRIDG%FINAL ()
CALL YLDISTG%FINAL ()
CALL YLFSSCG%FINAL ()

END SUBROUTINE INCLI2

SUBROUTINE COMPUTE_FRACTIONS (YDCOVR2S)

TYPE (ATLAS_FIELDSET) :: YDCOVR2S

TYPE (ATLAS_FIELD) :: YLFL2COV (INCOVR)
REAL (KIND=JPRB) :: ZFRAC_MER (YLFSSC2%SIZE ()), ZFRAC_EAU (YLFSSC2%SIZE ())
TYPE (COVERS_t) :: YLCOVERS
LOGICAL, ALLOCATABLE :: LCOVER (:)
INTEGER (KIND=JPIM) :: ICOVR

REAL (KIND=JPRB) :: ZAVGCOVR2 (INCOVR)
REAL (KIND=JPRB) :: ZMINCOVR2 (INCOVR)
REAL (KIND=JPRB) :: ZMAXCOVR2 (INCOVR)

DO ICOVR = 1, INCOVR
  YLFL2COV (ICOVR) = YDCOVR2S%FIELD (ICOVR)
ENDDO

! Create fractions fields

CALL INS2 (JPROPURBANIS, YLFL2, YLPT2, NEWFLD (YLFSSC2, "SURFPROP.URBANIS" ))
CALL INS2 (JPROPTERRE,   YLFL2, YLPT2, NEWFLD (YLFSSC2, "SURFPROP.TERRE"   ))
CALL READCOVERS (YLCOVERS, 1, LGARDEN, LWATER_TO_NATURE, LTOWN_TO_ROCK)
CALL FIELDSTAT (YLFSSC2, YLFL2COV, PMIN=ZMINCOVR2, PMAX=ZMAXCOVR2, PAVG=ZAVGCOVR2)

ALLOCATE (LCOVER (YLCOVERS%JPCOVER))
LCOVER = .FALSE.

LCOVER = ZAVGCOVR2 > 0._JPRB

CALL MAKEFRAC (ZFRAC_MER                 , YLFL2COV, YLCOVERS%XDATA_SEA  , LCOVER)
CALL MAKEFRAC (ZFRAC_EAU                 , YLFL2COV, YLCOVERS%XDATA_WATER, LCOVER)
CALL MAKEFRAC (YLPT2 (JPROPURBANIS)%ZDATA, YLFL2COV, YLCOVERS%XDATA_TOWN , LCOVER)

!$OMP WORKSHARE
  YLPT2 (JPROPTERRE)%ZDATA = 1._JPRB - (ZFRAC_MER + ZFRAC_EAU)
!$OMP END WORKSHARE

!$OMP WORKSHARE
WHERE (ZFRAC_EAU > SMASK)
  YLPT2 (JINDTERREMER)%ZDATA = 0._JPRB
ENDWHERE
!$OMP END WORKSHARE

END SUBROUTINE

SUBROUTINE MAKEFRAC (PFRAC, YDCOVER, PDATA, LDCOVER)

REAL (KIND=JPRB),   INTENT (OUT) :: PFRAC (:)
TYPE (ATLAS_FIELD), INTENT (IN)  :: YDCOVER (:)
REAL (KIND=JPRB),   INTENT (IN)  :: PDATA (:)
LOGICAL,            INTENT (IN)  :: LDCOVER (:)

TYPE (PTR) :: YLPTR (SIZE (YDCOVER))

INTEGER (KIND=JPIM) :: JLOC, JCOV, INCOV
REAL (KIND=JPRB) :: ZSUM

INCOV = SIZE (YDCOVER)

DO JCOV = 1, INCOV
  CALL YDCOVER (JCOV)%DATA (YLPTR (JCOV)%ZDATA)
ENDDO

! 1D computation

!$OMP PARALLEL DO PRIVATE (JLOC, ZSUM, JCOV) 
DO JLOC = 1, SIZE (PFRAC)
  PFRAC (JLOC) = 0._JPRB
  ZSUM = 0._JPRB
  DO JCOV = 1, INCOV
    IF (LDCOVER (JCOV)) THEN
      PFRAC (JLOC) = PFRAC (JLOC) + YLPTR (JCOV)%ZDATA (JLOC) * PDATA (JCOV)
      ZSUM         = ZSUM + YLPTR (JCOV)%ZDATA (JLOC)
    ENDIF
  ENDDO
  PFRAC (JLOC) = PFRAC (JLOC) / ZSUM
ENDDO
!$OMP END PARALLEL DO

END SUBROUTINE

FUNCTION RNS1 (YDDHIO, YDFSSC1, CDNAME, PSCALE) RESULT (YLFL)

USE ATLAS_IO_DH, ONLY : ATLAS_IO_DH_t

TYPE (ATLAS_IO_DH_t), INTENT (INOUT) :: YDDHIO
TYPE (ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS), INTENT (IN) :: YDFSSC1
CHARACTER (LEN=*),    INTENT (IN)    :: CDNAME
REAL (KIND=JPRB),     INTENT (IN), OPTIONAL :: PSCALE

TYPE (ATLAS_FIELDSET) :: YLFS
TYPE (ATLAS_FIELD) :: YLFL

! Read a field on source geometry, and insert it in the list #1

YLFS = YDDHIO%READ (CDNAME, [CDNAME], YDFSSC1, PUNDEF=ZUNDEF, PSCALE=PSCALE)

YLFL = YLFS%FIELD (1)

CALL YLFS%FINAL ()

CALL YLFL%RETURN ()

END FUNCTION

SUBROUTINE INS2 (KRANK, YDFL2, YDPT2, YDFL)

INTEGER (KIND=JPIM), INTENT (IN)    :: KRANK
TYPE (ATLAS_FIELD),  INTENT (INOUT) :: YDFL2 (:)
TYPE (PTR),          INTENT (INOUT) :: YDPT2 (:)
TYPE (ATLAS_FIELD),  INTENT (IN)    :: YDFL

! Insert a field in list #2 (target)

IF (.NOT. YDFL2 (KRANK)%IS_NULL ()) THEN
  WRITE (0, *) " KRANK = ", KRANK, " NAME = ", YDFL2 (KRANK)%NAME ()
  CALL ABORT ('FIELD ALREADY EXISTS:'//YDFL2 (KRANK)%NAME ())
ENDIF

IF (YDFL%SIZE () /= YLFSSC2%SIZE ()) CALL ABORT ('SIZE MISMATCH')
YDFL2 (KRANK) = YDFL
CALL YDFL%DATA (YDPT2 (KRANK)%ZDATA)

END SUBROUTINE

END PROGRAM

