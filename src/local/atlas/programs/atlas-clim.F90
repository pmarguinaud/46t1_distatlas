PROGRAM ATLAS_CLIM

USE PARKIND1, ONLY : JPIM, JPRB
USE ATLAS_IO_GATHSCAT, ONLY : ATLAS_IO_GATHSCAT_t
USE ATLAS_FMT_FA, ONLY : ATLAS_FMT_FA_t
USE ATLAS_FMT_FORTRAN_BINARY, ONLY : ATLAS_FMT_FORTRAN_BINARY_t
USE ATLAS_IO_DH, ONLY : ATLAS_IO_DH_t
USE FCKIT_MODULE, ONLY : FCKIT_MPI_COMM
USE INTERPOLATIONA_MOD
USE INTERPOLATION4_MOD
USE ATLAS_MODULE  
USE ATLAS_HELPER
USE ATLAS_TRACE_MODULE
USE XRD_GETOPTIONS
USE READCOVERS_MOD

!

#include "atlas-abort.h"

IMPLICIT NONE

REAL (KIND=JPRB), PARAMETER :: RPI = 2.0_JPRB * ASIN (1.0_JPRB)
REAL (KIND=JPRB), PARAMETER :: RA = 6371229._JPRB
REAL (KIND=JPRB), PARAMETER :: RG = 9.80665_JPRB
REAL (KIND=JPRB), PARAMETER :: XKARMAN = 0.4_JPRB
REAL (KIND=JPRB), PARAMETER :: XCDZ0EFF = 0.8_JPRB
REAL (KIND=JPRB), PARAMETER :: ZUNDEF = HUGE (1._JPRB)
INTEGER (KIND=JPIM), PARAMETER :: INCOVR = 256_JPIM
LOGICAL, PARAMETER :: LGARDEN = .FALSE., LWATER_TO_NATURE = .FALSE., LTOWN_TO_ROCK = .FALSE.

#include "atlas-compute-covers.h"
#include "atlas-compute-sso.h"
#include "atlas-compute-aos.h"

TYPE (ATLAS_IO_GATHSCAT_t)                :: YLFAIO
TYPE (ATLAS_FMT_FA_t),             TARGET :: YLFMFA
TYPE (ATLAS_IO_GATHSCAT_t)                :: YLFBIO
TYPE (ATLAS_FMT_FORTRAN_BINARY_t), TARGET :: YLFMFB
TYPE (ATLAS_IO_DH_t)                      :: YLDHIO
TYPE (ATLAS_STRUCTUREDGRID)               :: YLGRID1
TYPE (ATLAS_STRUCTUREDGRID)               :: YLGRID2
TYPE (ATLAS_STRUCTUREDGRID)               :: YLGRIDG
TYPE (ATLAS_TRACE)                        :: YLTRAC

! Grids of input files

TYPE (ATLAS_STRUCTUREDGRID)                  :: YLGRID_OROG
TYPE (ATLAS_STRUCTUREDGRID)                  :: YLGRID_SABL
TYPE (ATLAS_STRUCTUREDGRID)                  :: YLGRID_ARGI
TYPE (ATLAS_STRUCTUREDGRID)                  :: YLGRID_COVR

! Functionspaces

TYPE (ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS) :: YLFSSCG
TYPE (ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS) :: YLFSSC1
TYPE (ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS) :: YLFSSC2

! Distributions (of grids on MPI tasks)

TYPE (ATLAS_GRIDDISTRIBUTION)                :: YLDISTG
TYPE (ATLAS_GRIDDISTRIBUTION)                :: YLDIST1
TYPE (ATLAS_GRIDDISTRIBUTION)                :: YLDIST2

! Interpolation (source grid -> target grid)

TYPE (INTERPOLATIONA)                        :: YLINTEA

! Field sets

TYPE (ATLAS_FIELDSET)                        :: YLFLDS2

! Communicator

TYPE (FCKIT_MPI_COMM)                        :: YLCOMM

INTEGER (KIND=JPIM) :: I, JFLD
INTEGER (KIND=JPIM) :: NPROC, IRANK


! Atlas fields for target geometry

TYPE (ATLAS_FIELD), ALLOCATABLE :: YLFL2 (:)

! Pointers to access data of target fields

TYPE (PTR),         ALLOCATABLE :: YLPT2 (:)

INTEGER (KIND=JPIM) :: INFLD

TYPE (ATLAS_FIELD)    :: YLOROG1, YLARGI1, YLSABL1, YLCOVR1
TYPE (ATLAS_FIELDSET) :: YLCOVR2S, YLAOSP2S
REAL (KIND=JPRB), POINTER, DIMENSION (:) :: ZOROG1, ZARGI1, ZSABL1, ZCOVR1

! Indices of all fields

INTEGER (KIND=JPIM) :: JGEOPOTENTIEL
INTEGER (KIND=JPIM) :: JVARGEOPDIR, JSSO_SLOPE, JVARGEOPANI, JETGEOPOTENT, JZ0RELFOISG, JZ0FOISG
INTEGER (KIND=JPIM) :: JPROPURBANIS, JPROPTERRE
INTEGER (KIND=JPIM) :: JINDTERREMER, JPROPSABLE, JPROPARGILE
INTEGER (KIND=JPIM) :: Jwpl_GL, Jtpl_GL, Jsnl_GL, Jz0v_GL, Jvgx_GL, Jsab_GL, Jrsm_GL
INTEGER (KIND=JPIM) :: Jitp_GL, Jemi_GL, Jdps_GL, Jdpr_GL, Jarg_GL, Jalv_GL, Jalb_GL
INTEGER (KIND=JPIM) :: Jitp1GL, Jitp2GL, Jitp3GL, Jitp4GL, Jitp5GL
INTEGER (KIND=JPIM) :: JINDVEGDOMI, JALBEDOSOLNU, JEMISSIVITE, JEPAISOLMAX, JALBEDO
INTEGER (KIND=JPIM) :: JPROPVEGMAX, JALBEDOCOMPL, JPROPVEGETAT, JEPAISSOL

CALL INITOPTIONS ()
CALL CHECKOPTIONS ()

YLFAIO = ATLAS_IO_GATHSCAT_t (YLFMFA)
YLFBIO = ATLAS_IO_GATHSCAT_t (YLFMFB)

CALL ATLAS_LIBRARY%INITIALISE ()

YLTRAC = ATLAS_TRACE (__FILE__, __LINE__, "ATLAS_CLIM")

YLCOMM = FCKIT_MPI_COMM ()
NPROC  = YLCOMM%SIZE ()
IRANK  = YLCOMM%RANK ()

CALL LINUX_BIND (IRANK, NPROC)

YLGRID2 = GRID_FROM_NAMELIST ()

YLDHIO = ATLAS_IO_DH_t (YLGRID2)

! Create source grids & check compatibility

YLGRID_OROG = YLDHIO%GRID ("SURFGEOPOTENTIEL")
YLGRID_ARGI = YLDHIO%GRID ("SURFPROP.ARGILE" )
YLGRID_SABL = YLDHIO%GRID ("SURFPROP.SABLE"  )
YLGRID_COVR = YLDHIO%GRID ("SFX.COVER"       )

IF (.NOT. (GRID_EQ (YLGRID_OROG, YLGRID_ARGI))) CALL ABORT ("GEOMETRY MISMATCH")
IF (.NOT. (GRID_EQ (YLGRID_OROG, YLGRID_SABL))) CALL ABORT ("GEOMETRY MISMATCH")
IF (.NOT. (GRID_EQ (YLGRID_OROG, YLGRID_COVR))) CALL ABORT ("GEOMETRY MISMATCH")

YLGRID1 = YLGRID_OROG

! Not needed anymore, finalize

CALL YLGRID_OROG%FINAL ()
CALL YLGRID_ARGI%FINAL ()
CALL YLGRID_SABL%FINAL ()
CALL YLGRID_COVR%FINAL ()

! GL fields

YLGRIDG = YLFMFB%GRID ("wpl_GL")

! Create distributions for both source & target grids

CALL CREATE_DIST (YLGRID1, YLDIST1, .TRUE.)
CALL CREATE_DIST (YLGRID2, YLDIST2)
CALL CREATE_DIST (YLGRIDG, YLDISTG)

! Create functionspaces

BLOCK
  TYPE (ATLAS_CONFIG) :: YLCONF
  YLCONF = ATLAS_CONFIG ()
  CALL YLCONF%SET ("halo", 1)
  YLFSSC1 = ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS (YLGRID1, YLDIST1, YLCONF)
  YLFSSC2 = ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS (YLGRID2, YLDIST2, YLCONF)
  YLFSSCG = ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS (YLGRIDG, YLDISTG, YLCONF)
  CALL YLCONF%FINAL ()
ENDBLOCK

! Define indices for all fields

INFLD = 0

#define ADDFLD(J) INFLD = INFLD + 1; J = INFLD

ADDFLD (JGEOPOTENTIEL); ADDFLD (JPROPSABLE  ); ADDFLD (JPROPARGILE ); 
ADDFLD (JVARGEOPDIR  ); ADDFLD (JSSO_SLOPE  ); ADDFLD (JVARGEOPANI ); ADDFLD (JETGEOPOTENT); 
ADDFLD (JINDTERREMER ); ADDFLD (JPROPURBANIS); ADDFLD (JPROPTERRE  ); ADDFLD (JZ0RELFOISG );
ADDFLD (JZ0FOISG     );
ADDFLD (Jwpl_GL      ); ADDFLD (Jtpl_GL     ); ADDFLD (Jsnl_GL     ); ADDFLD (Jz0v_GL     ); 
ADDFLD (Jvgx_GL      ); ADDFLD (Jsab_GL     ); ADDFLD (Jrsm_GL     ); ADDFLD (Jitp_GL     ); 
ADDFLD (Jemi_GL      ); ADDFLD (Jdps_GL     ); ADDFLD (Jdpr_GL     ); ADDFLD (Jarg_GL     ); 
ADDFLD (Jalv_GL      ); ADDFLD (Jalb_GL     );
ADDFLD (Jitp1GL      ); ADDFLD (Jitp2GL     ); ADDFLD (Jitp3GL     ); ADDFLD (Jitp4GL     ); 
ADDFLD (Jitp5GL      ); ADDFLD (JINDVEGDOMI ); ADDFLD (JALBEDOSOLNU); ADDFLD (JEMISSIVITE );
ADDFLD (JEPAISOLMAX  ); ADDFLD (JALBEDO     ); ADDFLD (JPROPVEGMAX ); ADDFLD (JALBEDOCOMPL);
ADDFLD (JEPAISSOL    ); ADDFLD (JPROPVEGETAT);

#undef ADDFLD

! Allocate fields & pointers

ALLOCATE (YLFL2 (INFLD), YLPT2 (INFLD))

YLFLDS2 = ATLAS_FIELDSET ()




! Create interpolation object (source -> target)

YLINTEA = INTERPOLATIONA (YLDIST1, YLFSSC1, YLDIST2, YLFSSC2, LDOPENMP=.TRUE.)

! Read input fields on source geometry

YLOROG1 = RNS1 ("SURFGEOPOTENTIEL", PSCALE=RG); CALL YLOROG1%DATA (ZOROG1)
YLARGI1 = RNS1 ("SURFPROP.ARGILE"            ); CALL YLARGI1%DATA (ZARGI1)
YLSABL1 = RNS1 ("SURFPROP.SABLE"             ); CALL YLSABL1%DATA (ZSABL1)
YLCOVR1 = RNS1 ("SFX.COVER"                  ); CALL YLCOVR1%DATA (ZCOVR1)

YLCOVR2S = ATLAS_COMPUTE_COVERS (YLFSSC1, YLFSSC2, YLCOVR1, YLINTEA, LDOPENMP=.TRUE.) 

! Set missing values of orography

!$OMP WORKSHARE
WHERE (ZCOVR1 == 1._JPRB) ! Sea 
  ZOROG1 = ZUNDEF
ENDWHERE
!$OMP END WORKSHARE

CALL INS2 (JINDTERREMER, NEWFLD (YLFSSC2, "SURFIND.TERREMER"))

BLOCK
  TYPE (ATLAS_FIELD) :: YLCOVR2
  REAL (KIND=JPRB), POINTER :: ZCOVR2 (:)

  YLCOVR2 = YLCOVR2S%FIELD ("COVER001")
  CALL YLCOVR2%DATA (ZCOVR2)

!$OMP WORKSHARE
  WHERE (ZCOVR2 > 0.5_JPRB)
    YLPT2 (JINDTERREMER)%ZDATA = 0._JPRB
  ELSE WHERE
    YLPT2 (JINDTERREMER)%ZDATA = 1._JPRB
  END WHERE
!$OMP END WORKSHARE

  CALL YLCOVR2%FINAL ()

ENDBLOCK

! Interpolate fields using box averaging

BLOCK
  TYPE (ATLAS_FIELDSET) :: YLFLDS1
  TYPE (ATLAS_FIELDSET) :: YLFLDS2I

  YLFLDS1 = ATLAS_FIELDSET ()

  CALL YLFLDS1%ADD (YLOROG1)
  CALL YLFLDS1%ADD (YLARGI1)
  CALL YLFLDS1%ADD (YLSABL1)
  YLFLDS2I = YLINTEA%INTERPOLATE (YLFLDS1)
  CALL YLFLDS1%FINAL ()

! Insert interpolated fields in the list of fields of target geometry

  CALL INS2 (JGEOPOTENTIEL, YLFLDS2I%FIELD ("SURFGEOPOTENTIEL"))
  CALL INS2 (JPROPSABLE   , YLFLDS2I%FIELD ("SURFPROP.SABLE"  ))
  CALL INS2 (JPROPARGILE  , YLFLDS2I%FIELD ("SURFPROP.ARGILE" ))

  CALL YLFLDS2I%FINAL ()
ENDBLOCK

BLOCK
  TYPE (ATLAS_FIELDSET) :: YLFLDS2SSO
  TYPE (ATLAS_FIELD)    :: YLFLD2

  YLFLDS2SSO = ATLAS_COMPUTE_SSO (YLFSSC1, YLFSSC2, YLOROG1, YLFL2 (JGEOPOTENTIEL), YLINTEA, LDOPENMP=.TRUE., LDROTATE=.TRUE.) 

  YLFLD2 = YLFLDS2SSO%FIELD ("SSO_DIR"  ); CALL YLFLD2%RENAME ("SURFVAR.GEOP.DIR"); CALL INS2 (JVARGEOPDIR , YLFLD2)
  YLFLD2 = YLFLDS2SSO%FIELD ("SSO_ANIS" ); CALL YLFLD2%RENAME ("SURFVAR.GEOP.ANI"); CALL INS2 (JVARGEOPANI , YLFLD2)
  YLFLD2 = YLFLDS2SSO%FIELD ("SSO_STDEV"); CALL YLFLD2%RENAME ("SURFET.GEOPOTENT"); CALL INS2 (JETGEOPOTENT, YLFLD2)


!$OMP WORKSHARE
  WHERE (YLPT2 (JVARGEOPANI)%ZDATA /= ZUNDEF)
    YLPT2 (JVARGEOPANI)%ZDATA (:) = YLPT2 (JVARGEOPANI)%ZDATA (:) ** 2
  END WHERE
!$OMP END WORKSHARE

!$OMP WORKSHARE
  WHERE (YLPT2 (JVARGEOPDIR)%ZDATA /= ZUNDEF)
    YLPT2 (JVARGEOPDIR)%ZDATA (:) = YLPT2 (JVARGEOPDIR)%ZDATA (:) * RPI / 180._JPRB
  END WHERE
!$OMP END WORKSHARE

ENDBLOCK

! Add enveloppe

!$OMP WORKSHARE 
  WHERE (YLPT2 (JGEOPOTENTIEL)%ZDATA (:) /= ZUNDEF)
    YLPT2 (JGEOPOTENTIEL)%ZDATA (:) = YLPT2 (JGEOPOTENTIEL)%ZDATA (:) + YLPT2 (JETGEOPOTENT)%ZDATA
  ENDWHERE
!$OMP END WORKSHARE

BLOCK
  TYPE (INTERPOLATION4) :: YLINTE4
  REAL (KIND=JPRB) :: ZLOC2 (YLFSSC2%SIZE ())
  REAL (KIND=JPRB), POINTER, DIMENSION (:) :: ZAOSIP2, ZAOSIM2, ZAOSJP2, ZAOSJM2, &
                                            & ZHO2IP2, ZHO2IM2, ZHO2JP2, ZHO2JM2
  TYPE (ATLAS_FIELD) :: YLFLD2

  YLINTE4 = INTERPOLATION4 (YLDIST2, YLFSSC2, YLDIST1, YLFSSC1)
  YLAOSP2S = ATLAS_COMPUTE_AOS (YLFSSC1, YLFSSC2, YLOROG1, YLFL2 (JGEOPOTENTIEL), YLINTEA, YLINTE4, LDOPENMP=.TRUE.) 

#define GF(n, z) YLFLD2 = YLAOSP2S%FIELD (#n); CALL YLFLD2%DATA (z); CALL YLFLD2%FINAL ()
  GF (AOSIP, ZAOSIP2)
  GF (AOSIM, ZAOSIM2)
  GF (AOSJP, ZAOSJP2)
  GF (AOSJM, ZAOSJM2)
  GF (HO2IP, ZHO2IP2)
  GF (HO2IM, ZHO2IM2)
  GF (HO2JP, ZHO2JP2)
  GF (HO2JM, ZHO2JM2)
#undef GF

  CALL INS2 (JZ0RELFOISG, NEWFLD (YLFSSC2, "SURFZ0REL.FOIS.G" ))
  CALL INS2 (JZ0FOISG,    NEWFLD (YLFSSC2, "SURFZ0.FOIS.G"    ))

  WHERE (YLPT2 (JGEOPOTENTIEL)%ZDATA /= ZUNDEF)
    ZLOC2 (:) = 0.25_JPRB * XCDZ0EFF / (2._JPRB * XKARMAN**2) &
            & * (ZAOSIP2 (:) + ZAOSIM2 (:) + ZAOSJP2 (:) + ZAOSJM2 (:))        
    WHERE (ZLOC2 (:) > 0._JPRB)
      YLPT2 (JZ0RELFOISG)%ZDATA = 0.25_JPRB * (ZHO2IP2 (:) + ZHO2IM2 (:) + ZHO2JP2 (:) + ZHO2JM2 (:)) &
                              & * EXP (-SQRT (1._JPRB / ZLOC2 (:)))
      YLPT2 (JZ0RELFOISG)%ZDATA = MAX (YLPT2 (JZ0RELFOISG)%ZDATA (:), 1E-10_JPRB)
    ELSEWHERE
      YLPT2 (JZ0RELFOISG)%ZDATA = 0._JPRB
    END WHERE
  ELSE WHERE
    YLPT2 (JZ0RELFOISG)%ZDATA = ZUNDEF
  END WHERE

  YLPT2 (JZ0FOISG)%ZDATA = YLPT2 (JZ0RELFOISG)%ZDATA

  CALL YLINTE4%FINAL ()
ENDBLOCK

CALL COMPUTE_FRACTIONS

! Fix missing values: orography parameters, set to zero

BLOCK
  INTEGER (KIND=JPIM) :: IZS (6)
  IZS = [JGEOPOTENTIEL,  JVARGEOPDIR, JVARGEOPANI,  JETGEOPOTENT, JZ0RELFOISG, JZ0FOISG]

  DO JFLD = 1, SIZE (IZS)
!$OMP WORKSHARE 
    WHERE (YLPT2 (IZS (JFLD))%ZDATA == ZUNDEF)
      YLPT2 (IZS (JFLD))%ZDATA = 0._JPRB
    ENDWHERE
!$OMP END WORKSHARE
  ENDDO

ENDBLOCK

! Fix missing values : clay & sand

!$OMP WORKSHARE
WHERE (YLPT2 (JPROPSABLE)%ZDATA == ZUNDEF)
  YLPT2 (JPROPSABLE)%ZDATA = 0._JPRB
END WHERE
!$OMP END WORKSHARE
!$OMP WORKSHARE
WHERE (YLPT2 (JPROPARGILE)%ZDATA == ZUNDEF)
  YLPT2 (JPROPARGILE)%ZDATA = 0._JPRB
END WHERE
!$OMP END WORKSHARE


BLOCK
  TYPE (INTERPOLATION4) :: YLINTEG
  TYPE (ATLAS_FIELDSET) :: YLFSG1, YLFSG2
  TYPE (ATLAS_FIELD) :: YLF
 
  INTEGER (KIND=JPIM) :: IDNAMG (14), IDITP (5)
  CHARACTER (LEN=16) :: CLNAMG (14)
  INTEGER (KIND=JPIM) :: JFLD
  INTEGER (KIND=JPIM), PARAMETER :: NTPLAC = 5, NTPMER = 1, NTPGLA = 2, NTPDES = 3
  TYPE (PTR) :: YLITP (5)

  IDNAMG = [Jwpl_GL           , Jtpl_GL           , Jsnl_GL           , Jz0v_GL           , &
         &  Jvgx_GL           , Jsab_GL           , Jrsm_GL           , Jitp_GL           , &
         &  Jemi_GL           , Jdps_GL           , Jdpr_GL           , Jarg_GL           , &
         &  Jalv_GL           , Jalb_GL           ]

  CLNAMG = ['wpl_GL          ', 'tpl_GL          ', 'snl_GL          ', 'z0v_GL          ', &
         &  'vgx_GL          ', 'sab_GL          ', 'rsm_GL          ', 'itp_GL          ', &
         &  'emi_GL          ', 'dps_GL          ', 'dpr_GL          ', 'arg_GL          ', &
         &  'alv_GL          ', 'alb_GL          ']

  YLINTEG = INTERPOLATION4 (YLDISTG, YLFSSCG, YLDIST2, YLFSSC2)

  YLFSG1 = YLFBIO%READ ('', CLNAMG, YLFSSCG, PUNDEF=ZUNDEF)

  ! Create fields of density for each type

  DO JFLD = 1, 5
    BLOCK
      TYPE (ATLAS_FIELD) :: YLF
      CHARACTER (LEN=16) :: CLNAME
      WRITE (CLNAME, '("itp_GL.",I3.3)') JFLD
      YLF = NEWFLD (YLFSSCG, CLNAME, ZUNDEF)
      CALL YLFSG1%ADD (YLF)
      CALL YLF%DATA (YLITP (JFLD)%ZDATA)
      YLITP (JFLD)%ZDATA = 0._JPRB
      CALL YLF%FINAL ()
    ENDBLOCK
  ENDDO

  BLOCK
    TYPE (ATLAS_FIELD) :: YLITP1
    REAL (KIND=JPRB), POINTER :: ZITP1 (:)
    INTEGER (KIND=JPIM) :: JLOC1, JTYP1
    YLITP1 = YLFSG1%FIELD ('itp_GL')
    CALL YLITP1%DATA (ZITP1)
    DO JLOC1 = 1, YLFSSCG%SIZE_OWNED ()
      JTYP1 = NINT (ZITP1 (JLOC1))
      IF ((JTYP1 < 1) .OR. (5 < JTYP1)) THEN
        WRITE (0, *) 'ATLAS_CLIM: UNEXPECTED VALUE FOR itp_GL: ', JLOC1, JTYP1, ZITP1 (JLOC1)
        CALL ABORT ('ATLAS_CLIM: UNEXPECTED VALUE FOR itp_GL')
      ENDIF
      YLITP (JTYP1)%ZDATA (JLOC1) = 1._JPRB
    ENDDO
    CALL YLITP1%FINAL ()
  ENDBLOCK

  YLFSG2 = YLINTEG%INTERPOLATE (YLFSG1)

  ! Add to final list

  DO JFLD = 1, SIZE (CLNAMG)
    YLF = YLFSG2%FIELD (TRIM (CLNAMG (JFLD)))
    CALL YLF%RENAME ('SURF.'//TRIM (CLNAMG (JFLD)))
    CALL INS2 (IDNAMG (JFLD), YLF)
    CALL YLF%FINAL ()
  ENDDO

  IDITP = [Jitp1GL, Jitp2GL, Jitp3GL, Jitp4GL, Jitp5GL]

  DO JFLD = 1, 5
    BLOCK
      TYPE (ATLAS_FIELD) :: YLF
      CHARACTER (LEN=16) :: CLNAME
      WRITE (CLNAME, '("itp_GL.",I3.3)') JFLD
      YLF = YLFSG2%FIELD (TRIM (CLNAME))
      CALL YLF%RENAME ("SURF."//TRIM (CLNAME))
      CALL INS2 (IDITP (JFLD), YLF)
      CALL YLF%FINAL ()
    ENDBLOCK
  ENDDO

  YLF = YLFSG2%FIELD ('alb_GL'); CALL YLF%RENAME ('SURFALBEDO.SOLNU'); CALL INS2 (JALBEDOSOLNU, YLF); CALL YLF%FINAL ()
  YLF = YLFSG2%FIELD ('emi_GL'); CALL YLF%RENAME ('SURFEMISSIVITE'  ); CALL INS2 (JEMISSIVITE , YLF); CALL YLF%FINAL ()
  YLF = YLFSG2%FIELD ('dps_GL'); CALL YLF%RENAME ('SURFEPAI.SOL.MAX'); CALL INS2 (JEPAISOLMAX , YLF); CALL YLF%FINAL ()

  ! Find vegetation dominant index

  CALL INS2 (JINDVEGDOMI, NEWFLD (YLFSSC2, 'SURFIND.VEG.DOMI'))

  BLOCK
    REAL (KIND=JPRB) :: IVS, IVD, ZITP
    REAL (KIND=JPRB) :: ZMAX1, ZMAX2
    INTEGER (KIND=JPIM) :: JLOC2, JT, ILSM

    DO JLOC2 = 1, YLFSSC2%SIZE_OWNED ()

      ZMAX1 = 0.0_JPRB; ZMAX2 = 0.0_JPRB
      IVD   = 0_JPIM  ; IVS   = 0_JPIM

      DO JT = 1, 5
        ZITP = YLPT2 (IDITP (JT))%ZDATA (JLOC2)
        IF (ZITP > ZMAX1) THEN
          ZMAX1 = ZITP
          IVD = JT
        ENDIF
      ENDDO
      DO JT = 1, 5
        IF (JT == IVD) CYCLE
        ZITP = YLPT2 (IDITP (JT))%ZDATA (JLOC2)
        IF (ZITP > ZMAX2) THEN
          ZMAX2 = ZITP
          IVS = JT
        ENDIF
      ENDDO

      ILSM = NINT (YLPT2 (JINDTERREMER)%ZDATA (JLOC2))

      IF (ILSM == 0 .AND. IVD /= NTPLAC) IVD = NTPMER
      IF ((IVD == NTPMER .OR. IVD == NTPLAC) .AND. (ILSM == 1)) THEN
        IF (IVS == 0) THEN
          IVD = NTPDES
        ELSE
          IVD = IVS
        ENDIF
      ENDIF

      YLPT2 (JINDVEGDOMI)%ZDATA (JLOC2) = REAL (IVD, JPRB)

    ENDDO
  ENDBLOCK

  CALL INS2 (JEPAISSOL,    NEWFLD (YLFSSC2, 'SURFEPAIS.SOL'   ))
  CALL INS2 (JPROPVEGMAX,  NEWFLD (YLFSSC2, 'SURFPROP.VEG.MAX'))
  CALL INS2 (JPROPVEGETAT, NEWFLD (YLFSSC2, 'SURFPROP.VEGETAT'))

  BLOCK
    INTEGER (KIND=JPIM) :: JLOC2
    TYPE (ATLAS_FIELD) :: YLVGX, YLDPR
    REAL (KIND=JPRB), POINTER :: ZVGX (:), ZDPR (:)
    REAL (KIND=JPRB) :: ZV, ZD, ZEPAISOLMAX
    REAL (KIND=JPRB), PARAMETER :: SVEG = 0.02_JPRB
    YLVGX = YLFSG2%FIELD ('vgx_GL'); CALL YLVGX%DATA (ZVGX)
    YLDPR = YLFSG2%FIELD ('dpr_GL'); CALL YLDPR%DATA (ZDPR)
    DO JLOC2 = 1, YLFSSC2%SIZE_OWNED ()
      ZV = ZVGX (JLOC2)
      ZD = ZDPR (JLOC2)
      ZV = MAX (0.0_JPRB, MIN (1.0_JPRB, ZV))
      IF (ZV < SVEG) ZV = 0.0_JPRB
      ZEPAISOLMAX = YLPT2 (JEPAISOLMAX)%ZDATA (JLOC2)
      YLPT2 (JEPAISSOL   )%ZDATA (JLOC2) = ZV * MIN (ZD, ZEPAISOLMAX) &
                                         & + (1.0_JPRB - ZV) * ZEPAISOLMAX 
      YLPT2 (JPROPVEGMAX )%ZDATA (JLOC2) = ZV
      YLPT2 (JPROPVEGETAT)%ZDATA (JLOC2) = ZV
    ENDDO
    CALL YLVGX%FINAL ()
    CALL YLDPR%FINAL ()
  ENDBLOCK  

  ! Final calculations

  BLOCK
    INTEGER (KIND=JPIM) :: JLOC2
    INTEGER (KIND=JPIM) :: IV

    REAL (KIND=JPRB), PARAMETER :: SALBG =  0.75_JPRB, SALBM =  0.07_JPRB, SARGN =  3.00_JPRB, &
                                 & SDEPN =  0.10_JPRB, SDEPX =  8.00_JPRB, SEMIG =  0.98_JPRB, &
                                 & SEMIN =  0.90_JPRB, SSABN =  6.00_JPRB, SARGX = 58.00_JPRB, &
                                 & SALBN =  0.05_JPRB, SALBX =  0.80_JPRB, SEMIX =  1.00_JPRB, &
                                 & SEMIM =  0.96_JPRB, SSABX = 92.00_JPRB

    DO JLOC2 = 1, YLFSSC2%SIZE_OWNED ()
      IV = NINT (YLPT2 (JINDVEGDOMI)%ZDATA (JLOC2))
      IF (IV < 1 .OR. IV > 5) THEN
        WRITE (0, *) 'UNEXPECTED VEGETATION INDEX', JLOC2, IV
        CALL ABORT ('UNEXPECTED VEGETATION INDEX')
      ENDIF
      SELECT CASE (IV)
        CASE (NTPMER, NTPLAC)

          YLPT2 (JALBEDOSOLNU)%ZDATA (JLOC2) = SALBM
          YLPT2 (JEMISSIVITE )%ZDATA (JLOC2) = SEMIM
          YLPT2 (JEPAISOLMAX )%ZDATA (JLOC2) = SDEPX
          YLPT2 (JPROPARGILE )%ZDATA (JLOC2) = SARGN
          YLPT2 (JPROPSABLE  )%ZDATA (JLOC2) = SSABN
          YLPT2 (JPROPVEGMAX )%ZDATA (JLOC2) = 0.0_JPRB
          YLPT2 (JEPAISSOL   )%ZDATA (JLOC2) = SDEPX
          YLPT2 (JPROPURBANIS)%ZDATA (JLOC2) = 0.0_JPRB

        CASE (NTPGLA) 
        
          YLPT2 (JALBEDOSOLNU)%ZDATA (JLOC2) = SALBG
          YLPT2 (JEMISSIVITE )%ZDATA (JLOC2) = SEMIG
          YLPT2 (JEPAISOLMAX )%ZDATA (JLOC2) = SDEPN
          YLPT2 (JPROPARGILE )%ZDATA (JLOC2) = SARGN
          YLPT2 (JPROPSABLE  )%ZDATA (JLOC2) = SSABN
          YLPT2 (JPROPVEGMAX )%ZDATA (JLOC2) = 0.0_JPRB
          YLPT2 (JEPAISSOL   )%ZDATA (JLOC2) = SDEPN
          YLPT2 (JPROPURBANIS)%ZDATA (JLOC2) = 0.0_JPRB

        CASE DEFAULT

          BLOCK
            REAL (KIND=JPRB) :: ZZARG, ZZSAB, ZSUM

            ZZARG = MAX (SARGN, MIN (SARGX, YLPT2 (JPROPARGILE )%ZDATA (JLOC2)))
            ZZSAB = MAX (SSABN, MIN (SSABX, YLPT2 (JPROPSABLE  )%ZDATA (JLOC2)))
            ZSUM  = MAX (100._JPRB, ZZARG + ZZSAB) / 100._JPRB

            YLPT2 (JALBEDOSOLNU)%ZDATA (JLOC2) = MAX (SALBN,MIN (SALBX, YLPT2 (JALBEDOSOLNU)%ZDATA (JLOC2)))
            YLPT2 (JEMISSIVITE )%ZDATA (JLOC2) = MAX (SEMIN,MIN (SEMIX, YLPT2 (JEMISSIVITE )%ZDATA (JLOC2)))
            YLPT2 (JEPAISOLMAX )%ZDATA (JLOC2) = MAX (SDEPN,MIN (SDEPX, YLPT2 (JEPAISOLMAX )%ZDATA (JLOC2)))
            YLPT2 (JPROPARGILE )%ZDATA (JLOC2) = ZZARG / ZSUM
            YLPT2 (JPROPSABLE  )%ZDATA (JLOC2) = ZZSAB / ZSUM
            YLPT2 (JPROPVEGMAX )%ZDATA (JLOC2) = YLPT2 (JPROPVEGMAX)%ZDATA (JLOC2) * YLPT2 (JPROPTERRE)%ZDATA (JLOC2)
            YLPT2 (JEPAISSOL   )%ZDATA (JLOC2) = MAX (SDEPN, MIN (YLPT2 (JEPAISOLMAX )%ZDATA (JLOC2), YLPT2 (JEPAISSOL   )%ZDATA (JLOC2)))
            YLPT2 (JPROPURBANIS)%ZDATA (JLOC2) = MIN (1.0_JPRB - YLPT2 (JPROPVEGMAX )%ZDATA (JLOC2), YLPT2 (JPROPURBANIS)%ZDATA (JLOC2))
          ENDBLOCK

      END SELECT
    ENDDO
  ENDBLOCK

  ! Other albedo fields
  CALL INS2 (JALBEDO     , NEWFLD (YLFSSC2, 'SURFALBEDO'      ))
  CALL INS2 (JALBEDOCOMPL, NEWFLD (YLFSSC2, 'SURFALBEDO.COMPL'))

!$OMP WORKSHARE
  YLPT2 (JALBEDO     )%ZDATA = YLPT2 (JALBEDOSOLNU)%ZDATA
!$OMP END WORKSHARE
!$OMP WORKSHARE
  YLPT2 (JALBEDOCOMPL)%ZDATA = YLPT2 (JALBEDOSOLNU)%ZDATA
!$OMP END WORKSHARE


  CALL YLFSG1 %FINAL ()
  CALL YLFSG2 %FINAL ()
  CALL YLINTEG%FINAL ()
ENDBLOCK

CALL YLFAIO%WRITE ('Const.Clim', YLFLDS2, YLFSSC2)

DO JFLD = 1, INFLD
  CALL YLFL2 (JFLD)%FINAL ()
ENDDO

CALL YLCOVR2S%FINAL ()
CALL YLAOSP2S%FINAL ()
CALL YLOROG1%FINAL ()
CALL YLARGI1%FINAL ()
CALL YLSABL1%FINAL ()
CALL YLCOVR1%FINAL ()
CALL YLFLDS2%FINAL ()
CALL YLINTEA%FINAL ()
CALL YLGRID1%FINAL ()
CALL YLDIST1%FINAL ()
CALL YLDIST2%FINAL ()
CALL YLFSSC1%FINAL ()
CALL YLFSSC2%FINAL ()



CALL YLTRAC%FINAL ()

CALL ATLAS_LIBRARY%FINALISE()

WRITE (*, *) "--- STOP ---"

CONTAINS

SUBROUTINE COMPUTE_FRACTIONS

TYPE (ATLAS_FIELD) :: YLFL2 (INCOVR)
REAL (KIND=JPRB) :: ZFRAC_MER (YLFSSC2%SIZE ()), ZFRAC_EAU (YLFSSC2%SIZE ())
TYPE (COVERS_t) :: YLCOVERS
LOGICAL, ALLOCATABLE :: LCOVER (:)
INTEGER (KIND=JPIM) :: ICOVR

REAL (KIND=JPRB) :: ZAVGCOVR2 (INCOVR)
REAL (KIND=JPRB) :: ZMINCOVR2 (INCOVR)
REAL (KIND=JPRB) :: ZMAXCOVR2 (INCOVR)

DO ICOVR = 1, INCOVR
  YLFL2 (ICOVR) = YLCOVR2S%FIELD (ICOVR)
ENDDO

! Create fractions fields

CALL INS2 (JPROPURBANIS, NEWFLD (YLFSSC2, "SURFPROP.URBANIS" ))
CALL INS2 (JPROPTERRE,   NEWFLD (YLFSSC2, "SURFPROP.TERRE"   ))

CALL READCOVERS (YLCOVERS, 1, LGARDEN, LWATER_TO_NATURE, LTOWN_TO_ROCK)
CALL FIELDSTAT (YLFSSC2, YLFL2, PMIN=ZMINCOVR2, PMAX=ZMAXCOVR2, PAVG=ZAVGCOVR2)

ALLOCATE (LCOVER (YLCOVERS%JPCOVER))
LCOVER = .FALSE.

LCOVER = ZAVGCOVR2 > 0._JPRB

CALL MAKEFRAC (ZFRAC_MER                 , YLFL2, YLCOVERS%XDATA_SEA  , LCOVER)
CALL MAKEFRAC (ZFRAC_EAU                 , YLFL2, YLCOVERS%XDATA_WATER, LCOVER)
CALL MAKEFRAC (YLPT2 (JPROPURBANIS)%ZDATA, YLFL2, YLCOVERS%XDATA_TOWN , LCOVER)

!$OMP WORKSHARE
  YLPT2 (JPROPTERRE)%ZDATA = 1._JPRB - (ZFRAC_MER + ZFRAC_EAU)
!$OMP END WORKSHARE

!$OMP WORKSHARE
WHERE (ZFRAC_EAU > 0.5_JPRB)
  YLPT2 (JINDTERREMER)%ZDATA = 0._JPRB
ENDWHERE
!$OMP END WORKSHARE

END SUBROUTINE

SUBROUTINE MAKEFRAC (PFRAC, YDCOVER, PDATA, LDCOVER)

REAL (KIND=JPRB),   INTENT (OUT) :: PFRAC (:)
TYPE (ATLAS_FIELD), INTENT (IN)  :: YDCOVER (:)
REAL (KIND=JPRB),   INTENT (IN)  :: PDATA (:)
LOGICAL,            INTENT (IN)  :: LDCOVER (:)

TYPE (PTR) :: YLPTR (SIZE (YDCOVER))

INTEGER (KIND=JPIM) :: JLOC, JCOV, INCOV
REAL (KIND=JPRB) :: ZSUM

INCOV = SIZE (YDCOVER)

DO JCOV = 1, INCOV
  CALL YDCOVER (JCOV)%DATA (YLPTR (JCOV)%ZDATA)
ENDDO

! 1D computation

!$OMP PARALLEL DO PRIVATE (JLOC, ZSUM, JCOV) 
DO JLOC = 1, SIZE (PFRAC)
  PFRAC (JLOC) = 0._JPRB
  ZSUM = 0._JPRB
  DO JCOV = 1, INCOV
    IF (LDCOVER (JCOV)) THEN
      PFRAC (JLOC) = PFRAC (JLOC) + YLPTR (JCOV)%ZDATA (JLOC) * PDATA (JCOV)
      ZSUM         = ZSUM + YLPTR (JCOV)%ZDATA (JLOC)
    ENDIF
  ENDDO
  PFRAC (JLOC) = PFRAC (JLOC) / ZSUM
ENDDO
!$OMP END PARALLEL DO

END SUBROUTINE

FUNCTION RNS1 (CDNAME, PSCALE) RESULT (YLFL)

CHARACTER (LEN=*),   INTENT (IN) :: CDNAME
REAL (KIND=JPRB),    INTENT (IN), OPTIONAL :: PSCALE

TYPE (ATLAS_FIELDSET) :: YLFS
TYPE (ATLAS_FIELD) :: YLFL

! Read a field on source geometry, and insert it in the list #1

YLFS = YLDHIO%READ (CDNAME, [CDNAME], YLFSSC1, PUNDEF=ZUNDEF, PSCALE=PSCALE)

YLFL = YLFS%FIELD (1)

CALL YLFS%FINAL ()

CALL YLFL%RETURN ()

END FUNCTION

SUBROUTINE INS2 (KRANK, YDFL)

INTEGER (KIND=JPIM), INTENT (IN) :: KRANK
TYPE (ATLAS_FIELD),  INTENT (IN) :: YDFL

! Insert a field in list #2 (target)

IF (.NOT. YLFL2 (KRANK)%IS_NULL ()) CALL ABORT ('FIELD ALREADY EXISTS')
IF (YDFL%SIZE () /= YLFSSC2%SIZE ()) CALL ABORT ('SIZE MISMATCH')
YLFL2 (KRANK) = YDFL
CALL YDFL%DATA (YLPT2 (KRANK)%ZDATA)
CALL YLFLDS2%ADD (YDFL)

END SUBROUTINE

END PROGRAM

