PROGRAM ATLAS_CLIM

USE PARKIND1, ONLY : JPIM, JPRB
USE ATLAS_FA, ONLY : ATLAS_FA_t
USE ATLAS_DH, ONLY : ATLAS_DH_t
USE FCKIT_MODULE, ONLY : FCKIT_MPI_COMM
USE INTERPOLATIONA_MOD
USE INTERPOLATION4_MOD
USE ATLAS_MODULE  
USE ATLAS_HELPER
USE ATLAS_TRACE_MODULE
USE XRD_GETOPTIONS
USE READCOVERS_MOD

!

#include "atlas-abort.h"

IMPLICIT NONE

REAL (KIND=JPRB), PARAMETER :: RPI = 2.0_JPRB * ASIN (1.0_JPRB)
REAL (KIND=JPRB), PARAMETER :: RA = 6371229._JPRB
REAL (KIND=JPRB), PARAMETER :: ZUNDEF = HUGE (1._JPRB)
INTEGER (KIND=JPIM), PARAMETER :: INCOVR = 256_JPIM
LOGICAL, PARAMETER :: LGARDEN = .FALSE., LWATER_TO_NATURE = .FALSE., LTOWN_TO_ROCK = .TRUE.

#include "atlas-compute-covers.h"
#include "atlas-compute-sso.h"
#include "atlas-compute-aos.h"

TYPE (ATLAS_FA_t)              :: YLFAIO
TYPE (ATLAS_DH_t)              :: YLDHIO
TYPE (ATLAS_STRUCTUREDGRID)    :: YLGRID1
TYPE (ATLAS_STRUCTUREDGRID)    :: YLGRID2
TYPE (ATLAS_TRACE)             :: YLTRAC
! Grids of input files

TYPE (ATLAS_STRUCTUREDGRID)                  :: YLGRID_OROG
TYPE (ATLAS_STRUCTUREDGRID)                  :: YLGRID_SAND
TYPE (ATLAS_STRUCTUREDGRID)                  :: YLGRID_CLAY
TYPE (ATLAS_STRUCTUREDGRID)                  :: YLGRID_COVR

! Functionspaces

TYPE (ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS) :: YLFSSC1
TYPE (ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS) :: YLFSSC2

! Distributions (of grids on MPI tasks)

TYPE (ATLAS_GRIDDISTRIBUTION)                :: YLDIST1
TYPE (ATLAS_GRIDDISTRIBUTION)                :: YLDIST2

! Interpolation (source grid -> target grid)

TYPE (INTERPOLATIONA)                        :: YLINTEA

! Field sets

TYPE (ATLAS_FIELDSET)                        :: YLFLDS1  
TYPE (ATLAS_FIELDSET)                        :: YLFLDS2
TYPE (ATLAS_FIELDSET)                        :: YLFLDS2I

! Communicator

TYPE (FCKIT_MPI_COMM)                        :: YLCOMM

INTEGER (KIND=JPIM) :: I, JFLD
INTEGER (KIND=JPIM) :: NPROC, IRANK


! Atlas fields for target geometry

TYPE (ATLAS_FIELD), ALLOCATABLE :: YLFL2 (:)

! Pointers to access data of target fields

TYPE (PTR),         ALLOCATABLE :: YLPT2 (:)

INTEGER (KIND=JPIM) :: INFLD

TYPE (ATLAS_FIELD) :: YLOROG1, YLCLAY1, YLSAND1, YLCOVR1
REAL (KIND=JPRB), POINTER, DIMENSION (:) :: ZOROG1, ZCLAY1, ZSAND1, ZCOVR1

! Indices of all fields

INTEGER (KIND=JPIM) :: JZS, JSAND, JCLAY
INTEGER (KIND=JPIM) :: JMIN_ZS, JMAX_ZS, JAVG_ZS, JSIL_ZS
INTEGER (KIND=JPIM) :: JSSO_DIR, JSSO_SLOPE, JSSO_ANIS, JSSO_STDEV
INTEGER (KIND=JPIM) :: JAOSIP, JAOSIM, JAOSJP, JAOSJM, JHO2IP, JHO2IM, JHO2JP, JHO2JM
INTEGER (KIND=JPIM) :: JFRAC_SEA, JFRAC_WATER, JFRAC_NATURE, JFRAC_TOWN
INTEGER (KIND=JPIM) :: JBATHY, JRUNOFFB, JWDRAIN, JCOVER


CALL INITOPTIONS ()
CALL CHECKOPTIONS ()

CALL ATLAS_LIBRARY%INITIALISE ()

YLTRAC = ATLAS_TRACE (__FILE__, __LINE__, "ATLAS_CLIM")

YLCOMM = FCKIT_MPI_COMM ()
NPROC  = YLCOMM%SIZE ()
IRANK  = YLCOMM%RANK ()

CALL LINUX_BIND (IRANK, NPROC)

YLGRID2 = GRID_FROM_NAMELIST ()

YLDHIO = ATLAS_DH_t (YLGRID2)

! Create source grids & check compatibility

YLGRID_OROG = YLDHIO%GRID ("SFX.ZS"   )
YLGRID_CLAY = YLDHIO%GRID ("SFX.CLAY" )
YLGRID_SAND = YLDHIO%GRID ("SFX.SAND" )
YLGRID_COVR = YLDHIO%GRID ("SFX.COVER")

IF (.NOT. (GRID_EQ (YLGRID_OROG, YLGRID_CLAY))) CALL ABORT ("GEOMETRY MISMATCH")
IF (.NOT. (GRID_EQ (YLGRID_OROG, YLGRID_SAND))) CALL ABORT ("GEOMETRY MISMATCH")
IF (.NOT. (GRID_EQ (YLGRID_OROG, YLGRID_COVR))) CALL ABORT ("GEOMETRY MISMATCH")

YLGRID1 = YLGRID_OROG

! Not needed anymore, finalize

CALL YLGRID_OROG%FINAL ()
CALL YLGRID_CLAY%FINAL ()
CALL YLGRID_SAND%FINAL ()
CALL YLGRID_COVR%FINAL ()

! Create distributions for both source & target grids

CALL CREATE_DIST (YLGRID1, YLDIST1, .TRUE.)
CALL CREATE_DIST (YLGRID2, YLDIST2)

! Create functionspaces

BLOCK
  TYPE (ATLAS_CONFIG) :: YLCONF
  YLCONF = ATLAS_CONFIG ()
  CALL YLCONF%SET ("halo", 1)
  YLFSSC1 = ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS (YLGRID1, YLDIST1, YLCONF)
  YLFSSC2 = ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS (YLGRID2, YLDIST2, YLCONF)
  CALL YLCONF%FINAL ()
ENDBLOCK

! Define indices for all fields

INFLD = 0

#define ADDFLD(J) INFLD = INFLD + 1; J = INFLD

ADDFLD (JZS         ); ADDFLD (JSAND       ); ADDFLD (JCLAY       ); 
ADDFLD (JSSO_DIR    ); ADDFLD (JSSO_SLOPE  ); ADDFLD (JSSO_ANIS   ); ADDFLD (JSSO_STDEV  ); 
ADDFLD (JAOSIP      ); ADDFLD (JAOSIM      ); ADDFLD (JAOSJP      ); ADDFLD (JAOSJM      );
ADDFLD (JHO2IP      ); ADDFLD (JHO2IM      ); ADDFLD (JHO2JP      ); ADDFLD (JHO2JM      );
ADDFLD (JFRAC_SEA   ); ADDFLD (JFRAC_TOWN  ); ADDFLD (JFRAC_WATER ); ADDFLD (JFRAC_NATURE);
ADDFLD (JBATHY      ); ADDFLD (JRUNOFFB    ); ADDFLD (JWDRAIN     ); ADDFLD (JMIN_ZS     );
ADDFLD (JMAX_ZS     ); ADDFLD (JAVG_ZS     ); ADDFLD (JSIL_ZS     );


JCOVER = INFLD
INFLD = INFLD + INCOVR

#undef ADDFLD

! Allocate fields & pointers

ALLOCATE (YLFL2 (INFLD), YLPT2 (INFLD))

YLFLDS2 = ATLAS_FIELDSET ()

! Create interpolation object (source -> target)

YLINTEA = INTERPOLATIONA (YLDIST1, YLFSSC1, YLDIST2, YLFSSC2, LDOPENMP=.TRUE.)

! Read input fields on source geometry

YLOROG1 = RNS1 ("SFX.ZS"                    ); CALL YLOROG1%DATA (ZOROG1)
YLCLAY1 = RNS1 ("SFX.CLAY", PSCALE=0.01_JPRB); CALL YLCLAY1%DATA (ZCLAY1)
YLSAND1 = RNS1 ("SFX.SAND", PSCALE=0.01_JPRB); CALL YLSAND1%DATA (ZSAND1)
YLCOVR1 = RNS1 ("SFX.COVER"                 ); CALL YLCOVR1%DATA (ZCOVR1)

BLOCK
  TYPE (ATLAS_FIELDSET) :: YLFLDSCOVR2
  TYPE (ATLAS_FIELD) :: YLCOVR2
  INTEGER (KIND=JPIM) :: ICOV
  CHARACTER (LEN=:), ALLOCATABLE :: CLNAME

  YLFLDSCOVR2 = ATLAS_COMPUTE_COVERS (YLFSSC1, YLFSSC2, YLCOVR1, YLINTEA, LDOPENMP=.TRUE.) 

  DO ICOV = 1, YLFLDSCOVR2%SIZE ()
    YLCOVR2 = YLFLDSCOVR2%FIELD (ICOV)
    CLNAME = YLCOVR2%NAME ()
    CALL YLCOVR2%RENAME ("SFX."//CLNAME)
    CALL INS2 (JCOVER+ICOV, YLCOVR2)
    DEALLOCATE (CLNAME)
  ENDDO
  
  CALL YLFLDSCOVR2%FINAL ()
ENDBLOCK

! Set missing values of orography

!$OMP WORKSHARE
WHERE (ZCOVR1 == 1._JPRB) ! Sea 
  ZOROG1 = ZUNDEF
ENDWHERE
!$OMP END WORKSHARE

! Interpolate fields using box averaging

YLFLDS1 = ATLAS_FIELDSET ()
CALL YLFLDS1%ADD (YLOROG1)
CALL YLFLDS1%ADD (YLCLAY1)
CALL YLFLDS1%ADD (YLSAND1)
YLFLDS2I = YLINTEA%INTERPOLATE (YLFLDS1)
CALL YLFLDS1%FINAL ()

! Insert interpolated fields in the list of fields of target geometry

CALL INS2 (JZS     , YLFLDS2I%FIELD ("SFX.ZS"      ))
CALL INS2 (JSAND   , YLFLDS2I%FIELD ("SFX.SAND"    ))
CALL INS2 (JCLAY   , YLFLDS2I%FIELD ("SFX.CLAY"    ))

CALL YLFLDS2I%FINAL ()

! Min, max, avg orography

BLOCK
 
  CALL INS2 (JAVG_ZS, NEWFLD (YLFSSC2, "SFX.AVG_ZS", ZUNDEF))
  CALL INS2 (JSIL_ZS, NEWFLD (YLFSSC2, "SFX.SIL_ZS", ZUNDEF))

  YLPT2 (JAVG_ZS)%ZDATA = YLPT2 (JZS)%ZDATA
  YLPT2 (JSIL_ZS)%ZDATA = YLPT2 (JZS)%ZDATA

! Use min and max reduction of interpolation object; default reduction is +

  CALL INS2 (JMIN_ZS, YLINTEA%INTERPOLATE (YLOROG1, YLINTEA%OPT_MIN ()))
  CALL INS2 (JMAX_ZS, YLINTEA%INTERPOLATE (YLOROG1, YLINTEA%OPT_MAX ()))

  CALL YLFL2 (JMIN_ZS)%RENAME ("SFX.MIN_ZS")
  CALL YLFL2 (JMAX_ZS)%RENAME ("SFX.MAX_ZS")

ENDBLOCK

BLOCK
  TYPE (ATLAS_FIELDSET) :: YLFLDS2SSO
  TYPE (ATLAS_FIELD)    :: YLFLD2

  YLFLDS2SSO = ATLAS_COMPUTE_SSO (YLFSSC1, YLFSSC2, YLOROG1, YLFL2 (JZS), YLINTEA, LDOPENMP=.TRUE., LDROTATE=.TRUE.) 

  YLFLD2 = YLFLDS2SSO%FIELD ("SSO_DIR"  ); CALL YLFLD2%RENAME ("SFX.SSO_DIR"  ); CALL INS2 (JSSO_DIR  , YLFLD2)
  YLFLD2 = YLFLDS2SSO%FIELD ("SSO_SLOPE"); CALL YLFLD2%RENAME ("SFX.SSO_SLOPE"); CALL INS2 (JSSO_SLOPE, YLFLD2)
  YLFLD2 = YLFLDS2SSO%FIELD ("SSO_ANIS" ); CALL YLFLD2%RENAME ("SFX.SSO_ANIS" ); CALL INS2 (JSSO_ANIS , YLFLD2)
  YLFLD2 = YLFLDS2SSO%FIELD ("SSO_STDEV"); CALL YLFLD2%RENAME ("SFX.SSO_STDEV"); CALL INS2 (JSSO_STDEV, YLFLD2)
ENDBLOCK

! Add enveloppe

!$OMP WORKSHARE 
  WHERE (YLPT2 (JZS)%ZDATA (:) /= ZUNDEF)
    YLPT2 (JZS)%ZDATA (:) = YLPT2 (JZS)%ZDATA (:) + YLPT2 (JSSO_STDEV)%ZDATA
  ENDWHERE
!$OMP END WORKSHARE



BLOCK
  INTEGER (KIND=JPIM) :: JFLD
  TYPE (ATLAS_FIELD) :: YLFLD2
  INTEGER (KIND=JPIM) :: IAOSHO (8)
  CHARACTER (LEN=16) :: CLAOSN (8) 
  TYPE (ATLAS_FIELDSET) :: YLFLDSAOS2
  TYPE (INTERPOLATION4) :: YLINTE4

  YLINTE4 = INTERPOLATION4 (YLDIST2, YLFSSC2, YLDIST1, YLFSSC1)

  YLFLDSAOS2 = ATLAS_COMPUTE_AOS (YLFSSC1, YLFSSC2, YLOROG1, YLFL2 (JZS), YLINTEA, YLINTE4, LDOPENMP=.TRUE.) 

  CLAOSN = ["AOSIP           ", "AOSIM           ", "AOSJP           ", "AOSJM           ", &
            "HO2IP           ", "HO2IM           ", "HO2JP           ", "HO2JM           "]
  IAOSHO = [JAOSIP, JAOSIM, JAOSJP, JAOSJM, JHO2IP, JHO2IM, JHO2JP, JHO2JM]
  
  DO JFLD = 1, 8
    YLFLD2 = YLFLDSAOS2%FIELD (TRIM (CLAOSN (JFLD)))
    CALL YLFLD2%RENAME ("SFX."//TRIM (CLAOSN (JFLD)))
    CALL INS2 (IAOSHO (JFLD), YLFLD2)
  ENDDO

  CALL YLINTE4%FINAL ()
ENDBLOCK

CALL COMPUTE_FRACTIONS

! Other; insert dummy fields for now

BLOCK

  CALL INS2 (JBATHY  , NEWFLD (YLFSSC2, "SFX.BATHY" , ZUNDEF))
  CALL INS2 (JRUNOFFB, NEWFLD (YLFSSC2, "SFX.RUNOFF", ZUNDEF))
  CALL INS2 (JWDRAIN , NEWFLD (YLFSSC2, "SFX.WDRAIN", ZUNDEF))

!$OMP WORKSHARE 
  WHERE (YLPT2 (JFRAC_SEA)%ZDATA > 0._JPRB)
    YLPT2 (JBATHY)%ZDATA = -300._JPRB
  ELSEWHERE
    YLPT2 (JBATHY)%ZDATA = ZUNDEF
  ENDWHERE
!$OMP END WORKSHARE

!$OMP WORKSHARE 
  WHERE (YLPT2 (JFRAC_NATURE)%ZDATA > 0._JPRB)
    YLPT2 (JRUNOFFB)%ZDATA = 0.5_JPRB
    YLPT2 (JWDRAIN)%ZDATA = 0.0_JPRB
  ELSEWHERE
    YLPT2 (JRUNOFFB)%ZDATA = ZUNDEF
    YLPT2 (JWDRAIN)%ZDATA = ZUNDEF
  ENDWHERE
!$OMP END WORKSHARE

ENDBLOCK

! Fix missing values: orography parameters, set to zero

BLOCK
  INTEGER (KIND=JPIM) :: IZS (17)
  IZS = &
& [ JZS   ,  JSSO_DIR, JSSO_SLOPE, JSSO_ANIS,  JSSO_STDEV, JAOSIP, &
&   JAOSIM,  JAOSJP  , JAOSJM    , JHO2IP   ,  JHO2IM    , JHO2JP, &
&   JHO2JM,  JMIN_ZS , JMAX_ZS   , JAVG_ZS  ,  JSIL_ZS   ]

  DO JFLD = 1, SIZE (IZS)
    IF (YLFL2 (IZS (JFLD))%IS_NULL ()) CYCLE
!$OMP WORKSHARE 
    WHERE (YLPT2 (IZS (JFLD))%ZDATA == ZUNDEF)
      YLPT2 (IZS (JFLD))%ZDATA = 0._JPRB
    ENDWHERE
!$OMP END WORKSHARE
  ENDDO

ENDBLOCK

CALL YLFAIO%WRITE ('PGD2', YLFLDS2, YLFSSC2)

DO JFLD = 1, INFLD
  CALL YLFL2 (JFLD)%FINAL ()
ENDDO


CALL YLOROG1%FINAL ()
CALL YLCLAY1%FINAL ()
CALL YLSAND1%FINAL ()
CALL YLCOVR1%FINAL ()
CALL YLFLDS2%FINAL ()
CALL YLINTEA%FINAL ()
CALL YLGRID1%FINAL ()
CALL YLDIST1%FINAL ()
CALL YLDIST2%FINAL ()
CALL YLFSSC1%FINAL ()
CALL YLFSSC2%FINAL ()



CALL YLTRAC%FINAL ()

CALL ATLAS_LIBRARY%FINALISE()

WRITE (*, *) "--- STOP ---"

CONTAINS

SUBROUTINE COMPUTE_FRACTIONS

TYPE (COVERS_t) :: YLCOVERS
LOGICAL, ALLOCATABLE :: LCOVER (:)

REAL (KIND=JPRB) :: ZAVGCOVR2 (INCOVR)
REAL (KIND=JPRB) :: ZMINCOVR2 (INCOVR)
REAL (KIND=JPRB) :: ZMAXCOVR2 (INCOVR)

! Create fractions fields

CALL INS2 (JFRAC_SEA   , NEWFLD (YLFSSC2, "SFX.FRAC_SEA"   , ZUNDEF))
CALL INS2 (JFRAC_NATURE, NEWFLD (YLFSSC2, "SFX.FRAC_NATURE", ZUNDEF))
CALL INS2 (JFRAC_TOWN  , NEWFLD (YLFSSC2, "SFX.FRAC_TOWN"  , ZUNDEF))
CALL INS2 (JFRAC_WATER , NEWFLD (YLFSSC2, "SFX.FRAC_WATER" , ZUNDEF))

CALL READCOVERS (YLCOVERS, 1, LGARDEN, LWATER_TO_NATURE, LTOWN_TO_ROCK)
CALL FIELDSTAT (YLFSSC2, YLFL2 (JCOVER+1:JCOVER+INCOVR), PMIN=ZMINCOVR2, PMAX=ZMAXCOVR2, PAVG=ZAVGCOVR2)

ALLOCATE (LCOVER (YLCOVERS%JPCOVER))
LCOVER = .FALSE.

LCOVER = ZAVGCOVR2 > 0._JPRB

CALL MAKEFRAC (YLPT2 (JFRAC_SEA   )%ZDATA, YLFL2 (JCOVER+1:JCOVER+INCOVR), YLCOVERS%XDATA_SEA   , LCOVER)
CALL MAKEFRAC (YLPT2 (JFRAC_NATURE)%ZDATA, YLFL2 (JCOVER+1:JCOVER+INCOVR), YLCOVERS%XDATA_NATURE, LCOVER)
CALL MAKEFRAC (YLPT2 (JFRAC_TOWN  )%ZDATA, YLFL2 (JCOVER+1:JCOVER+INCOVR), YLCOVERS%XDATA_TOWN  , LCOVER)
CALL MAKEFRAC (YLPT2 (JFRAC_WATER )%ZDATA, YLFL2 (JCOVER+1:JCOVER+INCOVR), YLCOVERS%XDATA_WATER , LCOVER)

END SUBROUTINE

SUBROUTINE MAKEFRAC (PFRAC, YDCOVER, PDATA, LDCOVER)

REAL (KIND=JPRB),   INTENT (OUT) :: PFRAC (:)
TYPE (ATLAS_FIELD), INTENT (IN)  :: YDCOVER (:)
REAL (KIND=JPRB),   INTENT (IN)  :: PDATA (:)
LOGICAL,            INTENT (IN)  :: LDCOVER (:)

TYPE (PTR) :: YLPTR (SIZE (YDCOVER))

INTEGER (KIND=JPIM) :: JLOC, JCOV, INCOV
REAL (KIND=JPRB) :: ZSUM

INCOV = SIZE (YDCOVER)

DO JCOV = 1, INCOV
  CALL YDCOVER (JCOV)%DATA (YLPTR (JCOV)%ZDATA)
ENDDO

! 1D computation

!$OMP PARALLEL DO PRIVATE (JLOC, ZSUM, JCOV) 
DO JLOC = 1, SIZE (PFRAC)
  PFRAC (JLOC) = 0._JPRB
  ZSUM = 0._JPRB
  DO JCOV = 1, INCOV
    IF (LDCOVER (JCOV)) THEN
      PFRAC (JLOC) = PFRAC (JLOC) + YLPTR (JCOV)%ZDATA (JLOC) * PDATA (JCOV)
      ZSUM         = ZSUM + YLPTR (JCOV)%ZDATA (JLOC)
    ENDIF
  ENDDO
  PFRAC (JLOC) = PFRAC (JLOC) / ZSUM
ENDDO
!$OMP END PARALLEL DO

END SUBROUTINE

FUNCTION RNS1 (CDNAME, PSCALE) RESULT (YLFL)

CHARACTER (LEN=*),   INTENT (IN) :: CDNAME
REAL (KIND=JPRB),    INTENT (IN), OPTIONAL :: PSCALE

TYPE (ATLAS_FIELDSET) :: YLFS
TYPE (ATLAS_FIELD) :: YLFL

! Read a field on source geometry, and insert it in the list #1

YLFS = YLDHIO%READ (CDNAME, [CDNAME], YLFSSC1, PUNDEF=ZUNDEF, PSCALE=PSCALE)

YLFL = YLFS%FIELD (1)

CALL YLFS%FINAL ()

CALL YLFL%RETURN ()

END FUNCTION

SUBROUTINE INS2 (KRANK, YDFL)

INTEGER (KIND=JPIM), INTENT (IN) :: KRANK
TYPE (ATLAS_FIELD),  INTENT (IN) :: YDFL

! Insert a field in list #2 (target)

IF (.NOT. YLFL2 (KRANK)%IS_NULL ()) CALL ABORT ('FIELD ALREADY EXISTS')
IF (YDFL%SIZE () /= YLFSSC2%SIZE ()) CALL ABORT ('SIZE MISMATCH')
YLFL2 (KRANK) = YDFL
CALL YDFL%DATA (YLPT2 (KRANK)%ZDATA)
CALL YLFLDS2%ADD (YDFL)

END SUBROUTINE

END PROGRAM

