PROGRAM ATLAS_CLIM

USE PARKIND1, ONLY : JPIM, JPRB
USE ATLAS_IO_GATHSCAT, ONLY : ATLAS_IO_GATHSCAT_t
USE ATLAS_FMT_FA, ONLY : ATLAS_FMT_FA_t
USE FCKIT_MODULE, ONLY : FCKIT_MPI_COMM
USE INTERPOLATIONA_MOD
USE INTERPOLATION4_MOD
USE ATLAS_MODULE  
USE ATLAS_HELPER
USE ATLAS_TRACE_MODULE
USE XRD_GETOPTIONS
USE READCOVERS_MOD

!

#include "atlas-abort.h"

IMPLICIT NONE

REAL (KIND=JPRB), PARAMETER :: RPI = 2.0_JPRB * ASIN (1.0_JPRB)
REAL (KIND=JPRB), PARAMETER :: RA = 6371229._JPRB
REAL (KIND=JPRB), PARAMETER :: RG = 9.80665_JPRB
REAL (KIND=JPRB), PARAMETER :: XKARMAN = 0.4_JPRB
REAL (KIND=JPRB), PARAMETER :: XCDZ0EFF = 0.8_JPRB
REAL (KIND=JPRB), PARAMETER :: ZUNDEF = HUGE (1._JPRB)
REAL (KIND=JPRB), PARAMETER :: SMASK = 0.5_JPRB
REAL (KIND=JPRB), PARAMETER :: SVEG = 0.02_JPRB

! From sucst

REAL (KIND=JPRB), PARAMETER :: RKBOL = 1.380658E-23_JPRB
REAL (KIND=JPRB), PARAMETER :: RNAVO = 6.0221367E+23_JPRB
REAL (KIND=JPRB), PARAMETER :: R     = RNAVO * RKBOL
REAL (KIND=JPRB), PARAMETER :: RMD   = 28.9644_JPRB
REAL (KIND=JPRB), PARAMETER :: RMV   = 18.0153_JPRB
REAL (KIND=JPRB), PARAMETER :: RD    = 1000._JPRB * R / RMD
REAL (KIND=JPRB), PARAMETER :: RV    = 1000._JPRB * R / RMV
REAL (KIND=JPRB), PARAMETER :: RCPV  = 4._JPRB  * RV
REAL (KIND=JPRB), PARAMETER :: RETV  = RV / RD - 1.0_JPRB
REAL (KIND=JPRB), PARAMETER :: RCW   = 4218._JPRB
REAL (KIND=JPRB), PARAMETER :: RCS   = 2106._JPRB
REAL (KIND=JPRB), PARAMETER :: RTT   = 273.16_JPRB
REAL (KIND=JPRB), PARAMETER :: RLVTT = 2.5008E+6_JPRB
REAL (KIND=JPRB), PARAMETER :: RLSTT = 2.8345E+6_JPRB
REAL (KIND=JPRB), PARAMETER :: RESTT = 611.14_JPRB
REAL (KIND=JPRB), PARAMETER :: RGAMW = (RCW - RCPV) / RV
REAL (KIND=JPRB), PARAMETER :: RBETW = RLVTT / RV + RGAMW * RTT
REAL (KIND=JPRB), PARAMETER :: RALPW = LOG (RESTT) + RBETW / RTT + RGAMW * LOG (RTT)
REAL (KIND=JPRB), PARAMETER :: RGAMS = (RCS - RCPV) / RV
REAL (KIND=JPRB), PARAMETER :: RBETS = RLSTT / RV + RGAMS * RTT
REAL (KIND=JPRB), PARAMETER :: RALPS = LOG (RESTT) + RBETS / RTT + RGAMS * LOG (RTT)
REAL (KIND=JPRB), PARAMETER :: RGAMD = RGAMS - RGAMW
REAL (KIND=JPRB), PARAMETER :: RBETD = RBETS - RBETW
REAL (KIND=JPRB), PARAMETER :: RALPD = RALPS - RALPW

! 
INTEGER (KIND=JPIM), PARAMETER :: NTPLAC = 5, NTPMER = 1, NTPGLA = 2, NTPDES = 3
REAL (KIND=JPRB), PARAMETER :: SALBB  = 0.65_JPRB, SALBM = 0.07_JPRB, SALBN = 0.05_JPRB,              &
& SALBX = 0.80_JPRB, SEMIB = 0.97_JPRB, SEMIM  = 0.96_JPRB, SRSMD = 5000._JPRB, SRSMN = 1.0_JPRB,     &
& SRSMX = 5000._JPRB, STHER = 0.10_JPRB, SZZ0B = 0.001_JPRB, SZZ0D = 0.001_JPRB, SZZ0M = 0.001_JPRB,  &
& SZZ0U = 2.500_JPRB, TMERGL = 271.23_JPRB, SFCZ0 = 1._JPRB
!


INTEGER (KIND=JPIM), PARAMETER :: INCOVR = 256_JPIM
LOGICAL, PARAMETER :: LGARDEN = .FALSE., LWATER_TO_NATURE = .FALSE., LTOWN_TO_ROCK = .FALSE.

#include "atlas-compute-covers.h"
#include "atlas-compute-sso.h"
#include "atlas-compute-aos.h"

TYPE (ATLAS_IO_GATHSCAT_t)                :: YLFAIO
TYPE (ATLAS_FMT_FA_t),             TARGET :: YLFMFA
TYPE (ATLAS_STRUCTUREDGRID)               :: YLGRID2
TYPE (ATLAS_TRACE)                        :: YLTRAC

! Functionspaces

TYPE (ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS) :: YLFSSC2

! Distributions (of grids on MPI tasks)

TYPE (ATLAS_GRIDDISTRIBUTION)                :: YLDIST2


! Communicator

TYPE (FCKIT_MPI_COMM)                        :: YLCOMM

INTEGER (KIND=JPIM) :: NPROC, IRANK


! Atlas fields for target geometry

TYPE (ATLAS_FIELD), ALLOCATABLE :: YLFL2 (:, :)

! Pointers to access data of target fields

TYPE (PTR),         ALLOCATABLE :: YLPT2 (:, :)

INTEGER (KIND=JPIM) :: INFLD

! Indices of all fields

INTEGER (KIND=JPIM) :: JSURFGEOPOTENTIEL
INTEGER (KIND=JPIM) :: JSURFVARGEOPDIR  , JSURFVARGEOPANI , JSURFETGEOPOTENT, JSURFZ0RELFOISG, JSURFZ0FOISG
INTEGER (KIND=JPIM) :: JSURFPROPURBANIS , JSURFPROPTERRE
INTEGER (KIND=JPIM) :: JSURFINDTERREMER , JSURFPROPSABLE  , JSURFPROPARGILE
INTEGER (KIND=JPIM) :: JSURFINDVEGDOMI  , JSURFALBEDOSOLNU, JSURFEMISSIVITE , JSURFEPAISOLMAX , JSURFALBEDO
INTEGER (KIND=JPIM) :: JSURFPROPVEGMAX  , JSURFALBEDOCOMPL, JSURFPROPVEGETAT, JSURFEPAISSOL
INTEGER (KIND=JPIM) :: JSURFTEMPERATURE , JPROFTEMPERATURE, JSURFPROPRMAXEA , JPROFPROPRMAXEA
INTEGER (KIND=JPIM) :: JSURFRESERVNEIGE , JRELATEMPERATURE, JRELAPROPRMAXEA 
INTEGER (KIND=JPIM) :: JSURFINDFOLIAIRE , JSURFRESISTOMIN
INTEGER (KIND=JPIM) :: JSURFGZ0THERM    , JSURFZ0VEGFOISG , JSURFALBEDOVEG  
INTEGER (KIND=JPIM) :: JSURFAOFOZONE    , JSURFBOFOZONE   , JSURFCOFOZONE
INTEGER (KIND=JPIM) :: JSURFAEROSSEA    , JSURFAEROSLAND  , JSURFAEROSSOOT  , JSURFAEROSDESERT

INTEGER (KIND=JPIM), PARAMETER :: I00MONTH (1) = [0], I12MONTH (12) = [1,2,3,4,5,6,7,8,9,10,11,12]


CALL INITOPTIONS ()
CALL CHECKOPTIONS ()

YLFAIO = ATLAS_IO_GATHSCAT_t (YLFMFA)

CALL ATLAS_LIBRARY%INITIALISE ()

YLTRAC = ATLAS_TRACE (__FILE__, __LINE__, "ATLAS_CLIM")

YLCOMM = FCKIT_MPI_COMM ()
NPROC  = YLCOMM%SIZE ()
IRANK  = YLCOMM%RANK ()

CALL LINUX_BIND (IRANK, NPROC)

YLGRID2 = GRID_FROM_NAMELIST ()

! Create distributions for both source & target grids

CALL CREATE_DIST (YLGRID2, YLDIST2)

! Create functionspaces

BLOCK
  TYPE (ATLAS_CONFIG) :: YLCONF
  YLCONF = ATLAS_CONFIG ()
  CALL YLCONF%SET ("halo", 1)
  YLFSSC2 = ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS (YLGRID2, YLDIST2, YLCONF)
  CALL YLCONF%FINAL ()
ENDBLOCK

! Define indices for all fields

INFLD = 0

#define ADDFLD(J) INFLD = INFLD + 1; J = INFLD

ADDFLD (JSURFGEOPOTENTIEL); ADDFLD (JSURFPROPSABLE  ); 
ADDFLD (JSURFPROPARGILE  ); ADDFLD (JSURFVARGEOPDIR ); 
ADDFLD (JSURFVARGEOPANI  ); ADDFLD (JSURFETGEOPOTENT); 
ADDFLD (JSURFINDTERREMER ); ADDFLD (JSURFPROPURBANIS); 
ADDFLD (JSURFPROPTERRE   ); ADDFLD (JSURFZ0RELFOISG );  
ADDFLD (JSURFZ0FOISG     ); ADDFLD (JSURFINDVEGDOMI ); 
ADDFLD (JSURFALBEDOSOLNU ); ADDFLD (JSURFEMISSIVITE ); 
ADDFLD (JSURFEPAISOLMAX  ); ADDFLD (JSURFALBEDO     ); 
ADDFLD (JSURFPROPVEGMAX  ); ADDFLD (JSURFALBEDOCOMPL); 
ADDFLD (JSURFEPAISSOL    ); ADDFLD (JSURFPROPVEGETAT);  
ADDFLD (JSURFTEMPERATURE ); ADDFLD (JPROFTEMPERATURE); 
ADDFLD (JSURFPROPRMAXEA  ); ADDFLD (JPROFPROPRMAXEA );
ADDFLD (JSURFRESERVNEIGE ); ADDFLD (JRELATEMPERATURE);
ADDFLD (JRELAPROPRMAXEA  ); ADDFLD (JSURFALBEDO     );
ADDFLD (JSURFEMISSIVITE  ); ADDFLD (JSURFZ0FOISG    );
ADDFLD (JSURFINDFOLIAIRE ); ADDFLD (JSURFRESISTOMIN );
ADDFLD (JSURFGZ0THERM    ); ADDFLD (JSURFZ0VEGFOISG );
ADDFLD (JSURFALBEDOVEG   ); ADDFLD (JSURFPROPVEGETAT);
ADDFLD (JSURFAOFOZONE    ); ADDFLD (JSURFBOFOZONE   );
ADDFLD (JSURFCOFOZONE    ); ADDFLD (JSURFAEROSSEA   );
ADDFLD (JSURFAEROSLAND   ); ADDFLD (JSURFAEROSSOOT  );
ADDFLD (JSURFAEROSDESERT );

#undef ADDFLD

! Allocate fields & pointers

ALLOCATE (YLFL2 (INFLD, 0:12), YLPT2 (INFLD, 0:12))

CALL INCLI1; CALL WRFLS ('Const.Clim.INCLI1', I00MONTH)
CALL INCLI2; CALL WRFLS ('Const.Clim.INCLI2', I00MONTH) 
CALL INCLI3; CALL WRFLS ('Const.Clim.INCLI3', I12MONTH)
CALL INCLI4; CALL WRFLS ('Const.Clim.INCLI4', I12MONTH)
!ALL INCLI5; CALL WRFLS ('Const.Clim.INCLI5', I12MONTH)
!ALL INCLI6; CALL WRFLS ('Const.Clim.INCLI6', I12MONTH)
!ALL INCLI7; CALL WRFLS ('Const.Clim.INCLI7', I12MONTH)
CALL INCLI8; CALL WRFLS ('Const.Clim.INCLI8', I12MONTH)
CALL INCLI9; CALL WRFLS ('Const.Clim.INCLI9', I12MONTH)

BLOCK
  INTEGER (KIND=JPIM) :: IMONTH, JFLD
  DO IMONTH = 0, 12
    DO JFLD = 1, INFLD
      CALL YLFL2 (JFLD, IMONTH)%FINAL ()
    ENDDO
  ENDDO
ENDBLOCK

CALL YLGRID2%FINAL ()
CALL YLDIST2%FINAL ()
CALL YLFSSC2%FINAL ()

CALL YLTRAC%FINAL ()

CALL ATLAS_LIBRARY%FINALISE()

WRITE (*, *) "--- STOP ---"

CONTAINS

SUBROUTINE INCLI9

USE ATLAS_FMT_AEROSOLS, ONLY : ATLAS_FMT_AEROSOLS_t

TYPE (INTERPOLATION4) :: YLINTEG
TYPE (ATLAS_FIELDSET) :: YLFSG1, YLFSG2
TYPE (ATLAS_FIELD) :: YLF

TYPE (ATLAS_IO_GATHSCAT_t)                :: YLFBIO
TYPE (ATLAS_FMT_AEROSOLS_t),       TARGET :: YLFMFB
TYPE (ATLAS_STRUCTUREDGRID)               :: YLGRIDG

TYPE (ATLAS_GRIDDISTRIBUTION)                :: YLDISTG
TYPE (ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS) :: YLFSSCG

CHARACTER (LEN=16) :: CLNAMG (12*4)
CHARACTER (LEN=4) :: CLMONTH
INTEGER (KIND=JPIM) :: IMONTH

YLFBIO = ATLAS_IO_GATHSCAT_t (YLFMFB)

YLGRIDG = YLFMFB%GRID ("aero_GL")

CALL CREATE_DIST (YLGRIDG, YLDISTG)

BLOCK
  TYPE (ATLAS_CONFIG) :: YLCONF
  YLCONF = ATLAS_CONFIG ()
  CALL YLCONF%SET ("halo", 1)
  YLFSSCG = ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS (YLGRIDG, YLDISTG, YLCONF)
  CALL YLCONF%FINAL ()
ENDBLOCK

DO IMONTH = 1, 12
  WRITE (CLMONTH, '(".m",I2.2)') IMONTH
  CLNAMG (4*(IMONTH-1)+1) = 'sea'   //TRIM (CLMONTH)
  CLNAMG (4*(IMONTH-1)+2) = 'land'  //TRIM (CLMONTH)
  CLNAMG (4*(IMONTH-1)+3) = 'soot'  //TRIM (CLMONTH)
  CLNAMG (4*(IMONTH-1)+4) = 'desert'//TRIM (CLMONTH)
ENDDO

YLFSG1 = YLFBIO%READ ('aero_GL', CLNAMG, YLFSSCG, PUNDEF=ZUNDEF)
CALL YLFAIO%WRITE ('INCLI9', YLFSG1, YLFSSCG)

YLINTEG = INTERPOLATION4 (YLDISTG, YLFSSCG, YLDIST2, YLFSSC2)
YLFSG2 = YLINTEG%INTERPOLATE (YLFSG1)

BLOCK
  INTEGER :: IX, IY, IGLO
  IGLO = 0
  DO IY = 1, YLGRIDG%NY ()
    DO IX = 1, YLGRIDG%NX (IY)
     IGLO = IGLO + 1
     IF ((640 <= IGLO) .AND. (IGLO <= 660)) THEN
       WRITE (0, *) IGLO, YLGRIDG%LONLAT (IX, IY)
     ENDIF
    ENDDO
  ENDDO
ENDBLOCK


DO IMONTH = 1, 12
  BLOCK
    TYPE (ATLAS_FIELD) :: YLF
    WRITE (CLMONTH, '(".m",I2.2)') IMONTH
    YLF = YLFSG2%FIELD ("sea"   //CLMONTH); CALL YLF%RENAME ("SURFAEROS.SEA"   ); CALL INS2 (JSURFAEROSSEA   , IMONTH, YLF); CALL YLF%FINAL ()
    YLF = YLFSG2%FIELD ("land"  //CLMONTH); CALL YLF%RENAME ("SURFAEROS.LAND"  ); CALL INS2 (JSURFAEROSLAND  , IMONTH, YLF); CALL YLF%FINAL ()
    YLF = YLFSG2%FIELD ("soot"  //CLMONTH); CALL YLF%RENAME ("SURFAEROS.SOOT"  ); CALL INS2 (JSURFAEROSSOOT  , IMONTH, YLF); CALL YLF%FINAL ()
    YLF = YLFSG2%FIELD ("desert"//CLMONTH); CALL YLF%RENAME ("SURFAEROS.DESERT"); CALL INS2 (JSURFAEROSDESERT, IMONTH, YLF); CALL YLF%FINAL ()
  ENDBLOCK
ENDDO


END SUBROUTINE

SUBROUTINE INCLI8

USE ATLAS_FMT_OZONE, ONLY : ATLAS_FMT_OZONE_t

TYPE (INTERPOLATION4) :: YLINTEG
TYPE (ATLAS_FIELDSET) :: YLFSG1, YLFSG2
TYPE (ATLAS_FIELD) :: YLF

TYPE (ATLAS_IO_GATHSCAT_t)                :: YLFBIO
TYPE (ATLAS_FMT_OZONE_t),          TARGET :: YLFMFB
TYPE (ATLAS_STRUCTUREDGRID)               :: YLGRIDG

TYPE (ATLAS_GRIDDISTRIBUTION)                :: YLDISTG
TYPE (ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS) :: YLFSSCG

CHARACTER (LEN=16) :: CLNAMG (12*3)
CHARACTER (LEN=4) :: CLMONTH
INTEGER (KIND=JPIM) :: IMONTH

YLFBIO = ATLAS_IO_GATHSCAT_t (YLFMFB)

YLGRIDG = YLFMFB%GRID ("abc_coef")

CALL CREATE_DIST (YLGRIDG, YLDISTG)

BLOCK
  TYPE (ATLAS_CONFIG) :: YLCONF
  YLCONF = ATLAS_CONFIG ()
  CALL YLCONF%SET ("halo", 1)
  YLFSSCG = ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS (YLGRIDG, YLDISTG, YLCONF)
  CALL YLCONF%FINAL ()
ENDBLOCK

DO IMONTH = 1, 12
  WRITE (CLMONTH, '(".m",I2.2)') IMONTH
  CLNAMG (3*(IMONTH-1)+1) = 'a'//TRIM (CLMONTH)
  CLNAMG (3*(IMONTH-1)+2) = 'b'//TRIM (CLMONTH)
  CLNAMG (3*(IMONTH-1)+3) = 'c'//TRIM (CLMONTH)
ENDDO

YLFSG1 = YLFBIO%READ ('abc_coef', CLNAMG, YLFSSCG, PUNDEF=ZUNDEF)
YLINTEG = INTERPOLATION4 (YLDISTG, YLFSSCG, YLDIST2, YLFSSC2)
YLFSG2 = YLINTEG%INTERPOLATE (YLFSG1)

CALL YLFAIO%WRITE ('INCLI8', YLFSG2, YLFSSC2)

DO IMONTH = 1, 12
  BLOCK
    TYPE (ATLAS_FIELD) :: YLF
    WRITE (CLMONTH, '(".m",I2.2)') IMONTH
    YLF = YLFSG2%FIELD ("a"//CLMONTH); CALL YLF%RENAME ("SURFA.OF.OZONE"); CALL INS2 (JSURFAOFOZONE, IMONTH, YLF); CALL YLF%FINAL ()
    YLF = YLFSG2%FIELD ("b"//CLMONTH); CALL YLF%RENAME ("SURFB.OF.OZONE"); CALL INS2 (JSURFBOFOZONE, IMONTH, YLF); CALL YLF%FINAL ()
    YLF = YLFSG2%FIELD ("c"//CLMONTH); CALL YLF%RENAME ("SURFC.OF.OZONE"); CALL INS2 (JSURFCOFOZONE, IMONTH, YLF); CALL YLF%FINAL ()
  ENDBLOCK
ENDDO


END SUBROUTINE

SUBROUTINE WRFLS (CDFILE, KMONTH)

USE ATLAS_IO, ONLY : ATLAS_IO_t

CHARACTER (LEN=*),   INTENT (IN) :: CDFILE
INTEGER (KIND=JPIM), INTENT (IN) :: KMONTH (:)

TYPE (ATLAS_FIELDSET) :: YLFLDS
INTEGER (KIND=JPIM) :: IMONTH, J
CHARACTER (LEN=4) :: CLMONTH
CHARACTER (LEN=256) :: CLFILE

INTEGER (KIND=JPIM) :: JFLD

DO J = 1, SIZE (KMONTH)

  IMONTH = KMONTH (J)
  WRITE (CLMONTH, '(".m",I2.2)') IMONTH

  YLFLDS = ATLAS_FIELDSET ()

  DO JFLD = 1, SIZE (YLFL2, 1)
    IF (YLFL2 (JFLD, IMONTH)%IS_NULL ()) CYCLE
    CALL YLFLDS%ADD (YLFL2 (JFLD, IMONTH))
  ENDDO
  
  IF (IMONTH > 0) THEN
    CLFILE = TRIM (CDFILE)//CLMONTH
  ELSE
    CLFILE = CDFILE
  ENDIF

  CALL YLFAIO%WRITE (TRIM (CLFILE), YLFLDS, YLFSSC2)

  CALL YLFLDS%FINAL ()

ENDDO

END SUBROUTINE

SUBROUTINE INCLI4

USE ATLAS_FMT_SOIL_AND_VEG, ONLY : ATLAS_FMT_SOIL_AND_VEG_t

TYPE (INTERPOLATION4) :: YLINTEG
TYPE (ATLAS_FIELDSET) :: YLFSG1, YLFSG2
TYPE (ATLAS_FIELD) :: YLF

TYPE (ATLAS_IO_GATHSCAT_t)                :: YLFBIO
TYPE (ATLAS_FMT_SOIL_AND_VEG_t),   TARGET :: YLFMFB
TYPE (ATLAS_STRUCTUREDGRID)               :: YLGRIDG

TYPE (ATLAS_GRIDDISTRIBUTION)                :: YLDISTG
TYPE (ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS) :: YLFSSCG

CHARACTER (LEN=16) :: CLNAMG (3+12*2)
CHARACTER (LEN=4) :: CLMONTH
INTEGER (KIND=JPIM) :: JFLD
REAL (KIND=JPRB), POINTER :: ZZ0V (:), ZALV (:), ZRSM (:), ZVEG (:), ZLAI (:)

INTEGER (KIND=JPIM) :: IMONTH

YLFBIO = ATLAS_IO_GATHSCAT_t (YLFMFB)

YLGRIDG = YLFMFB%GRID ("z0v_GL")

CALL CREATE_DIST (YLGRIDG, YLDISTG)

BLOCK
  TYPE (ATLAS_CONFIG) :: YLCONF
  YLCONF = ATLAS_CONFIG ()
  CALL YLCONF%SET ("halo", 1)
  YLFSSCG = ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS (YLGRIDG, YLDISTG, YLCONF)
  CALL YLCONF%FINAL ()
ENDBLOCK

CLNAMG (1:3) = ['z0v_GL          ', 'alv_GL          ', 'rsm_GL          ']

DO IMONTH = 1, 12
  WRITE (CLMONTH, '(".m",I2.2)') IMONTH
  CLNAMG (3+2*(IMONTH-1)+1) = 'veg_GL'//TRIM (CLMONTH)
  CLNAMG (3+2*(IMONTH-1)+2) = 'lai_GL'//TRIM (CLMONTH)
ENDDO


YLFSG1 = YLFBIO%READ ('', CLNAMG, YLFSSCG, PUNDEF=ZUNDEF)


BLOCK
  TYPE (ATLAS_FIELD) :: YLF
  REAL (KIND=JPRB), PARAMETER :: ZEPS = 1.E-10_JPRB
  REAL (KIND=JPRB), ALLOCATABLE :: ZDES (:)

  ALLOCATE (ZDES (YLFSSCG%SIZE ()))

  DO IMONTH = 1, 12
   
  
    WRITE (CLMONTH, '(".m",I2.2)') IMONTH
  
    CALL YLFSG1%ADD (CPYFLD (YLFSG1%FIELD ('z0v_GL'), 'z0v_GL'//TRIM (CLMONTH)))
    CALL YLFSG1%ADD (CPYFLD (YLFSG1%FIELD ('alv_GL'), 'alv_GL'//TRIM (CLMONTH)))
    CALL YLFSG1%ADD (CPYFLD (YLFSG1%FIELD ('rsm_GL'), 'rsm_GL'//TRIM (CLMONTH)))

    YLF = YLFSG1%FIELD ('z0v_GL'//TRIM (CLMONTH)); CALL YLF%DATA (ZZ0V); CALL YLF%FINAL ()
    YLF = YLFSG1%FIELD ('alv_GL'//TRIM (CLMONTH)); CALL YLF%DATA (ZALV); CALL YLF%FINAL ()
    YLF = YLFSG1%FIELD ('rsm_GL'//TRIM (CLMONTH)); CALL YLF%DATA (ZRSM); CALL YLF%FINAL ()
    YLF = YLFSG1%FIELD ('veg_GL'//TRIM (CLMONTH)); CALL YLF%DATA (ZVEG); CALL YLF%FINAL ()
    YLF = YLFSG1%FIELD ('lai_GL'//TRIM (CLMONTH)); CALL YLF%DATA (ZLAI); CALL YLF%FINAL ()

    WHERE (ZVEG < SVEG)
      ZDES = 1._JPRB
    ELSEWHERE
      ZDES = 0._JPRB
    ENDWHERE

    WHERE ((ZZ0V < ZEPS) .OR. (ZZ0V == ZUNDEF) .OR. (ZDES > SMASK))
      ZZ0V = ZUNDEF
    ELSEWHERE
      ZZ0V = LOG (ZZ0V)
    ENDWHERE

    WHERE ((ZLAI == ZUNDEF) .OR. (ZRSM < ZEPS) .OR. (ZDES >= SMASK))
      ZLAI = ZUNDEF
      ZRSM = ZUNDEF
    ELSEWHERE
      ZRSM = ZLAI / ZRSM
    ENDWHERE

  ENDDO

  DEALLOCATE (ZDES)
ENDBLOCK

YLINTEG = INTERPOLATION4 (YLDISTG, YLFSSCG, YLDIST2, YLFSSC2)
YLFSG2 = YLINTEG%INTERPOLATE (YLFSG1)
CALL YLFAIO%WRITE ('INCLI4', YLFSG2, YLFSSC2)

DO IMONTH = 1, 12
  BLOCK
    REAL (KIND=JPRB), POINTER :: ZZ0V (:), ZALV (:), ZRSM (:), ZVEG (:), ZLAI (:)
    REAL (KIND=JPRB) :: ZVI, ZV, Z0, ZA, ZL, ZR, ZU, ZFZ
    INTEGER (KIND=JPIM) :: JLOC2
    INTEGER (KIND=JPIM) :: IV
    TYPE (ATLAS_FIELD) :: YLF
    REAL (KIND=JPRB), PARAMETER :: ZEPS = 1.E-10_JPRB

    WRITE (CLMONTH, '(".m",I2.2)') IMONTH

    YLF = YLFSG2%FIELD ('z0v_GL'//TRIM (CLMONTH)); CALL YLF%DATA (ZZ0V); CALL YLF%FINAL ()
    YLF = YLFSG2%FIELD ('alv_GL'//TRIM (CLMONTH)); CALL YLF%DATA (ZALV); CALL YLF%FINAL ()
    YLF = YLFSG2%FIELD ('rsm_GL'//TRIM (CLMONTH)); CALL YLF%DATA (ZRSM); CALL YLF%FINAL ()
    YLF = YLFSG2%FIELD ('veg_GL'//TRIM (CLMONTH)); CALL YLF%DATA (ZVEG); CALL YLF%FINAL ()
    YLF = YLFSG2%FIELD ('lai_GL'//TRIM (CLMONTH)); CALL YLF%DATA (ZLAI); CALL YLF%FINAL ()

    WHERE (ZZ0V == ZUNDEF)
      ZZ0V = -100._JPRB
    ENDWHERE

    CALL INS2 (JSURFINDFOLIAIRE, IMONTH, NEWFLD (YLFSSC2, "SURFIND.FOLIAIRE" ))
    CALL INS2 (JSURFRESISTOMIN , IMONTH, NEWFLD (YLFSSC2, "SURFRESI.STO.MIN" ))
    CALL INS2 (JSURFGZ0THERM   , IMONTH, NEWFLD (YLFSSC2, "SURFGZ0.THERM   " ))
    CALL INS2 (JSURFZ0VEGFOISG , IMONTH, NEWFLD (YLFSSC2, "SURFZ0VEG.FOIS.G" ))
    CALL INS2 (JSURFALBEDOVEG  , IMONTH, NEWFLD (YLFSSC2, "SURFALBEDO.VEG  " ))
    CALL INS2 (JSURFPROPVEGETAT, IMONTH, CPYFLD (YLFL2 (JSURFPROPVEGETAT, 0)))

    ZFZ = SFCZ0 * RG

    DO JLOC2 = 1, YLFSSC2%SIZE_OWNED ()

!  Vegetation fraction (corrected with land fraction)

      ZVI = MAX (0.0_JPRB, MIN (1.0_JPRB, ZVEG (JLOC2)))
      ZV  = MIN (YLPT2 (JSURFPROPVEGETAT, 0)%ZDATA (JLOC2), ZVI * YLPT2 (JSURFPROPTERRE, 0)%ZDATA (JLOC2))
    
!  Roughness length of vegetation

      Z0  = EXP (ZZ0V (JLOC2))

!  Albedo of vegetation
      ZA  = ZALV (JLOC2)
      ZA  = MIN (SALBX, MAX (SALBN, ZA))
    
!  Leaf area index
      IF (ZLAI (JLOC2) /= ZUNDEF) THEN
        ZL = ZLAI (JLOC2)
      ELSE
        ZL = 0.0_JPRB
      ENDIF
    
!  Minimum surface resistance
      ZR  = ZL / MAX (ZRSM (JLOC2), ZEPS)
    
!  Set values over sea (no vegetation, albedo and roughness unchanged)
      IV  = NINT (YLPT2 (JSURFINDVEGDOMI, 0)%ZDATA (JLOC2))

      IF (IV == NTPMER .OR. IV == NTPLAC) THEN
        YLPT2 (JSURFPROPVEGETAT, IMONTH)%ZDATA (JLOC2) = 0.0_JPRB
        YLPT2 (JSURFINDFOLIAIRE, IMONTH)%ZDATA (JLOC2) = 0.0_JPRB
        YLPT2 (JSURFRESISTOMIN , IMONTH)%ZDATA (JLOC2) = SRSMX
        YLPT2 (JSURFGZ0THERM   , IMONTH)%ZDATA (JLOC2) = YLPT2 (JSURFZ0FOISG, 0)%ZDATA (JLOC2)
        YLPT2 (JSURFZ0VEGFOISG , IMONTH)%ZDATA (JLOC2) = 0.0_JPRB
        YLPT2 (JSURFALBEDOVEG  , IMONTH)%ZDATA (JLOC2) = SALBN
      ELSE
    
!  Correct if vegetation cover is not significant
        IF (IV == NTPGLA .OR. ZVI < SVEG) THEN
          ZV = 0.0_JPRB
          Z0 = SZZ0D
          ZA = SALBN
          ZL = 0.0_JPRB
          ZR = SRSMD
        ENDIF
    
!  Roughness length :
!  contributions from vegetation, urban areas and desert ; scaling
        ZU = YLPT2 (JSURFPROPURBANIS, 0)%ZDATA (JLOC2)

        Z0 = ZFZ * (ZV * Z0 + ZU * SZZ0U + (1.0_JPRB - ZU - ZV) * SZZ0D)
    
!  Final values
        
        YLPT2 (JSURFPROPVEGETAT, IMONTH)%ZDATA (JLOC2) = ZV
        YLPT2 (JSURFZ0FOISG    , IMONTH)%ZDATA (JLOC2) = SQRT (YLPT2 (JSURFZ0FOISG, 0)%ZDATA (JLOC2)**2 + Z0**2)
        YLPT2 (JSURFALBEDO     , IMONTH)%ZDATA (JLOC2) = MIN (SALBX, MAX (SALBN, (1.0_JPRB - ZV) * YLPT2 (JSURFALBEDO, 0)%ZDATA (JLOC2) + ZV * ZA))
        YLPT2 (JSURFINDFOLIAIRE, IMONTH)%ZDATA (JLOC2) = ZL
        YLPT2 (JSURFRESISTOMIN , IMONTH)%ZDATA (JLOC2) = MIN (SRSMX, MAX (SRSMN, ZR))
        YLPT2 (JSURFGZ0THERM   , IMONTH)%ZDATA (JLOC2) = Z0 * STHER

        YLPT2 (JSURFZ0VEGFOISG , IMONTH)%ZDATA (JLOC2) = Z0 
        YLPT2 (JSURFALBEDOVEG  , IMONTH)%ZDATA (JLOC2) = ZA
      ENDIF
    
    ENDDO


  ENDBLOCK
ENDDO

END SUBROUTINE

ELEMENTAL LOGICAL FUNCTION ISINF (P)

REAL (KIND=JPRB), INTENT (IN) :: P

ISINF = ABS (P) > HUGE (P)

END FUNCTION

SUBROUTINE INCLI3

USE ATLAS_FMT_N108, ONLY : ATLAS_FMT_N108_t


REAL (KIND=JPRB), PARAMETER :: RDTDZ1 = -6.5E-3_JPRB, ZGST = RDTDZ1 / RG

TYPE (ATLAS_FMT_N108_t), TARGET :: YLN108FM
TYPE (ATLAS_IO_GATHSCAT_t)      :: YLN108IO

TYPE (ATLAS_FIELDSET) :: YLFLDS108N1
TYPE (ATLAS_FIELDSET) :: YLFLDS108N2

TYPE (ATLAS_GRIDDISTRIBUTION) :: YLDIST108N
TYPE (ATLAS_STRUCTUREDGRID)   :: YLGRID108N
TYPE (ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS) :: YLFSSC108N

REAL (KIND=JPRB), POINTER :: ZLFRAC1 (:), ZOROGG1 (:), ZIFRAC1 (:)
TYPE (PTR) :: YLPTEMPG1 (12), YLPTEMPD1 (12), YLPTEMPS1 (12)

REAL (KIND=JPRB), POINTER :: ZLFRAC2 (:), ZOROGG2 (:), ZIFRAC2 (:)
TYPE (PTR) :: YLPTEMPG2 (12), YLPTEMPD2 (12), YLPTEMPS2 (12)

INTEGER (KIND=JPIM) :: JFLD, IMONTH

TYPE (INTERPOLATION4) :: YLINTE4

CHARACTER (LEN=16) :: CLNAME (39)
CHARACTER (LEN=4) :: CLMONTH

REAL (KIND=JPRB) :: SODELX (0:9)

REAL (KIND=JPRB) :: FOHU, FOWR, FOSN
REAL (KIND=JPRB) :: PTDARG, PHUARG, PXARG, PYARG
REAL (KIND=JPRB) :: ZNEI1, ZNEI2, ZNEI3, ZNEI4, ZNEI5
REAL (KIND=JPRB), PARAMETER :: ZEPS = 1.E-10_JPRB

#include "fcttrm.func.h"

! Relative humidity function (from Td and T).
FOHU (PTDARG, PTARG) = ES (PTDARG) / ES (PTARG)

! Soil relative water content function (from surface relative humidity).
FOWR (PHUARG) = ACOS (1.0_JPRB - 2.0_JPRB * PHUARG) / RPI

! Empirical snow climatology function.
FOSN (PXARG, PYARG) = MAX (0.0_JPRB, (ZNEI2 * PXARG) / (ZNEI3 - PXARG) &
& + ZNEI4 * (1.0_JPRB - COS (RPI * PYARG)) / 2.0_JPRB)  

!  to saturate the quantity of non-permanent snow.
ZNEI1 = 0.04_JPRB
!  Relative snow equivalent for a small partial permanent ice cover.
ZNEI2 = 10._JPRB
!  ZNEI2/(ZNEI3-1.) gives the maximum snow equivalent for total permanent
!  ice cover.
ZNEI3 = 1.0001_JPRB
!  Maximum non-permanent snow value.
ZNEI4 = 1000._JPRB
!  Permanent snow value on ice cap.
ZNEI5 = 10000._JPRB

BLOCK
  INTEGER (KIND=JPIM) :: J
  SODELX(0) =1.0_JPRB / SQRT (1.0_JPRB + 2.0_JPRB * RPI)
  DO J = 1, 9
    SODELX (J) = SODELX (J-1) * 2.0_JPRB * RPI
  ENDDO
ENDBLOCK

YLN108IO = ATLAS_IO_GATHSCAT_t (YLN108FM)

YLGRID108N = YLN108FM%GRID ('N108_GL')
CALL CREATE_DIST (YLGRID108N, YLDIST108N)

BLOCK
  TYPE (ATLAS_CONFIG) :: YLCONF
  YLCONF = ATLAS_CONFIG ()
  CALL YLCONF%SET ("halo", 1)
  YLFSSC108N = ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS (YLGRID108N, YLDIST108N, YLCONF)
  CALL YLCONF%FINAL ()
ENDBLOCK


CLNAME (1:3) = ['LFrac           ', 'OrogG           ', 'IFrac           ']

DO IMONTH = 1, 12
  WRITE (CLMONTH, '(".m",I2.2)') IMONTH
  CLNAME (3+(IMONTH-1)*3+1) = 'Temp_g'//CLMONTH
  CLNAME (3+(IMONTH-1)*3+2) = 'Temp_d'//CLMONTH
  CLNAME (3+(IMONTH-1)*3+3) = 'Temp_s'//CLMONTH
ENDDO

YLFLDS108N1 = YLN108IO%READ ('N108_GL', CLNAME, YLFSSC108N, PUNDEF=ZUNDEF)

BLOCK
  TYPE (ATLAS_FIELD) :: YLF
 
  YLF = YLFLDS108N1%FIELD ('LFrac'); CALL YLF%DATA (ZLFRAC1); CALL YLF%FINAL ()  
  YLF = YLFLDS108N1%FIELD ('OrogG'); CALL YLF%DATA (ZOROGG1); CALL YLF%FINAL ()  
  YLF = YLFLDS108N1%FIELD ('IFrac'); CALL YLF%DATA (ZIFRAC1); CALL YLF%FINAL ()  

  DO IMONTH = 1, 12
    WRITE (CLMONTH, '(".m",I2.2)') IMONTH
    YLF = YLFLDS108N1%FIELD ('Temp_g'//CLMONTH); CALL YLF%DATA (YLPTEMPG1 (IMONTH)%ZDATA); CALL YLF%FINAL ()
    YLF = YLFLDS108N1%FIELD ('Temp_d'//CLMONTH); CALL YLF%DATA (YLPTEMPD1 (IMONTH)%ZDATA); CALL YLF%FINAL ()
    YLF = YLFLDS108N1%FIELD ('Temp_d'//CLMONTH); CALL YLF%DATA (YLPTEMPS1 (IMONTH)%ZDATA); CALL YLF%FINAL ()
  ENDDO
ENDBLOCK

DO IMONTH = 1, 12
  YLPTEMPG1  (IMONTH)%ZDATA = YLPTEMPG1  (IMONTH)%ZDATA - ZGST * ZOROGG1
  YLPTEMPD1 (IMONTH)%ZDATA = YLPTEMPD1 (IMONTH)%ZDATA - ZGST * ZOROGG1
ENDDO

YLINTE4 = INTERPOLATION4 (YLDIST108N, YLFSSC108N, YLDIST2, YLFSSC2)

YLFLDS108N2 = YLINTE4%INTERPOLATE (YLFLDS108N1)

BLOCK
  TYPE (ATLAS_FIELD) :: YLF
 
  YLF = YLFLDS108N2%FIELD ('LFrac'); CALL YLF%DATA (ZLFRAC2); CALL YLF%FINAL ()  
  YLF = YLFLDS108N2%FIELD ('OrogG'); CALL YLF%DATA (ZOROGG2); CALL YLF%FINAL ()  
  YLF = YLFLDS108N2%FIELD ('IFrac'); CALL YLF%DATA (ZIFRAC2); CALL YLF%FINAL ()  

  DO IMONTH = 1, 12
    WRITE (CLMONTH, '(".m",I2.2)') IMONTH
    YLF = YLFLDS108N2%FIELD ('Temp_g'//CLMONTH); CALL YLF%DATA (YLPTEMPG2 (IMONTH)%ZDATA); CALL YLF%FINAL ()
    YLF = YLFLDS108N2%FIELD ('Temp_d'//CLMONTH); CALL YLF%DATA (YLPTEMPD2 (IMONTH)%ZDATA); CALL YLF%FINAL ()
    YLF = YLFLDS108N2%FIELD ('Temp_s'//CLMONTH); CALL YLF%DATA (YLPTEMPS2 (IMONTH)%ZDATA); CALL YLF%FINAL ()
  ENDDO
ENDBLOCK


BLOCK
  INTEGER (KIND=JPIM) :: JLOC2
  REAL (KIND=JPRB) :: ZTS, ZTD, ZHU, ZWR, ZXSN, ZYSN
  
  DO IMONTH = 1, 12
    CALL INS2 (JSURFTEMPERATURE, IMONTH, NEWFLD (YLFSSC2, "SURFTEMPERATURE" ))
    CALL INS2 (JPROFTEMPERATURE, IMONTH, NEWFLD (YLFSSC2, "PROFTEMPERATURE" ))
    CALL INS2 (JSURFPROPRMAXEA , IMONTH, NEWFLD (YLFSSC2, "SURFPROP.RMAX.EA"))
    CALL INS2 (JPROFPROPRMAXEA , IMONTH, NEWFLD (YLFSSC2, "PROFPROP.RMAX.EA"))
    CALL INS2 (JSURFRESERVNEIGE, IMONTH, NEWFLD (YLFSSC2, "SURFRESERV.NEIGE"))
    CALL INS2 (JRELATEMPERATURE, IMONTH, NEWFLD (YLFSSC2, "RELATEMPERATURE" ))
    CALL INS2 (JRELAPROPRMAXEA , IMONTH, NEWFLD (YLFSSC2, "RELAPROP.RMAX.EA"))

    CALL INS2 (JSURFALBEDO     , IMONTH, NEWFLD (YLFSSC2, "SURFALBEDO"      ))
    CALL INS2 (JSURFEMISSIVITE , IMONTH, NEWFLD (YLFSSC2, "SURFEMISSIVITE"  ))
    CALL INS2 (JSURFZ0FOISG    , IMONTH, NEWFLD (YLFSSC2, "SURFZ0.FOIS.G"   ))

    DO JLOC2 = 1, YLFSSC2%SIZE_OWNED ()
      IF (YLPT2 (JSURFINDTERREMER, 0)%ZDATA (JLOC2) >= SMASK) THEN
        ZTS = YLPTEMPG2 (IMONTH)%ZDATA (JLOC2) + ZGST * YLPT2 (JSURFGEOPOTENTIEL, 0)%ZDATA (JLOC2)
        ZTD = YLPTEMPD2 (IMONTH)%ZDATA (JLOC2) + ZGST * YLPT2 (JSURFGEOPOTENTIEL, 0)%ZDATA (JLOC2)
        YLPT2 (JSURFTEMPERATURE, IMONTH)%ZDATA (JLOC2) = ZTS
        ZHU = FOHU (MIN (ZTD, ZTS), ZTS)
        ZWR = FOWR (MAX (0.0_JPRB, MIN (1.0_JPRB, ZHU)))
        ZXSN = MAX (0.0_JPRB, MIN (1.0_JPRB, ZIFRAC2 (JLOC2) / MAX (ZEPS, ZLFRAC2 (JLOC2))))
        ZYSN = MAX (0.0_JPRB, MIN (1.0_JPRB, ZNEI1 * ZWR * (RTT-ZTS)))
        YLPT2 (JSURFPROPRMAXEA,  IMONTH)%ZDATA (JLOC2) = ZWR
        YLPT2 (JSURFRESERVNEIGE, IMONTH)%ZDATA (JLOC2) = FOSN (ZXSN, ZYSN)
      ELSE
        YLPT2 (JSURFTEMPERATURE, IMONTH)%ZDATA (JLOC2) = YLPTEMPS2 (IMONTH)%ZDATA (JLOC2) + ZGST * YLPT2 (JSURFGEOPOTENTIEL, 0)%ZDATA (JLOC2)
        YLPT2 (JSURFPROPRMAXEA,  IMONTH)%ZDATA (JLOC2) = 1.0_JPRB
        YLPT2 (JSURFRESERVNEIGE, IMONTH)%ZDATA (JLOC2) = 0.0_JPRB
      ENDIF
    ENDDO
  ENDDO
ENDBLOCK

BLOCK
  INTEGER (KIND=JPIM) :: JLOC2, IMONTH
  REAL (KIND=JPRB) :: ZTSHT, ZWSHT
  REAL (KIND=JPRB) :: ZRES (YLFSSC2%SIZE_OWNED (), 2*12)
  REAL (KIND=JPRB), PARAMETER :: PPWSHT = 0.1969_JPRB

  ZTSHT = (SODELX(0) + SODELX (1)) / (2.0_JPRB * SQRT (365._JPRB))
  CALL INCLAGA (YLPT2 (JSURFTEMPERATURE, 1:12), YLPT2 (JPROFTEMPERATURE, 1:12), ZTSHT)

  ZWSHT = PPWSHT
  CALL INCLAGA (YLPT2 (JSURFPROPRMAXEA , 1:12), YLPT2 (JPROFPROPRMAXEA , 1:12), ZWSHT)

!  No lag over sea
  DO IMONTH = 1, 12
    DO JLOC2 = 1, YLFSSC2%SIZE_OWNED ()
      IF (YLPT2 (JSURFINDTERREMER, 0)%ZDATA (JLOC2) < SMASK) THEN
        YLPT2 (JPROFTEMPERATURE, IMONTH)%ZDATA (JLOC2) = YLPT2 (JSURFTEMPERATURE, IMONTH)%ZDATA (JLOC2)
        YLPT2 (JPROFPROPRMAXEA , IMONTH)%ZDATA (JLOC2) = YLPT2 (JSURFPROPRMAXEA , IMONTH)%ZDATA (JLOC2)
      ENDIF
    ENDDO
  ENDDO

!  Relaxation temperature and moisture (new schemes)
  DO IMONTH = 1, 12
    YLPT2 (JRELATEMPERATURE, IMONTH)%ZDATA = YLPT2 (JPROFTEMPERATURE, IMONTH)%ZDATA 
    YLPT2 (JRELAPROPRMAXEA , IMONTH)%ZDATA = YLPT2 (JPROFPROPRMAXEA , IMONTH)%ZDATA 
  ENDDO

ENDBLOCK

BLOCK
  INTEGER (KIND=JPIM) :: IMONTH, JLOC2, ITP
  REAL (KIND=JPRB), POINTER :: ZALB, ZEMI, ZZ0G

  DO IMONTH = 1, 12
    DO JLOC2 = 1, YLFSSC2%SIZE_OWNED ()
      ITP = NINT (YLPT2 (JSURFINDVEGDOMI, 0)%ZDATA (JLOC2))
!  Increased snow fraction on ice-cap
      IF (ITP == NTPGLA) THEN
        YLPT2 (JSURFRESERVNEIGE, IMONTH)%ZDATA (JLOC2) = ZNEI5
      ELSE
        YLPT2 (JSURFRESERVNEIGE, IMONTH)%ZDATA (JLOC2) = MIN (ZNEI4, YLPT2 (JSURFRESERVNEIGE, IMONTH)%ZDATA (JLOC2))
      ENDIF
      ZALB => YLPT2 (JSURFALBEDO    , IMONTH)%ZDATA (JLOC2)
      ZEMI => YLPT2 (JSURFEMISSIVITE, IMONTH)%ZDATA (JLOC2)
      ZZ0G => YLPT2 (JSURFZ0FOISG   , IMONTH)%ZDATA (JLOC2)
!  On water : albedo, emissivity and roughness length
      IF (ITP == NTPMER .OR. ITP == NTPLAC) THEN
        IF (YLPT2 (JSURFTEMPERATURE, IMONTH)%ZDATA (JLOC2) <= TMERGL) THEN
          ZALB = SALBB
          ZEMI = SEMIB
          ZZ0G = SZZ0B * RG
        ELSE
          ZALB = SALBM
          ZEMI = SEMIM
          ZZ0G = SZZ0M * RG
        ENDIF
      ELSE
        ZALB = YLPT2 (JSURFALBEDO    , 0)%ZDATA (JLOC2)
        ZEMI = YLPT2 (JSURFEMISSIVITE, 0)%ZDATA (JLOC2)
        ZZ0G = YLPT2 (JSURFZ0FOISG   , 0)%ZDATA (JLOC2)
      ENDIF
    ENDDO
  ENDDO
ENDBLOCK

CALL YLFAIO%WRITE ('N108', YLFLDS108N2, YLFSSC2)

END SUBROUTINE

SUBROUTINE INCLAGA (YDSURF, YDPROF, PSHT)

TYPE (PTR) :: YDSURF (:)
TYPE (PTR) :: YDPROF (:)
REAL (KIND=JPRB), INTENT (IN) :: PSHT

#include "inclag.intfb.h"

INTEGER (KIND=JPIM) :: JLOC2, IMONTH, NGPTOT2
REAL (KIND=JPRB) :: ZTSHT
REAL (KIND=JPRB) :: ZRES (YLFSSC2%SIZE_OWNED (), 2*12)

NGPTOT2 = YLFSSC2%SIZE_OWNED () 

DO IMONTH = 1, 12
  DO JLOC2 = 1, NGPTOT2
    ZRES (JLOC2, 1+2*(IMONTH-1)) = YDSURF (IMONTH)%ZDATA (JLOC2) 
  ENDDO
ENDDO

CALL INCLAG (ZRES, PSHT, NGPTOT2, NGPTOT2, 2*12_JPIM, 2_JPIM)

DO IMONTH = 1, 12
  DO JLOC2 = 1, NGPTOT2
    YDPROF (IMONTH)%ZDATA (JLOC2) = ZRES (JLOC2, 2+2*(IMONTH-1))
  ENDDO
ENDDO

END SUBROUTINE INCLAGA


SUBROUTINE INCLI1

USE ATLAS_IO_DH, ONLY : ATLAS_IO_DH_t

TYPE (ATLAS_IO_DH_t)                      :: YLDHIO

TYPE (ATLAS_GRIDDISTRIBUTION)             :: YLDIST1
TYPE (ATLAS_STRUCTUREDGRID)               :: YLGRID1

! Grids of input files

TYPE (ATLAS_STRUCTUREDGRID)               :: YLGRID_OROG
TYPE (ATLAS_STRUCTUREDGRID)               :: YLGRID_SABL
TYPE (ATLAS_STRUCTUREDGRID)               :: YLGRID_ARGI
TYPE (ATLAS_STRUCTUREDGRID)               :: YLGRID_COVR


TYPE (ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS) :: YLFSSC1

! Interpolation (source grid -> target grid)

TYPE (INTERPOLATIONA)                        :: YLINTEA

TYPE (ATLAS_FIELDSET) :: YLCOVR2S, YLAOSP2S
TYPE (ATLAS_FIELD)    :: YLOROG1, YLARGI1, YLSABL1, YLCOVR1
REAL (KIND=JPRB), POINTER, DIMENSION (:) :: ZOROG1, ZARGI1, ZSABL1, ZCOVR1

YLDHIO = ATLAS_IO_DH_t (YLGRID2)

! Create source grids & check compatibility

YLGRID_OROG = YLDHIO%GRID ("SURFGEOPOTENTIEL")
YLGRID_ARGI = YLDHIO%GRID ("SURFPROP.ARGILE" )
YLGRID_SABL = YLDHIO%GRID ("SURFPROP.SABLE"  )
YLGRID_COVR = YLDHIO%GRID ("SFX.COVER"       )

IF (.NOT. (GRID_EQ (YLGRID_OROG, YLGRID_ARGI))) CALL ATLAS_ABORT ("GEOMETRY MISMATCH")
IF (.NOT. (GRID_EQ (YLGRID_OROG, YLGRID_SABL))) CALL ATLAS_ABORT ("GEOMETRY MISMATCH")
IF (.NOT. (GRID_EQ (YLGRID_OROG, YLGRID_COVR))) CALL ATLAS_ABORT ("GEOMETRY MISMATCH")

YLGRID1 = YLGRID_OROG

CALL CREATE_DIST (YLGRID1, YLDIST1, .TRUE.)

! Not needed anymore, finalize

CALL YLGRID_OROG%FINAL ()
CALL YLGRID_ARGI%FINAL ()
CALL YLGRID_SABL%FINAL ()
CALL YLGRID_COVR%FINAL ()

BLOCK
  TYPE (ATLAS_CONFIG) :: YLCONF
  YLCONF = ATLAS_CONFIG ()
  CALL YLCONF%SET ("halo", 1)
  YLFSSC1 = ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS (YLGRID1, YLDIST1, YLCONF)
  CALL YLCONF%FINAL ()
ENDBLOCK

! Create interpolation object (source -> target)

YLINTEA = INTERPOLATIONA (YLDIST1, YLFSSC1, YLDIST2, YLFSSC2, LDOPENMP=.TRUE.)

! Read input fields on source geometry

YLOROG1 = RNS1 (YLDHIO, YLFSSC1, "SURFGEOPOTENTIEL", PSCALE=RG); CALL YLOROG1%DATA (ZOROG1)
YLARGI1 = RNS1 (YLDHIO, YLFSSC1, "SURFPROP.ARGILE"            ); CALL YLARGI1%DATA (ZARGI1)
YLSABL1 = RNS1 (YLDHIO, YLFSSC1, "SURFPROP.SABLE"             ); CALL YLSABL1%DATA (ZSABL1)
YLCOVR1 = RNS1 (YLDHIO, YLFSSC1, "SFX.COVER"                  ); CALL YLCOVR1%DATA (ZCOVR1)

YLCOVR2S = ATLAS_COMPUTE_COVERS (YLFSSC1, YLFSSC2, YLCOVR1, YLINTEA, LDOPENMP=.TRUE.) 

! Set missing values of orography

!$OMP WORKSHARE
WHERE (ZCOVR1 == 1._JPRB) ! Sea 
  ZOROG1 = ZUNDEF
ENDWHERE
!$OMP END WORKSHARE

CALL INS2 (JSURFINDTERREMER, 0, NEWFLD (YLFSSC2, "SURFIND.TERREMER"))

BLOCK
  TYPE (ATLAS_FIELD) :: YLCOVR2
  REAL (KIND=JPRB), POINTER :: ZCOVR2 (:)

  YLCOVR2 = YLCOVR2S%FIELD ("COVER001")
  CALL YLCOVR2%DATA (ZCOVR2)

!$OMP WORKSHARE
  WHERE (ZCOVR2 > SMASK)
    YLPT2 (JSURFINDTERREMER, 0)%ZDATA = 0._JPRB
  ELSE WHERE
    YLPT2 (JSURFINDTERREMER, 0)%ZDATA = 1._JPRB
  END WHERE
!$OMP END WORKSHARE

  CALL YLCOVR2%FINAL ()

ENDBLOCK

! Interpolate fields using box averaging

BLOCK
  TYPE (ATLAS_FIELDSET) :: YLFLDS1
  TYPE (ATLAS_FIELDSET) :: YLFLDS2I

  YLFLDS1 = ATLAS_FIELDSET ()

  CALL YLFLDS1%ADD (YLOROG1)
  CALL YLFLDS1%ADD (YLARGI1)
  CALL YLFLDS1%ADD (YLSABL1)
  YLFLDS2I = YLINTEA%INTERPOLATE (YLFLDS1)
  CALL YLFLDS1%FINAL ()

! Insert interpolated fields in the list of fields of target geometry

  CALL INS2 (JSURFGEOPOTENTIEL, 0, YLFLDS2I%FIELD ("SURFGEOPOTENTIEL"))
  CALL INS2 (JSURFPROPSABLE   , 0, YLFLDS2I%FIELD ("SURFPROP.SABLE"  ))
  CALL INS2 (JSURFPROPARGILE  , 0, YLFLDS2I%FIELD ("SURFPROP.ARGILE" ))

  CALL YLFLDS2I%FINAL ()
ENDBLOCK

BLOCK
  TYPE (ATLAS_FIELDSET) :: YLFLDS2SSO
  TYPE (ATLAS_FIELD)    :: YLFLD2

  YLFLDS2SSO = ATLAS_COMPUTE_SSO (YLFSSC1, YLFSSC2, YLOROG1, YLFL2 (JSURFGEOPOTENTIEL, 0), YLINTEA, LDOPENMP=.TRUE., LDROTATE=.TRUE.) 

  YLFLD2 = YLFLDS2SSO%FIELD ("SSO_DIR"  ); CALL YLFLD2%RENAME ("SURFVAR.GEOP.DIR"); CALL INS2 (JSURFVARGEOPDIR , 0, YLFLD2)
  YLFLD2 = YLFLDS2SSO%FIELD ("SSO_ANIS" ); CALL YLFLD2%RENAME ("SURFVAR.GEOP.ANI"); CALL INS2 (JSURFVARGEOPANI , 0, YLFLD2)
  YLFLD2 = YLFLDS2SSO%FIELD ("SSO_STDEV"); CALL YLFLD2%RENAME ("SURFET.GEOPOTENT"); CALL INS2 (JSURFETGEOPOTENT, 0, YLFLD2)


!$OMP WORKSHARE
  WHERE (YLPT2 (JSURFVARGEOPANI, 0)%ZDATA /= ZUNDEF)
    YLPT2 (JSURFVARGEOPANI, 0)%ZDATA (:) = YLPT2 (JSURFVARGEOPANI, 0)%ZDATA (:) ** 2
  END WHERE
!$OMP END WORKSHARE

!$OMP WORKSHARE
  WHERE (YLPT2 (JSURFVARGEOPDIR, 0)%ZDATA /= ZUNDEF)
    YLPT2 (JSURFVARGEOPDIR, 0)%ZDATA (:) = YLPT2 (JSURFVARGEOPDIR, 0)%ZDATA (:) * RPI / 180._JPRB
  END WHERE
!$OMP END WORKSHARE

ENDBLOCK

! Add enveloppe

!$OMP WORKSHARE 
  WHERE (YLPT2 (JSURFGEOPOTENTIEL, 0)%ZDATA (:) /= ZUNDEF)
    YLPT2 (JSURFGEOPOTENTIEL, 0)%ZDATA (:) = YLPT2 (JSURFGEOPOTENTIEL, 0)%ZDATA (:) + YLPT2 (JSURFETGEOPOTENT, 0)%ZDATA
  ENDWHERE
!$OMP END WORKSHARE

BLOCK
  TYPE (INTERPOLATION4) :: YLINTE4
  REAL (KIND=JPRB) :: ZLOC2 (YLFSSC2%SIZE ())
  REAL (KIND=JPRB), POINTER, DIMENSION (:) :: ZAOSIP2, ZAOSIM2, ZAOSJP2, ZAOSJM2, &
                                            & ZHO2IP2, ZHO2IM2, ZHO2JP2, ZHO2JM2
  TYPE (ATLAS_FIELD) :: YLFLD2

  YLINTE4 = INTERPOLATION4 (YLDIST2, YLFSSC2, YLDIST1, YLFSSC1)
  YLAOSP2S = ATLAS_COMPUTE_AOS (YLFSSC1, YLFSSC2, YLOROG1, YLFL2 (JSURFGEOPOTENTIEL, 0), YLINTEA, YLINTE4, LDOPENMP=.TRUE.) 

#define GF(n, z) YLFLD2 = YLAOSP2S%FIELD (#n); CALL YLFLD2%DATA (z); CALL YLFLD2%FINAL ()
  GF (AOSIP, ZAOSIP2)
  GF (AOSIM, ZAOSIM2)
  GF (AOSJP, ZAOSJP2)
  GF (AOSJM, ZAOSJM2)
  GF (HO2IP, ZHO2IP2)
  GF (HO2IM, ZHO2IM2)
  GF (HO2JP, ZHO2JP2)
  GF (HO2JM, ZHO2JM2)
#undef GF

  CALL INS2 (JSURFZ0RELFOISG, 0, NEWFLD (YLFSSC2, "SURFZ0REL.FOIS.G" ))
  CALL INS2 (JSURFZ0FOISG,    0, NEWFLD (YLFSSC2, "SURFZ0.FOIS.G"    ))

  WHERE (YLPT2 (JSURFGEOPOTENTIEL, 0)%ZDATA /= ZUNDEF)
    ZLOC2 (:) = 0.25_JPRB * XCDZ0EFF / (2._JPRB * XKARMAN**2) &
            & * (ZAOSIP2 (:) + ZAOSIM2 (:) + ZAOSJP2 (:) + ZAOSJM2 (:))        
    WHERE (ZLOC2 (:) > 0._JPRB)
      YLPT2 (JSURFZ0RELFOISG, 0)%ZDATA = 0.25_JPRB * (ZHO2IP2 (:) + ZHO2IM2 (:) + ZHO2JP2 (:) + ZHO2JM2 (:)) &
                              & * EXP (-SQRT (1._JPRB / ZLOC2 (:)))
      YLPT2 (JSURFZ0RELFOISG, 0)%ZDATA = MAX (YLPT2 (JSURFZ0RELFOISG, 0)%ZDATA (:), 1E-10_JPRB)
    ELSEWHERE
      YLPT2 (JSURFZ0RELFOISG, 0)%ZDATA = 0._JPRB
    END WHERE
  ELSE WHERE
    YLPT2 (JSURFZ0RELFOISG, 0)%ZDATA = ZUNDEF
  END WHERE

  YLPT2 (JSURFZ0FOISG, 0)%ZDATA = YLPT2 (JSURFZ0RELFOISG, 0)%ZDATA

  CALL YLINTE4%FINAL ()
ENDBLOCK

CALL COMPUTE_FRACTIONS (YLCOVR2S)

! Fix missing values: orography parameters, set to zero

BLOCK
  INTEGER (KIND=JPIM) :: IZS (6), JFLD
  IZS = [JSURFGEOPOTENTIEL,  JSURFVARGEOPDIR, JSURFVARGEOPANI,  JSURFETGEOPOTENT, JSURFZ0RELFOISG, JSURFZ0FOISG]

  DO JFLD = 1, SIZE (IZS)
!$OMP WORKSHARE 
    WHERE (YLPT2 (IZS (JFLD), 0)%ZDATA == ZUNDEF)
      YLPT2 (IZS (JFLD), 0)%ZDATA = 0._JPRB
    ENDWHERE
!$OMP END WORKSHARE
  ENDDO

ENDBLOCK

! Fix missing values : clay & sand

!$OMP WORKSHARE
WHERE (YLPT2 (JSURFPROPSABLE, 0)%ZDATA == ZUNDEF)
  YLPT2 (JSURFPROPSABLE, 0)%ZDATA = 0._JPRB
END WHERE
!$OMP END WORKSHARE
!$OMP WORKSHARE
WHERE (YLPT2 (JSURFPROPARGILE, 0)%ZDATA == ZUNDEF)
  YLPT2 (JSURFPROPARGILE, 0)%ZDATA = 0._JPRB
END WHERE
!$OMP END WORKSHARE

CALL YLCOVR2S%FINAL ()
CALL YLAOSP2S%FINAL ()
CALL YLOROG1%FINAL ()
CALL YLARGI1%FINAL ()
CALL YLSABL1%FINAL ()
CALL YLCOVR1%FINAL ()
CALL YLINTEA%FINAL ()
CALL YLGRID1%FINAL ()
CALL YLDIST1%FINAL ()
CALL YLFSSC1%FINAL ()

END SUBROUTINE INCLI1

SUBROUTINE INCLI2

USE ATLAS_FMT_SOIL_AND_VEG, ONLY : ATLAS_FMT_SOIL_AND_VEG_t

TYPE (INTERPOLATION4) :: YLINTEG
TYPE (ATLAS_FIELDSET) :: YLFSG1, YLFSG2
TYPE (ATLAS_FIELD) :: YLF

TYPE (ATLAS_IO_GATHSCAT_t)                :: YLFBIO
TYPE (ATLAS_FMT_SOIL_AND_VEG_t),   TARGET :: YLFMFB
TYPE (ATLAS_STRUCTUREDGRID)               :: YLGRIDG

TYPE (ATLAS_GRIDDISTRIBUTION)                :: YLDISTG
TYPE (ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS) :: YLFSSCG

INTEGER (KIND=JPIM) :: IDITP (5)
CHARACTER (LEN=16) :: CLNAMG (14)
INTEGER (KIND=JPIM) :: JFLD
TYPE (PTR), ALLOCATABLE :: YLPTG2 (:)
INTEGER (KIND=JPIM) :: Jwpl_GL, Jtpl_GL, Jsnl_GL, Jz0v_GL, Jvgx_GL, Jsab_GL, Jrsm_GL
INTEGER (KIND=JPIM) :: Jitp_GL, Jemi_GL, Jdps_GL, Jdpr_GL, Jarg_GL, Jalv_GL, Jalb_GL
INTEGER (KIND=JPIM) :: Jitp1GL, Jitp2GL, Jitp3GL, Jitp4GL, Jitp5GL
INTEGER (KIND=JPIM) :: INFLD2

INFLD2 = 0

#define ADDFLD(J) INFLD2 = INFLD2 + 1; J = INFLD2

ADDFLD (Jwpl_GL      ); ADDFLD (Jtpl_GL     ); ADDFLD (Jsnl_GL     ); ADDFLD (Jz0v_GL     ); 
ADDFLD (Jvgx_GL      ); ADDFLD (Jsab_GL     ); ADDFLD (Jrsm_GL     ); ADDFLD (Jitp_GL     ); 
ADDFLD (Jemi_GL      ); ADDFLD (Jdps_GL     ); ADDFLD (Jdpr_GL     ); ADDFLD (Jarg_GL     ); 
ADDFLD (Jalv_GL      ); ADDFLD (Jalb_GL     );
ADDFLD (Jitp1GL      ); ADDFLD (Jitp2GL     ); ADDFLD (Jitp3GL     ); ADDFLD (Jitp4GL     ); 
ADDFLD (Jitp5GL      ); 

#undef ADDFLD

ALLOCATE (YLPTG2 (INFLD2))

YLFBIO = ATLAS_IO_GATHSCAT_t (YLFMFB)

YLGRIDG = YLFMFB%GRID ("wpl_GL")

CALL CREATE_DIST (YLGRIDG, YLDISTG)

BLOCK
  TYPE (ATLAS_CONFIG) :: YLCONF
  YLCONF = ATLAS_CONFIG ()
  CALL YLCONF%SET ("halo", 1)
  YLFSSCG = ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS (YLGRIDG, YLDISTG, YLCONF)
  CALL YLCONF%FINAL ()
ENDBLOCK

CLNAMG = ['wpl_GL          ', 'tpl_GL          ', 'snl_GL          ', 'z0v_GL          ', &
       &  'vgx_GL          ', 'sab_GL          ', 'rsm_GL          ', 'itp_GL          ', &
       &  'emi_GL          ', 'dps_GL          ', 'dpr_GL          ', 'arg_GL          ', &
       &  'alv_GL          ', 'alb_GL          ']

YLINTEG = INTERPOLATION4 (YLDISTG, YLFSSCG, YLDIST2, YLFSSC2)

YLFSG1 = YLFBIO%READ ('', CLNAMG, YLFSSCG, PUNDEF=ZUNDEF)

! Create fields of density for each type

BLOCK
  TYPE (PTR) :: YLITP (5)
  TYPE (ATLAS_FIELD) :: YLITP1
  REAL (KIND=JPRB), POINTER :: ZITP1 (:)
  INTEGER (KIND=JPIM) :: JLOC1, JTYP1

  DO JFLD = 1, 5
    BLOCK
      TYPE (ATLAS_FIELD) :: YLF
      CHARACTER (LEN=16) :: CLNAME
      WRITE (CLNAME, '("itp_GL.",I3.3)') JFLD
      YLF = NEWFLD (YLFSSCG, CLNAME, ZUNDEF)
      CALL YLFSG1%ADD (YLF)
      CALL YLF%DATA (YLITP (JFLD)%ZDATA)
      YLITP (JFLD)%ZDATA = 0._JPRB
      CALL YLF%FINAL ()
    ENDBLOCK
  ENDDO

  YLITP1 = YLFSG1%FIELD ('itp_GL')
  CALL YLITP1%DATA (ZITP1)
  DO JLOC1 = 1, YLFSSCG%SIZE_OWNED ()
    JTYP1 = NINT (ZITP1 (JLOC1))
    IF ((JTYP1 < 1) .OR. (5 < JTYP1)) THEN
      WRITE (0, *) 'ATLAS_CLIM: UNEXPECTED VALUE FOR itp_GL: ', JLOC1, JTYP1, ZITP1 (JLOC1)
      CALL ATLAS_ABORT ('ATLAS_CLIM: UNEXPECTED VALUE FOR itp_GL')
    ENDIF
    YLITP (JTYP1)%ZDATA (JLOC1) = 1._JPRB
  ENDDO
  CALL YLITP1%FINAL ()
ENDBLOCK

YLFSG2 = YLINTEG%INTERPOLATE (YLFSG1)

! Add to final list

DO JFLD = 1, YLFSG2%SIZE ()
  YLF = YLFSG2%FIELD (JFLD)
  CALL YLF%DATA (YLPTG2 (JFLD)%ZDATA)
  CALL YLF%FINAL ()
ENDDO

IDITP = [Jitp1GL, Jitp2GL, Jitp3GL, Jitp4GL, Jitp5GL]

YLF = YLFSG2%FIELD ('alb_GL'); CALL YLF%RENAME ('SURFALBEDO.SOLNU'); CALL INS2 (JSURFALBEDOSOLNU, 0, YLF); CALL YLF%FINAL ()
YLF = YLFSG2%FIELD ('emi_GL'); CALL YLF%RENAME ('SURFEMISSIVITE'  ); CALL INS2 (JSURFEMISSIVITE , 0, YLF); CALL YLF%FINAL ()
YLF = YLFSG2%FIELD ('dps_GL'); CALL YLF%RENAME ('SURFEPAI.SOL.MAX'); CALL INS2 (JSURFEPAISOLMAX , 0, YLF); CALL YLF%FINAL ()

! Find vegetation dominant index

CALL INS2 (JSURFINDVEGDOMI, 0, NEWFLD (YLFSSC2, 'SURFIND.VEG.DOMI'))

BLOCK
  REAL (KIND=JPRB) :: IVS, IVD, ZITP
  REAL (KIND=JPRB) :: ZMAX1, ZMAX2
  INTEGER (KIND=JPIM) :: JLOC2, JT, ILSM

  DO JLOC2 = 1, YLFSSC2%SIZE_OWNED ()

    ZMAX1 = 0.0_JPRB; ZMAX2 = 0.0_JPRB
    IVD   = 0_JPIM  ; IVS   = 0_JPIM

    DO JT = 1, 5
      ZITP = YLPTG2 (IDITP (JT))%ZDATA (JLOC2)
      IF (ZITP > ZMAX1) THEN
        ZMAX1 = ZITP
        IVD = JT
      ENDIF
    ENDDO
    DO JT = 1, 5
      IF (JT == IVD) CYCLE
      ZITP = YLPTG2 (IDITP (JT))%ZDATA (JLOC2)
      IF (ZITP > ZMAX2) THEN
        ZMAX2 = ZITP
        IVS = JT
      ENDIF
    ENDDO

    ILSM = NINT (YLPT2 (JSURFINDTERREMER, 0)%ZDATA (JLOC2))

    IF (ILSM == 0 .AND. IVD /= NTPLAC) IVD = NTPMER
    IF ((IVD == NTPMER .OR. IVD == NTPLAC) .AND. (ILSM == 1)) THEN
      IF (IVS == 0) THEN
        IVD = NTPDES
      ELSE
        IVD = IVS
      ENDIF
    ENDIF

    YLPT2 (JSURFINDVEGDOMI, 0)%ZDATA (JLOC2) = REAL (IVD, JPRB)

  ENDDO
ENDBLOCK

CALL INS2 (JSURFEPAISSOL,    0, NEWFLD (YLFSSC2, 'SURFEPAIS.SOL'   ))
CALL INS2 (JSURFPROPVEGMAX,  0, NEWFLD (YLFSSC2, 'SURFPROP.VEG.MAX'))
CALL INS2 (JSURFPROPVEGETAT, 0, NEWFLD (YLFSSC2, 'SURFPROP.VEGETAT'))

BLOCK
  INTEGER (KIND=JPIM) :: JLOC2
  TYPE (ATLAS_FIELD) :: YLVGX, YLDPR
  REAL (KIND=JPRB), POINTER :: ZVGX (:), ZDPR (:)
  REAL (KIND=JPRB) :: ZV, ZD, ZEPAISOLMAX
  REAL (KIND=JPRB), PARAMETER :: SVEG = 0.02_JPRB
  YLVGX = YLFSG2%FIELD ('vgx_GL'); CALL YLVGX%DATA (ZVGX)
  YLDPR = YLFSG2%FIELD ('dpr_GL'); CALL YLDPR%DATA (ZDPR)
  DO JLOC2 = 1, YLFSSC2%SIZE_OWNED ()
    ZV = ZVGX (JLOC2)
    ZD = ZDPR (JLOC2)
    ZV = MAX (0.0_JPRB, MIN (1.0_JPRB, ZV))
    IF (ZV < SVEG) ZV = 0.0_JPRB
    ZEPAISOLMAX = YLPT2 (JSURFEPAISOLMAX, 0)%ZDATA (JLOC2)
    YLPT2 (JSURFEPAISSOL   , 0)%ZDATA (JLOC2) = ZV * MIN (ZD, ZEPAISOLMAX) &
                                              & + (1.0_JPRB - ZV) * ZEPAISOLMAX 
    YLPT2 (JSURFPROPVEGMAX , 0)%ZDATA (JLOC2) = ZV
    YLPT2 (JSURFPROPVEGETAT, 0)%ZDATA (JLOC2) = ZV
  ENDDO
  CALL YLVGX%FINAL ()
  CALL YLDPR%FINAL ()
ENDBLOCK  

! Final calculations

BLOCK
  INTEGER (KIND=JPIM) :: JLOC2
  INTEGER (KIND=JPIM) :: IV

  REAL (KIND=JPRB), PARAMETER :: SALBG =  0.75_JPRB, SALBM =  0.07_JPRB, SARGN =  3.00_JPRB, &
                               & SDEPN =  0.10_JPRB, SDEPX =  8.00_JPRB, SEMIG =  0.98_JPRB, &
                               & SEMIN =  0.90_JPRB, SSABN =  6.00_JPRB, SARGX = 58.00_JPRB, &
                               & SALBN =  0.05_JPRB, SALBX =  0.80_JPRB, SEMIX =  1.00_JPRB, &
                               & SEMIM =  0.96_JPRB, SSABX = 92.00_JPRB

  DO JLOC2 = 1, YLFSSC2%SIZE_OWNED ()
    IV = NINT (YLPT2 (JSURFINDVEGDOMI, 0)%ZDATA (JLOC2))
    IF (IV < 1 .OR. IV > 5) THEN
      WRITE (0, *) 'UNEXPECTED VEGETATION INDEX', JLOC2, IV
      CALL ATLAS_ABORT ('UNEXPECTED VEGETATION INDEX')
    ENDIF
    SELECT CASE (IV)
      CASE (NTPMER, NTPLAC)

        YLPT2 (JSURFALBEDOSOLNU, 0)%ZDATA (JLOC2) = SALBM
        YLPT2 (JSURFEMISSIVITE , 0)%ZDATA (JLOC2) = SEMIM
        YLPT2 (JSURFEPAISOLMAX , 0)%ZDATA (JLOC2) = SDEPX
        YLPT2 (JSURFPROPARGILE , 0)%ZDATA (JLOC2) = SARGN
        YLPT2 (JSURFPROPSABLE  , 0)%ZDATA (JLOC2) = SSABN
        YLPT2 (JSURFPROPVEGMAX , 0)%ZDATA (JLOC2) = 0.0_JPRB
        YLPT2 (JSURFEPAISSOL   , 0)%ZDATA (JLOC2) = SDEPX
        YLPT2 (JSURFPROPURBANIS, 0)%ZDATA (JLOC2) = 0.0_JPRB

      CASE (NTPGLA) 
      
        YLPT2 (JSURFALBEDOSOLNU, 0)%ZDATA (JLOC2) = SALBG
        YLPT2 (JSURFEMISSIVITE , 0)%ZDATA (JLOC2) = SEMIG
        YLPT2 (JSURFEPAISOLMAX , 0)%ZDATA (JLOC2) = SDEPN
        YLPT2 (JSURFPROPARGILE , 0)%ZDATA (JLOC2) = SARGN
        YLPT2 (JSURFPROPSABLE  , 0)%ZDATA (JLOC2) = SSABN
        YLPT2 (JSURFPROPVEGMAX , 0)%ZDATA (JLOC2) = 0.0_JPRB
        YLPT2 (JSURFEPAISSOL   , 0)%ZDATA (JLOC2) = SDEPN
        YLPT2 (JSURFPROPURBANIS, 0)%ZDATA (JLOC2) = 0.0_JPRB

      CASE DEFAULT

        BLOCK
          REAL (KIND=JPRB) :: ZZARG, ZZSAB, ZSUM

          ZZARG = MAX (SARGN, MIN (SARGX, YLPT2 (JSURFPROPARGILE , 0)%ZDATA (JLOC2)))
          ZZSAB = MAX (SSABN, MIN (SSABX, YLPT2 (JSURFPROPSABLE  , 0)%ZDATA (JLOC2)))
          ZSUM  = MAX (100._JPRB, ZZARG + ZZSAB) / 100._JPRB

          YLPT2 (JSURFALBEDOSOLNU, 0)%ZDATA (JLOC2) = MAX (SALBN,MIN (SALBX, YLPT2 (JSURFALBEDOSOLNU, 0)%ZDATA (JLOC2)))
          YLPT2 (JSURFEMISSIVITE , 0)%ZDATA (JLOC2) = MAX (SEMIN,MIN (SEMIX, YLPT2 (JSURFEMISSIVITE , 0)%ZDATA (JLOC2)))
          YLPT2 (JSURFEPAISOLMAX , 0)%ZDATA (JLOC2) = MAX (SDEPN,MIN (SDEPX, YLPT2 (JSURFEPAISOLMAX , 0)%ZDATA (JLOC2)))
          YLPT2 (JSURFPROPARGILE , 0)%ZDATA (JLOC2) = ZZARG / ZSUM
          YLPT2 (JSURFPROPSABLE  , 0)%ZDATA (JLOC2) = ZZSAB / ZSUM
          YLPT2 (JSURFPROPVEGMAX , 0)%ZDATA (JLOC2) = YLPT2 (JSURFPROPVEGMAX, 0)%ZDATA (JLOC2) * YLPT2 (JSURFPROPTERRE, 0)%ZDATA (JLOC2)
          YLPT2 (JSURFEPAISSOL   , 0)%ZDATA (JLOC2) = MAX (SDEPN, MIN (YLPT2 (JSURFEPAISOLMAX , 0)%ZDATA (JLOC2), YLPT2 (JSURFEPAISSOL   , 0)%ZDATA (JLOC2)))
          YLPT2 (JSURFPROPURBANIS, 0)%ZDATA (JLOC2) = MIN (1.0_JPRB - YLPT2 (JSURFPROPVEGMAX , 0)%ZDATA (JLOC2), YLPT2 (JSURFPROPURBANIS, 0)%ZDATA (JLOC2))
        ENDBLOCK

    END SELECT
  ENDDO
ENDBLOCK

! Other albedo fields
CALL INS2 (JSURFALBEDO     , 0, NEWFLD (YLFSSC2, 'SURFALBEDO'      ))
CALL INS2 (JSURFALBEDOCOMPL, 0, NEWFLD (YLFSSC2, 'SURFALBEDO.COMPL'))

!$OMP WORKSHARE
YLPT2 (JSURFALBEDO     , 0)%ZDATA = YLPT2 (JSURFALBEDOSOLNU, 0)%ZDATA
!$OMP END WORKSHARE
!$OMP WORKSHARE
YLPT2 (JSURFALBEDOCOMPL, 0)%ZDATA = YLPT2 (JSURFALBEDOSOLNU, 0)%ZDATA
!$OMP END WORKSHARE


CALL YLFSG1 %FINAL ()
CALL YLFSG2 %FINAL ()
CALL YLINTEG%FINAL ()
CALL YLGRIDG%FINAL ()
CALL YLDISTG%FINAL ()
CALL YLFSSCG%FINAL ()

END SUBROUTINE INCLI2

SUBROUTINE COMPUTE_FRACTIONS (YDCOVR2S)

TYPE (ATLAS_FIELDSET) :: YDCOVR2S

TYPE (ATLAS_FIELD) :: YLFL2COV (INCOVR)
REAL (KIND=JPRB) :: ZFRAC_MER (YLFSSC2%SIZE ()), ZFRAC_EAU (YLFSSC2%SIZE ())
TYPE (COVERS_t) :: YLCOVERS
LOGICAL, ALLOCATABLE :: LCOVER (:)
INTEGER (KIND=JPIM) :: ICOVR

REAL (KIND=JPRB) :: ZAVGCOVR2 (INCOVR)
REAL (KIND=JPRB) :: ZMINCOVR2 (INCOVR)
REAL (KIND=JPRB) :: ZMAXCOVR2 (INCOVR)

DO ICOVR = 1, INCOVR
  YLFL2COV (ICOVR) = YDCOVR2S%FIELD (ICOVR)
ENDDO

! Create fractions fields

CALL INS2 (JSURFPROPURBANIS, 0, NEWFLD (YLFSSC2, "SURFPROP.URBANIS" ))
CALL INS2 (JSURFPROPTERRE,   0, NEWFLD (YLFSSC2, "SURFPROP.TERRE"   ))
CALL READCOVERS (YLCOVERS, 1, LGARDEN, LWATER_TO_NATURE, LTOWN_TO_ROCK)
CALL FIELDSTAT (YLFSSC2, YLFL2COV, PMIN=ZMINCOVR2, PMAX=ZMAXCOVR2, PAVG=ZAVGCOVR2)

ALLOCATE (LCOVER (YLCOVERS%JPCOVER))
LCOVER = .FALSE.

LCOVER = ZAVGCOVR2 > 0._JPRB

CALL MAKEFRAC (ZFRAC_MER                        , YLFL2COV, YLCOVERS%XDATA_SEA  , LCOVER)
CALL MAKEFRAC (ZFRAC_EAU                        , YLFL2COV, YLCOVERS%XDATA_WATER, LCOVER)
CALL MAKEFRAC (YLPT2 (JSURFPROPURBANIS, 0)%ZDATA, YLFL2COV, YLCOVERS%XDATA_TOWN , LCOVER)

!$OMP WORKSHARE
  YLPT2 (JSURFPROPTERRE, 0)%ZDATA = 1._JPRB - (ZFRAC_MER + ZFRAC_EAU)
!$OMP END WORKSHARE

!$OMP WORKSHARE
WHERE (ZFRAC_EAU > SMASK)
  YLPT2 (JSURFINDTERREMER, 0)%ZDATA = 0._JPRB
ENDWHERE
!$OMP END WORKSHARE

END SUBROUTINE

SUBROUTINE MAKEFRAC (PFRAC, YDCOVER, PDATA, LDCOVER)

REAL (KIND=JPRB),   INTENT (OUT) :: PFRAC (:)
TYPE (ATLAS_FIELD), INTENT (IN)  :: YDCOVER (:)
REAL (KIND=JPRB),   INTENT (IN)  :: PDATA (:)
LOGICAL,            INTENT (IN)  :: LDCOVER (:)

TYPE (PTR) :: YLPTR (SIZE (YDCOVER))

INTEGER (KIND=JPIM) :: JLOC, JCOV, INCOV
REAL (KIND=JPRB) :: ZSUM

INCOV = SIZE (YDCOVER)

DO JCOV = 1, INCOV
  CALL YDCOVER (JCOV)%DATA (YLPTR (JCOV)%ZDATA)
ENDDO

! 1D computation

!$OMP PARALLEL DO PRIVATE (JLOC, ZSUM, JCOV) 
DO JLOC = 1, SIZE (PFRAC)
  PFRAC (JLOC) = 0._JPRB
  ZSUM = 0._JPRB
  DO JCOV = 1, INCOV
    IF (LDCOVER (JCOV)) THEN
      PFRAC (JLOC) = PFRAC (JLOC) + YLPTR (JCOV)%ZDATA (JLOC) * PDATA (JCOV)
      ZSUM         = ZSUM + YLPTR (JCOV)%ZDATA (JLOC)
    ENDIF
  ENDDO
  PFRAC (JLOC) = PFRAC (JLOC) / ZSUM
ENDDO
!$OMP END PARALLEL DO

END SUBROUTINE

FUNCTION RNS1 (YDDHIO, YDFSSC1, CDNAME, PSCALE) RESULT (YLFL)

USE ATLAS_IO_DH, ONLY : ATLAS_IO_DH_t

TYPE (ATLAS_IO_DH_t), INTENT (INOUT) :: YDDHIO
TYPE (ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS), INTENT (IN) :: YDFSSC1
CHARACTER (LEN=*),    INTENT (IN)    :: CDNAME
REAL (KIND=JPRB),     INTENT (IN), OPTIONAL :: PSCALE

TYPE (ATLAS_FIELDSET) :: YLFS
TYPE (ATLAS_FIELD) :: YLFL

! Read a field on source geometry, and insert it in the list #1

YLFS = YDDHIO%READ (CDNAME, [CDNAME], YDFSSC1, PUNDEF=ZUNDEF, PSCALE=PSCALE)

YLFL = YLFS%FIELD (1)

CALL YLFS%FINAL ()

CALL YLFL%RETURN ()

END FUNCTION

SUBROUTINE INS2 (KRANK, KMONTH, YDFL)

INTEGER (KIND=JPIM), INTENT (IN)    :: KRANK, KMONTH
TYPE (ATLAS_FIELD),  INTENT (IN)    :: YDFL

! Insert a field in list #2 (target)

IF (.NOT. YLFL2 (KRANK, KMONTH)%IS_NULL ()) THEN
  WRITE (0, *) " KRANK = ", KRANK, " KMONTH = ", KMONTH, " NAME = ", YLFL2 (KRANK, KMONTH)%NAME ()
  CALL ATLAS_ABORT ('FIELD ALREADY EXISTS:'//YLFL2 (KRANK, KMONTH)%NAME ())
ENDIF

IF (YDFL%SIZE () /= YLFSSC2%SIZE ()) CALL ATLAS_ABORT ('SIZE MISMATCH')
YLFL2 (KRANK, KMONTH) = YDFL
CALL YDFL%DATA (YLPT2 (KRANK, KMONTH)%ZDATA)

END SUBROUTINE

END PROGRAM

