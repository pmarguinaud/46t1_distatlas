MODULE ATLAS_HELPER

USE PARKIND1, ONLY : JPIM, JPRB
USE FCKIT_MODULE, ONLY : FCKIT_MPI_COMM
USE ATLAS_MODULE  

#include "atlas-abort.h"

!

IMPLICIT NONE

TYPE PTR
  REAL (KIND=JPRB), POINTER :: ZDATA (:) => NULL ()
END TYPE PTR

PRIVATE

PUBLIC :: CREATE_DIST, FIELDSTAT, PTR, GRID_EQ, NEWFLD

CONTAINS

FUNCTION NEWFLD (YDFSSC, CDNAME, PUNDEF) RESULT (YLFLD)

TYPE (ATLAS_FIELD) :: YLFLD

TYPE (ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS), INTENT (IN)  :: YDFSSC
CHARACTER (LEN=*),                            INTENT (IN)  :: CDNAME
REAL (KIND=JPRB), OPTIONAL,                   INTENT (IN)  :: PUNDEF

TYPE (ATLAS_METADATA) :: YLMETA

! Create new field; set its undef value in its metadata section

YLFLD = ATLAS_FIELD (NAME=TRIM (CDNAME), KIND=JPRB, SHAPE=[YDFSSC%SIZE ()])

IF (PRESENT (PUNDEF)) THEN
  YLMETA = YLFLD%METADATA ()
  CALL YLMETA%SET ("undef", PUNDEF)
  CALL YLMETA%FINAL ()
ENDIF

CALL YLFLD%RETURN ()

END FUNCTION

LOGICAL FUNCTION ISMGLO (YDGRID)

CLASS (ATLAS_STRUCTUREDGRID),  INTENT (IN) :: YDGRID

TYPE (ATLAS_CONFIG) :: YLCONF
CHARACTER (LEN=:), ALLOCATABLE :: CLDOTY

YLCONF = YDGRID%SPEC ()

ISMGLO = .FALSE.

IF (YLCONF%GET ('domain.type', CLDOTY)) THEN
  ISMGLO = CLDOTY == 'global'
ENDIF

CALL YLCONF%FINAL ()

END FUNCTION 

SUBROUTINE CREATE_DIST (YDGRID, YDDIST, LDLIGHT)

CLASS (ATLAS_STRUCTUREDGRID)  :: YDGRID
TYPE (ATLAS_GRIDDISTRIBUTION) :: YDDIST
LOGICAL, OPTIONAL             :: LDLIGHT

TYPE (ATLAS_CONFIG) :: YLCONF

CHARACTER (LEN=64)  :: CLDIST
LOGICAL             :: LLLIGHT

LLLIGHT = .FALSE.
IF (PRESENT (LDLIGHT)) LLLIGHT = LDLIGHT

IF (ISMGLO (YDGRID) .AND. (.NOT. LLLIGHT)) THEN
  CLDIST = "equal_regions"
ELSE
  CLDIST = "checkerboard"
ENDIF

YLCONF = ATLAS_CONFIG() 

SELECT CASE (CLDIST)
  CASE ('checkerboard') 
    IF (LLLIGHT) THEN
      CALL YLCONF%SET ('type', 'regular_bands')
      CALL YLCONF%SET ('blocksize', INT (YDGRID%NX (1)))
    ELSE
      CALL YLCONF%SET ('type', 'checkerboard')
    ENDIF
  CASE ('equal_regions')
    CALL YLCONF%SET ('type', 'equal_regions')
  CASE DEFAULT
    CALL ABORT ('UNKNOWN DISTRIBUTION TYPE :'//TRIM (CLDIST))
END SELECT 

YDDIST = ATLAS_GRIDDISTRIBUTION (YDGRID, YLCONF)

CALL YLCONF%FINAL ()

END SUBROUTINE

SUBROUTINE FIELDSTAT (YLFSSC, YLFLDS, PMIN, PMAX, PAVG)

USE FCKIT_MPI_MODULE

TYPE (ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS), INTENT (IN)  :: YLFSSC
TYPE (ATLAS_FIELD),                           INTENT (IN)  :: YLFLDS (:)
REAL (KIND=JPRB), OPTIONAL,                   INTENT (OUT) :: PMIN (:), PMAX (:), PAVG (:)

INTEGER (KIND=JPIM)   :: NPROC, INFLD, IGPTOT
TYPE (FCKIT_MPI_COMM) :: YLCOMM

TYPE (PTR),          ALLOCATABLE :: YLPTR (:)
LOGICAL,             ALLOCATABLE :: LLUNDEF (:)
REAL (KIND=JPRB),    ALLOCATABLE :: ZUNDEF (:), ZMMSALL (:), ZMMS (:)
INTEGER (KIND=JPIM), ALLOCATABLE :: ICNTALL (:), ICNT (:), IRECVCNT (:), IDISPCNT (:)
INTEGER (KIND=JPIM) :: JFLD, IOFF, INUM, IPROC

TYPE (ATLAS_METADATA) :: YLMETA

IGPTOT = YLFSSC%SIZE_OWNED ()
INFLD  = SIZE (YLFLDS)
YLCOMM = FCKIT_MPI_COMM ()
NPROC  = YLCOMM%SIZE ()

ALLOCATE (YLPTR (INFLD), LLUNDEF (INFLD), ZUNDEF (INFLD), ZMMSALL (3 * INFLD * NPROC), &
        & ZMMS (3 * INFLD), ICNTALL (INFLD * NPROC), ICNT (INFLD), IRECVCNT (NPROC), IDISPCNT (NPROC))

ZUNDEF = HUGE (1._JPRB)

DO JFLD = 1, INFLD
  CALL YLFLDS (JFLD)%DATA (YLPTR (JFLD)%ZDATA)
  YLMETA = YLFLDS (JFLD)%METADATA ()
  LLUNDEF (JFLD) = YLMETA%HAS ("undef")
  IF (LLUNDEF (JFLD)) CALL YLMETA%GET ("undef", ZUNDEF (JFLD))
  CALL YLMETA%FINAL ()
ENDDO


!$OMP PARALLEL DO PRIVATE (JFLD)
DO JFLD = 1, INFLD
  IF (LLUNDEF (JFLD)) THEN
    ICNT (JFLD) = COUNT  (YLPTR (JFLD)%ZDATA (1:IGPTOT) /= ZUNDEF (JFLD))
    IF (ICNT (JFLD) > 0) THEN
      ZMMS (3*(JFLD-1)+1) = MINVAL (YLPTR (JFLD)%ZDATA (1:IGPTOT), MASK=YLPTR (JFLD)%ZDATA (1:IGPTOT)/=ZUNDEF (JFLD))
      ZMMS (3*(JFLD-1)+2) = MAXVAL (YLPTR (JFLD)%ZDATA (1:IGPTOT), MASK=YLPTR (JFLD)%ZDATA (1:IGPTOT)/=ZUNDEF (JFLD))
      ZMMS (3*(JFLD-1)+3) = SUM    (YLPTR (JFLD)%ZDATA (1:IGPTOT), MASK=YLPTR (JFLD)%ZDATA (1:IGPTOT)/=ZUNDEF (JFLD))
    ELSE
      ZMMS (3*(JFLD-1)+1) = ZUNDEF (JFLD)
      ZMMS (3*(JFLD-1)+2) = ZUNDEF (JFLD)
      ZMMS (3*(JFLD-1)+3) = ZUNDEF (JFLD)
    ENDIF
  ELSE
    ICNT (JFLD) = IGPTOT
    ZMMS (3*(JFLD-1)+1) = MINVAL (YLPTR (JFLD)%ZDATA (1:IGPTOT))
    ZMMS (3*(JFLD-1)+2) = MAXVAL (YLPTR (JFLD)%ZDATA (1:IGPTOT))
    ZMMS (3*(JFLD-1)+3) = SUM    (YLPTR (JFLD)%ZDATA (1:IGPTOT))
  ENDIF
ENDDO
!$OMP END PARALLEL DO

IRECVCNT (:) = 1
IDISPCNT (1) = 0
DO IPROC = 2, NPROC
  IDISPCNT (IPROC) = IDISPCNT (IPROC-1) + IRECVCNT (IPROC-1)
ENDDO

CALL YLCOMM%ALLGATHER (ZMMS, ZMMSALL, INFLD * 3, IRECVCNT * INFLD * 3, IDISPCNT * INFLD * 3)
CALL YLCOMM%ALLGATHER (ICNT, ICNTALL, INFLD * 1, IRECVCNT * INFLD * 1, IDISPCNT * INFLD * 1)
  
!$OMP PARALLEL DO PRIVATE (JFLD, IOFF, INUM)
DO JFLD = 1, INFLD
  IOFF = 3*(JFLD-1)
  INUM = 3*INFLD
  IF (LLUNDEF (JFLD)) THEN
    IF (PRESENT (PMIN)) PMIN (JFLD) = MINVAL (ZMMSALL (IOFF+1::INUM), MASK=ZMMSALL (IOFF+1::INUM)/=ZUNDEF (JFLD))
    IF (PRESENT (PMAX)) PMAX (JFLD) = MAXVAL (ZMMSALL (IOFF+2::INUM), MASK=ZMMSALL (IOFF+2::INUM)/=ZUNDEF (JFLD))
    IF (PRESENT (PAVG)) PAVG (JFLD) = SUM    (ZMMSALL (IOFF+3::INUM), MASK=ZMMSALL (IOFF+3::INUM)/=ZUNDEF (JFLD)) 
  ELSE
    IF (PRESENT (PMIN)) PMIN (JFLD) = MINVAL (ZMMSALL (IOFF+1::INUM))
    IF (PRESENT (PMAX)) PMAX (JFLD) = MAXVAL (ZMMSALL (IOFF+2::INUM))
    IF (PRESENT (PAVG)) PAVG (JFLD) = SUM    (ZMMSALL (IOFF+3::INUM))
  ENDIF
  INUM = SUM (ICNTALL ((JFLD-1)+1::INFLD))
  IF (PRESENT (PAVG)) THEN
    IF (INUM > 0) THEN
      PAVG (JFLD) = PAVG (JFLD) / REAL (INUM, JPRB)
    ELSE
      PAVG (JFLD) = ZUNDEF (JFLD)
    ENDIF
  ENDIF
ENDDO
!$OMP END PARALLEL DO

#ifdef UNDEF
DO JFLD = 1, SIZE (YLFLDS)
  WRITE (*, '(A16," > ",F12.4," | ",F12.4," | ",F12.4)') &
       & YLFLDS (JFLD)%NAME (), PAVG (JFLD), PMIN (JFLD), PMAX (JFLD)
ENDDO
#endif

END SUBROUTINE

LOGICAL FUNCTION GRID_EQ (YDGRID1, YDGRID2)

REAL (KIND=JPRB), PARAMETER :: RPI = 2.0_JPRB * ASIN (1.0_JPRB)
REAL (KIND=JPRB), PARAMETER :: DEG2RAD = RPI / 180._JPRB
REAL (KIND=JPRB), PARAMETER :: RAD2DEG = 180._JPRB / RPI

CLASS (ATLAS_STRUCTUREDGRID), INTENT (IN) :: YDGRID1, YDGRID2
TYPE (ATLAS_CONFIG) :: YLCONF1, YLCONF2
INTEGER (KIND=JPIM) :: I, J, ILIST (3)
REAL (KIND=JPRB) :: ZANGMAX

YLCONF1 = YDGRID1%SPEC ()
YLCONF2 = YDGRID2%SPEC ()

GRID_EQ = YLCONF1%JSON () == YLCONF2%JSON ()

IF (GRID_EQ) GOTO 999

IF (YDGRID1%SIZE () /= YDGRID2%SIZE ()) GOTO 999
IF (YDGRID1%NY () /= YDGRID2%NY ()) GOTO 999

DO J = 1, YDGRID1%NY ()
  IF (YDGRID1%NX (J) /= YDGRID2%NX (J)) GOTO 999
ENDDO

ZANGMAX = ANGLE (LONLAT2XYZ (YDGRID1%LONLAT (1, 1)), LONLAT2XYZ (YDGRID1%LONLAT (1, INT (YDGRID1%NY ()))))

DO J = 1, YDGRID1%NY ()
  ILIST = [1, INT (YDGRID1%NX (J) / 2), INT (YDGRID1%NX (J))]
  DO I = 1, SIZE (ILIST)
    IF (ANGLE (LONLAT2XYZ (YDGRID1%LONLAT (ILIST (I), J)), &
      &        LONLAT2XYZ (YDGRID2%LONLAT (ILIST (I), J))) &
      &        > 1.E-5_JPRB * ZANGMAX) GOTO 999
  ENDDO
ENDDO

GRID_EQ = .TRUE.

999 CONTINUE

IF (.NOT. GRID_EQ) THEN
  PRINT *, YLCONF1%JSON ()
  PRINT *, YLCONF2%JSON ()
ENDIF

CALL YLCONF1%FINAL ()
CALL YLCONF2%FINAL ()

CONTAINS

FUNCTION LONLAT2XYZ (PLONLAT) RESULT (ZXYZ)

REAL (KIND=JPRB), INTENT (IN) :: PLONLAT (2)
REAL (KIND=JPRB) :: ZLON, ZLAT, ZXYZ (3)
REAL (KIND=JPRB) :: ZCOSLON, ZCOSLAT, ZSINLON, ZSINLAT

ZLON = DEG2RAD * PLONLAT (1)
ZLAT = DEG2RAD * PLONLAT (2)

ZCOSLON = COS (ZLON); ZSINLON = SIN (ZLON)
ZCOSLAT = COS (ZLAT); ZSINLAT = SIN (ZLAT)

ZXYZ (1) = ZCOSLON * ZCOSLAT
ZXYZ (2) = ZSINLON * ZCOSLAT
ZXYZ (3) =           ZSINLAT

END FUNCTION

REAL (KIND=JPRB) FUNCTION ANGLE (ZXYZ1, ZXYZ2)

REAL (KIND=JPRB), INTENT (IN) :: ZXYZ1 (3), ZXYZ2 (3)

ANGLE = RAD2DEG * ACOS (MAX (-1._JPRB, MIN (+1._JPRB, SUM (ZXYZ1 * ZXYZ2))))

END FUNCTION

END FUNCTION

END MODULE 

