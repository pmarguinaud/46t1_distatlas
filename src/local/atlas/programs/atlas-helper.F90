MODULE ATLAS_HELPER

USE PARKIND1, ONLY : JPIM, JPRB
USE FCKIT_MODULE, ONLY : FCKIT_MPI_COMM
USE ATLAS_MODULE  

#include "atlas-abort.h"

!

IMPLICIT NONE

TYPE PTR
  REAL (KIND=JPRB), POINTER :: ZDATA (:) => NULL ()
END TYPE PTR

PRIVATE

PUBLIC :: CREATE_DIST, FIELDSTAT, PTR, GRID_EQ, NEWFLD, CPYFLD, GRID_FROM_NAMELIST

CONTAINS

FUNCTION NEWFLD (YDFSSC, CDNAME, PUNDEF) RESULT (YLFLD)

TYPE (ATLAS_FIELD) :: YLFLD

TYPE (ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS), INTENT (IN)  :: YDFSSC
CHARACTER (LEN=*),                            INTENT (IN)  :: CDNAME
REAL (KIND=JPRB), OPTIONAL,                   INTENT (IN)  :: PUNDEF

TYPE (ATLAS_METADATA) :: YLMETA

! Create new field; set its undef value in its metadata section

YLFLD = ATLAS_FIELD (NAME=TRIM (CDNAME), KIND=JPRB, SHAPE=[YDFSSC%SIZE ()])

IF (PRESENT (PUNDEF)) THEN
  YLMETA = YLFLD%METADATA ()
  CALL YLMETA%SET ("undef", PUNDEF)
  CALL YLMETA%FINAL ()
ENDIF

CALL YLFLD%RETURN ()

END FUNCTION

FUNCTION CPYFLD (YDFLD, CDNAME) RESULT (YLFLD)

TYPE (ATLAS_FIELD) :: YLFLD

TYPE (ATLAS_FIELD),          INTENT (IN) :: YDFLD
CHARACTER (LEN=*), OPTIONAL, INTENT (IN) :: CDNAME

TYPE (ATLAS_METADATA) :: YLMETA
REAL (KIND=JPRB) :: ZUNDEF
REAL (KIND=JPRB), POINTER :: ZDATAL (:), ZDATAD (:)

YLFLD = ATLAS_FIELD (NAME=TRIM (YDFLD%NAME ()), KIND=JPRB, SHAPE=[YDFLD%SIZE ()])

IF (PRESENT (CDNAME)) THEN
  CALL YLFLD%RENAME (CDNAME)
ENDIF

YLMETA = YDFLD%METADATA ()
IF (YLMETA%HAS ("undef")) THEN
  CALL YLMETA%GET ("undef", ZUNDEF)
  CALL YLMETA%FINAL ()
  YLMETA = YLFLD%METADATA ()
  CALL YLMETA%SET ("undef", ZUNDEF)
ENDIF
CALL YLMETA%FINAL ()

CALL YDFLD%DATA (ZDATAD)
CALL YLFLD%DATA (ZDATAL)

!$OMP WORKSHARE
ZDATAL = ZDATAD
!$OMP END WORKSHARE

CALL YLFLD%RETURN ()

END FUNCTION

LOGICAL FUNCTION ISMGLO (YDGRID)

CLASS (ATLAS_STRUCTUREDGRID),  INTENT (IN) :: YDGRID

TYPE (ATLAS_CONFIG) :: YLCONF
CHARACTER (LEN=:), ALLOCATABLE :: CLDOTY

YLCONF = YDGRID%SPEC ()

ISMGLO = .FALSE.

IF (YLCONF%GET ('domain.type', CLDOTY)) THEN
  ISMGLO = CLDOTY == 'global'
ENDIF

CALL YLCONF%FINAL ()

END FUNCTION 

SUBROUTINE CREATE_DIST (YDGRID, YDDIST, LDLIGHT)

CLASS (ATLAS_STRUCTUREDGRID)  :: YDGRID
TYPE (ATLAS_GRIDDISTRIBUTION) :: YDDIST
LOGICAL, OPTIONAL             :: LDLIGHT

TYPE (ATLAS_CONFIG) :: YLCONF

CHARACTER (LEN=64)  :: CLDIST
LOGICAL             :: LLLIGHT

LLLIGHT = .FALSE.
IF (PRESENT (LDLIGHT)) LLLIGHT = LDLIGHT

IF (ISMGLO (YDGRID) .AND. (.NOT. LLLIGHT)) THEN
  CLDIST = "equal_regions"
ELSE
  CLDIST = "checkerboard"
ENDIF

YLCONF = ATLAS_CONFIG() 

SELECT CASE (CLDIST)
  CASE ('checkerboard') 
    IF (LLLIGHT) THEN
      CALL YLCONF%SET ('type', 'regular_bands')
      CALL YLCONF%SET ('blocksize', INT (YDGRID%NX (1)))
    ELSE
      CALL YLCONF%SET ('type', 'checkerboard')
    ENDIF
  CASE ('equal_regions')
    CALL YLCONF%SET ('type', 'equal_regions')
  CASE DEFAULT
    CALL ATLAS_ABORT ('UNKNOWN DISTRIBUTION TYPE :'//TRIM (CLDIST))
END SELECT 

YDDIST = ATLAS_GRIDDISTRIBUTION (YDGRID, YLCONF)

CALL YLCONF%FINAL ()

END SUBROUTINE

SUBROUTINE FIELDSTAT (YLFSSC, YLFLDS, PMIN, PMAX, PAVG)

USE FCKIT_MPI_MODULE

TYPE (ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS), INTENT (IN)  :: YLFSSC
TYPE (ATLAS_FIELD),                           INTENT (IN)  :: YLFLDS (:)
REAL (KIND=JPRB), OPTIONAL,                   INTENT (OUT) :: PMIN (:), PMAX (:), PAVG (:)

INTEGER (KIND=JPIM)   :: NPROC, INFLD, IGPTOT
TYPE (FCKIT_MPI_COMM) :: YLCOMM

TYPE (PTR),          ALLOCATABLE :: YLPTR (:)
LOGICAL,             ALLOCATABLE :: LLUNDEF (:)
REAL (KIND=JPRB),    ALLOCATABLE :: ZUNDEF (:), ZMMSALL (:), ZMMS (:)
INTEGER (KIND=JPIM), ALLOCATABLE :: ICNTALL (:), ICNT (:), IRECVCNT (:), IDISPCNT (:)
INTEGER (KIND=JPIM) :: JFLD, IOFF, INUM, IPROC

TYPE (ATLAS_METADATA) :: YLMETA

IGPTOT = YLFSSC%SIZE_OWNED ()
INFLD  = SIZE (YLFLDS)
YLCOMM = FCKIT_MPI_COMM ()
NPROC  = YLCOMM%SIZE ()

ALLOCATE (YLPTR (INFLD), LLUNDEF (INFLD), ZUNDEF (INFLD), ZMMSALL (3 * INFLD * NPROC), &
        & ZMMS (3 * INFLD), ICNTALL (INFLD * NPROC), ICNT (INFLD), IRECVCNT (NPROC), IDISPCNT (NPROC))

ZUNDEF = HUGE (1._JPRB)

DO JFLD = 1, INFLD
  CALL YLFLDS (JFLD)%DATA (YLPTR (JFLD)%ZDATA)
  YLMETA = YLFLDS (JFLD)%METADATA ()
  LLUNDEF (JFLD) = YLMETA%HAS ("undef")
  IF (LLUNDEF (JFLD)) CALL YLMETA%GET ("undef", ZUNDEF (JFLD))
  CALL YLMETA%FINAL ()
ENDDO


!$OMP PARALLEL DO PRIVATE (JFLD)
DO JFLD = 1, INFLD
  IF (LLUNDEF (JFLD)) THEN
    ICNT (JFLD) = COUNT  (YLPTR (JFLD)%ZDATA (1:IGPTOT) /= ZUNDEF (JFLD))
    IF (ICNT (JFLD) > 0) THEN
      ZMMS (3*(JFLD-1)+1) = MINVAL (YLPTR (JFLD)%ZDATA (1:IGPTOT), MASK=YLPTR (JFLD)%ZDATA (1:IGPTOT)/=ZUNDEF (JFLD))
      ZMMS (3*(JFLD-1)+2) = MAXVAL (YLPTR (JFLD)%ZDATA (1:IGPTOT), MASK=YLPTR (JFLD)%ZDATA (1:IGPTOT)/=ZUNDEF (JFLD))
      ZMMS (3*(JFLD-1)+3) = SUM    (YLPTR (JFLD)%ZDATA (1:IGPTOT), MASK=YLPTR (JFLD)%ZDATA (1:IGPTOT)/=ZUNDEF (JFLD))
    ELSE
      ZMMS (3*(JFLD-1)+1) = ZUNDEF (JFLD)
      ZMMS (3*(JFLD-1)+2) = ZUNDEF (JFLD)
      ZMMS (3*(JFLD-1)+3) = ZUNDEF (JFLD)
    ENDIF
  ELSE
    ICNT (JFLD) = IGPTOT
    ZMMS (3*(JFLD-1)+1) = MINVAL (YLPTR (JFLD)%ZDATA (1:IGPTOT))
    ZMMS (3*(JFLD-1)+2) = MAXVAL (YLPTR (JFLD)%ZDATA (1:IGPTOT))
    ZMMS (3*(JFLD-1)+3) = SUM    (YLPTR (JFLD)%ZDATA (1:IGPTOT))
  ENDIF
ENDDO
!$OMP END PARALLEL DO

IRECVCNT (:) = 1
IDISPCNT (1) = 0
DO IPROC = 2, NPROC
  IDISPCNT (IPROC) = IDISPCNT (IPROC-1) + IRECVCNT (IPROC-1)
ENDDO

CALL YLCOMM%ALLGATHER (ZMMS, ZMMSALL, INFLD * 3, IRECVCNT * INFLD * 3, IDISPCNT * INFLD * 3)
CALL YLCOMM%ALLGATHER (ICNT, ICNTALL, INFLD * 1, IRECVCNT * INFLD * 1, IDISPCNT * INFLD * 1)
  
!$OMP PARALLEL DO PRIVATE (JFLD, IOFF, INUM)
DO JFLD = 1, INFLD
  IOFF = 3*(JFLD-1)
  INUM = 3*INFLD
  IF (LLUNDEF (JFLD)) THEN
    IF (PRESENT (PMIN)) PMIN (JFLD) = MINVAL (ZMMSALL (IOFF+1::INUM), MASK=ZMMSALL (IOFF+1::INUM)/=ZUNDEF (JFLD))
    IF (PRESENT (PMAX)) PMAX (JFLD) = MAXVAL (ZMMSALL (IOFF+2::INUM), MASK=ZMMSALL (IOFF+2::INUM)/=ZUNDEF (JFLD))
    IF (PRESENT (PAVG)) PAVG (JFLD) = SUM    (ZMMSALL (IOFF+3::INUM), MASK=ZMMSALL (IOFF+3::INUM)/=ZUNDEF (JFLD)) 
  ELSE
    IF (PRESENT (PMIN)) PMIN (JFLD) = MINVAL (ZMMSALL (IOFF+1::INUM))
    IF (PRESENT (PMAX)) PMAX (JFLD) = MAXVAL (ZMMSALL (IOFF+2::INUM))
    IF (PRESENT (PAVG)) PAVG (JFLD) = SUM    (ZMMSALL (IOFF+3::INUM))
  ENDIF
  INUM = SUM (ICNTALL ((JFLD-1)+1::INFLD))
  IF (PRESENT (PAVG)) THEN
    IF (INUM > 0) THEN
      PAVG (JFLD) = PAVG (JFLD) / REAL (INUM, JPRB)
    ELSE
      PAVG (JFLD) = ZUNDEF (JFLD)
    ENDIF
  ENDIF
ENDDO
!$OMP END PARALLEL DO

#ifdef UNDEF
DO JFLD = 1, SIZE (YLFLDS)
  WRITE (*, '(A16," > ",F12.4," | ",F12.4," | ",F12.4)') &
       & YLFLDS (JFLD)%NAME (), PAVG (JFLD), PMIN (JFLD), PMAX (JFLD)
ENDDO
#endif

END SUBROUTINE

LOGICAL FUNCTION GRID_EQ (YDGRID1, YDGRID2)

REAL (KIND=JPRB), PARAMETER :: RPI = 2.0_JPRB * ASIN (1.0_JPRB)
REAL (KIND=JPRB), PARAMETER :: DEG2RAD = RPI / 180._JPRB
REAL (KIND=JPRB), PARAMETER :: RAD2DEG = 180._JPRB / RPI

CLASS (ATLAS_STRUCTUREDGRID), INTENT (IN) :: YDGRID1, YDGRID2
TYPE (ATLAS_CONFIG) :: YLCONF1, YLCONF2
INTEGER (KIND=JPIM) :: I, J, ILIST (3)
REAL (KIND=JPRB) :: ZANGMAX

YLCONF1 = YDGRID1%SPEC ()
YLCONF2 = YDGRID2%SPEC ()

GRID_EQ = YLCONF1%JSON () == YLCONF2%JSON ()

IF (GRID_EQ) GOTO 999

IF (YDGRID1%SIZE () /= YDGRID2%SIZE ()) GOTO 999
IF (YDGRID1%NY () /= YDGRID2%NY ()) GOTO 999

DO J = 1, YDGRID1%NY ()
  IF (YDGRID1%NX (J) /= YDGRID2%NX (J)) GOTO 999
ENDDO

ZANGMAX = ANGLE (LONLAT2XYZ (YDGRID1%LONLAT (1, 1)), LONLAT2XYZ (YDGRID1%LONLAT (1, INT (YDGRID1%NY ()))))

DO J = 1, YDGRID1%NY ()
  ILIST = [1, INT (YDGRID1%NX (J) / 2), INT (YDGRID1%NX (J))]
  DO I = 1, SIZE (ILIST)
    IF (ANGLE (LONLAT2XYZ (YDGRID1%LONLAT (ILIST (I), J)), &
      &        LONLAT2XYZ (YDGRID2%LONLAT (ILIST (I), J))) &
      &        > 1.E-5_JPRB * ZANGMAX) GOTO 999
  ENDDO
ENDDO

GRID_EQ = .TRUE.

999 CONTINUE

IF (.NOT. GRID_EQ) THEN
  PRINT *, YLCONF1%JSON ()
  PRINT *, YLCONF2%JSON ()
ENDIF

CALL YLCONF1%FINAL ()
CALL YLCONF2%FINAL ()

CONTAINS

FUNCTION LONLAT2XYZ (PLONLAT) RESULT (ZXYZ)

REAL (KIND=JPRB), INTENT (IN) :: PLONLAT (2)
REAL (KIND=JPRB) :: ZLON, ZLAT, ZXYZ (3)
REAL (KIND=JPRB) :: ZCOSLON, ZCOSLAT, ZSINLON, ZSINLAT

ZLON = DEG2RAD * PLONLAT (1)
ZLAT = DEG2RAD * PLONLAT (2)

ZCOSLON = COS (ZLON); ZSINLON = SIN (ZLON)
ZCOSLAT = COS (ZLAT); ZSINLAT = SIN (ZLAT)

ZXYZ (1) = ZCOSLON * ZCOSLAT
ZXYZ (2) = ZSINLON * ZCOSLAT
ZXYZ (3) =           ZSINLAT

END FUNCTION

REAL (KIND=JPRB) FUNCTION ANGLE (ZXYZ1, ZXYZ2)

REAL (KIND=JPRB), INTENT (IN) :: ZXYZ1 (3), ZXYZ2 (3)

ANGLE = RAD2DEG * ACOS (MAX (-1._JPRB, MIN (+1._JPRB, SUM (ZXYZ1 * ZXYZ2))))

END FUNCTION

END FUNCTION

TYPE (ATLAS_STRUCTUREDGRID) FUNCTION GRID_FROM_NAMELIST () RESULT (YLGRID)

TYPE GRID_OPTIONS_t
  INTEGER (KIND=JPIM) :: NLOEN (30000) = 0
  INTEGER (KIND=JPIM) :: NDLON = 0, NDGLG = 0
  LOGICAL :: LATLON   = .FALSE.

  REAL (KIND=JPRB) :: ZLONW =   0._JPRB, ZLONE = 360._JPRB
  REAL (KIND=JPRB) :: ZLATS = -90._JPRB, ZLATN = +90._JPRB

  LOGICAL :: LELAM    = .FALSE.
  LOGICAL :: LROTATED = .FALSE. 
  LOGICAL :: LSTRETCH = .FALSE.
  REAL (KIND=JPRB) :: RSTRETCH = 1._JPRB
  REAL (KIND=JPRB) :: RLONCENT = 0._JPRB  ! Degrees
  REAL (KIND=JPRB) :: RLATCENT = 90._JPRB ! Degrees

  REAL (KIND=JPRB) :: DXINMETRES = 10000._JPRB
  REAL (KIND=JPRB) :: DYINMETRES = 10000._JPRB

  REAL (KIND=JPRB) :: LADINDEGREES    = 46.2_JPRB
  REAL (KIND=JPRB) :: LATIN1INDEGREES = 46.2_JPRB
  REAL (KIND=JPRB) :: LATIN2INDEGREES = 46.2_JPRB
  REAL (KIND=JPRB) :: LOVINDEGREES    =  2.0_JPRB
  INTEGER (KIND=JPIM) :: NUX, NUY
END TYPE GRID_OPTIONS_t

TYPE (GRID_OPTIONS_t) :: YLGROPT

NAMELIST / NAMGRID / YLGROPT

OPEN (4, FORM="FORMATTED")
READ (4, NAMGRID)
CLOSE (4)

IF (YLGROPT%LATLON) THEN
BLOCK
  LOGICAL :: LLGLOBAL
  TYPE (ATLAS_CONFIG) :: YLCFGR, YLCFDO
  REAL (KIND=JPRB) :: ZLOND

  ZLOND = MODULO (YLGROPT%ZLONE-YLGROPT%ZLONW, 360._JPRB) / (YLGROPT%NDLON-1)

  LLGLOBAL = ABS (MOD (YLGROPT%ZLONE+ZLOND-YLGROPT%ZLONW-360._JPRB, 360._JPRB)) < 1E-6_JPRB

  YLCFGR = ATLAS_CONFIG ()
  YLCFDO = ATLAS_CONFIG ()

  IF (LLGLOBAL) THEN ! Global lat/lon
    CALL YLCFGR%SET ("nx", YLGROPT%NDLON)
    CALL YLCFGR%SET ("ny", YLGROPT%NDGLG)
    CALL YLCFGR%SET ("type", "regular_lonlat")
    IF (YLGROPT%ZLONE+ZLOND < YLGROPT%ZLONW) THEN
      YLGROPT%ZLONW = YLGROPT%ZLONW - 360._JPRB
    ENDIF
    CALL YLCFDO%SET ("type", "global") 
    CALL YLCFDO%SET ("xmin", YLGROPT%ZLONW)
    CALL YLCFDO%SET ("xmax", YLGROPT%ZLONE+ZLOND)
    CALL YLCFDO%SET ("ymin", YLGROPT%ZLATS)
    CALL YLCFDO%SET ("ymax", YLGROPT%ZLATN)
    CALL YLCFDO%SET ("units", "degrees")
    CALL YLCFGR%SET ("domain", YLCFDO)
    YLGRID = ATLAS_STRUCTUREDGRID (YLCFGR)
  ELSE ! Regional lat/lon
    IF (YLGROPT%ZLONE < YLGROPT%ZLONW) THEN
      YLGROPT%ZLONW = YLGROPT%ZLONW - 360._JPRB
    ENDIF
    YLGRID = ATLAS_REGIONALGRID (NX=YLGROPT%NDLON, NY=YLGROPT%NDGLG, &
           & NORTH=YLGROPT%ZLATN, WEST=YLGROPT%ZLONW, SOUTH=YLGROPT%ZLATS, EAST=YLGROPT%ZLONE )
  ENDIF

  CALL YLCFGR%FINAL ()
  CALL YLCFDO%FINAL ()

ENDBLOCK
ELSEIF (YLGROPT%LELAM) THEN
  YLGRID = ATLAS_REGIONALGRID (NX=YLGROPT%NDLON, NY=YLGROPT%NDGLG,                                       &
         & XY_MIN=[-YLGROPT%NUX / 2 * YLGROPT%DXINMETRES, -YLGROPT%NUY / 2 * YLGROPT%DYINMETRES],        &
         & DX=YLGROPT%DXINMETRES, DY=YLGROPT%DYINMETRES,                                                 &
         & PROJECTION=ATLAS_LAMBERTCONFORMALCONICPROJECTION (YLGROPT%LOVINDEGREES, YLGROPT%LADINDEGREES, &
         & YLGROPT%LATIN1INDEGREES, YLGROPT%LATIN2INDEGREES))
ELSE IF (YLGROPT%RLONCENT /= 0._JPRB .OR. YLGROPT%RLATCENT /= 90._JPRB) THEN
  YLGRID = ATLAS_REDUCEDGAUSSIANGRID (YLGROPT%NLOEN (1:YLGROPT%NDGLG),  &
         & PROJECTION=ATLAS_ROTATEDSCHMIDTPROJECTION (YLGROPT%RSTRETCH, &
         & [YLGROPT%RLONCENT, YLGROPT%RLATCENT], 180._JPRB))
ELSE
  YLGRID = ATLAS_REDUCEDGAUSSIANGRID (YLGROPT%NLOEN (1:YLGROPT%NDGLG))
ENDIF

CALL YLGRID%RETURN ()

END FUNCTION

END MODULE 

