PROGRAM ATLAS_PGD

USE PARKIND1, ONLY : JPIM, JPRB
USE INTERPOLATIONA_MOD
USE ATLAS_ARPEGE_MODULE, ONLY : WFA, GFA
USE FCKIT_MODULE, ONLY : FCKIT_MPI_COMM
USE ATLAS_MODULE  
USE XRD_GETOPTIONS

!

IMPLICIT NONE

TYPE (ATLAS_STRUCTUREDGRID)                  :: YLGRID1
TYPE (ATLAS_STRUCTUREDGRID)                  :: YLGRID2
TYPE (ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS) :: YLFSSC1
TYPE (ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS) :: YLFSSC2
TYPE (ATLAS_GRIDDISTRIBUTION)                :: YLDIST1
TYPE (ATLAS_GRIDDISTRIBUTION)                :: YLDIST2
TYPE (INTERPOLATIONA)                        :: YLINTEA
TYPE (ATLAS_FIELDSET)                        :: YLFLDS1
TYPE (ATLAS_FIELDSET)                        :: YLFLDS2
TYPE (FCKIT_MPI_COMM)                        :: YLCOMM

INTEGER (KIND=JPIM) :: I, JFLD
INTEGER (KIND=JPIM) :: NPROC, IRANK

TYPE HDR_t
  REAL (KIND=JPRB) :: RUNDEF = 0
  REAL (KIND=JPRB) :: ZWEST = -999, ZEAST = -999, ZNORTH = -999, ZSOUTH = -999
  INTEGER (KIND=JPIM) :: ICOLS = -999, IROWS = -999, IWIDTH = -999
  CHARACTER (LEN=256) :: CLCOMMENT = ''
END TYPE HDR_t

INTERFACE CREATE_GRID
  PROCEDURE CREATE_GRID_HDR
  PROCEDURE CREATE_GRID_NML
END INTERFACE CREATE_GRID

TYPE (ATLAS_FIELD) :: YLCOVR1
TYPE (ATLAS_FIELD), ALLOCATABLE :: YLCOVR2 (:)
INTEGER (KIND=JPIM), PARAMETER :: INCOVR = 256_JPIM

TYPE (HDR_t) :: YLHDRS (4), YLHDR
CHARACTER (LEN=32), PARAMETER :: CLDATA (4) = [ &
!                         01234567890123456789012345678901
&                        'SFX.ZS                          ', &
&                        'SFX.CLAY                        ', &
&                        'SFX.SAND                        ', &
&                        'SFX.COVER                       ' ]

INTEGER (KIND=JPIM), PARAMETER :: JOROG_DAT = 1, JCLAY_DAT = 2, &
                                & JSAND_DAT = 3, JCOVR_DAT = 4

CALL INITOPTIONS 

CALL CHECKOPTIONS

CALL ATLAS_LIBRARY%INITIALISE ()

DO I = 1, SIZE (CLDATA)
  CALL HDR (TRIM (CLDATA (I)), YLHDRS (I))
ENDDO

YLHDR = YLHDRS (1)

DO I = 1, 4
  CALL COMPARE_GEOMHDR (YLHDR, YLHDRS (I))
ENDDO

YLCOMM = FCKIT_MPI_COMM ()
NPROC  = YLCOMM%SIZE ()
IRANK  = YLCOMM%RANK ()

CALL LINUX_BIND (IRANK, NPROC)

CALL CREATE_GRID (YLGRID1, YLHDR)
CALL CREATE_GRID (YLGRID2, 'fort.4')

CALL CREATE_DIST (YLGRID1, YLDIST1, .TRUE.)
CALL CREATE_DIST (YLGRID2, YLDIST2)

BLOCK
  TYPE (ATLAS_CONFIG) :: YLCONF
  YLCONF = ATLAS_CONFIG ()
  CALL YLCONF%SET ("halo", 1)
  CALL YLCONF%SET ("periodic_points", .TRUE.)
  YLFSSC1 = ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS (YLGRID1, YLDIST1, YLCONF)
  CALL YLCONF%FINAL ()
ENDBLOCK

YLFLDS1 = ATLAS_FIELDSET ()
YLFLDS2 = ATLAS_FIELDSET ()

YLFSSC2 = ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS (YLGRID2, YLDIST2)

YLINTEA = INTERPOLATIONA (YLDIST1, YLFSSC1, YLDIST2, YLFSSC2)

CALL YLFLDS1%ADD (DIR (CLDATA (JOROG_DAT), YLHDRS (JOROG_DAT), YLFSSC1, YLGRID1, YLDIST1))
CALL YLFLDS1%ADD (DIR (CLDATA (JCLAY_DAT), YLHDRS (JCLAY_DAT), YLFSSC1, YLGRID1, YLDIST1, 0.01_JPRB))
CALL YLFLDS1%ADD (DIR (CLDATA (JSAND_DAT), YLHDRS (JSAND_DAT), YLFSSC1, YLGRID1, YLDIST1, 0.01_JPRB))

YLFLDS2 = YLINTEA%INTERPOLATE (YLFLDS1)

YLCOVR1 = DIR (CLDATA (JCOVR_DAT), YLHDRS (JCOVR_DAT), YLFSSC1, YLGRID1, YLDIST1)

! Create covers

BLOCK
  TYPE PTR
    REAL (KIND=JPRB), POINTER :: ZDATA (:) => NULL ()
  END TYPE PTR
  TYPE (ATLAS_FIELD) :: YLCOVR2E
  INTEGER (KIND=JPIM), ALLOCATABLE :: IOFF (:), ICNT (:)
  TYPE (PTR), ALLOCATABLE :: YLPTR (:)
  REAL (KIND=JPRB), POINTER :: ZCOVR2E (:)
  INTEGER (KIND=JPIM) :: JLOC2, ICOV, II
  CHARACTER (LEN=16) :: CLNOMA

  IOFF = YLINTEA%GETOFF ()
  ICNT = YLINTEA%GETCNT ()

  YLCOVR2E = YLINTEA%SHUFFLE (YLCOVR1)

  CALL YLCOVR2E%DATA (ZCOVR2E)

  ALLOCATE (YLCOVR2 (INCOVR), YLPTR (INCOVR))

  DO ICOV = 1, INCOVR
    WRITE (CLNOMA, '("SFX.COVER",I3.3)') ICOV
    YLCOVR2 (ICOV) = ATLAS_FIELD (NAME=TRIM (CLNOMA), KIND=JPRB, SHAPE=[YLFSSC2%SIZE ()])
    CALL YLFLDS2%ADD (YLCOVR2 (ICOV))
    CALL YLCOVR2 (ICOV)%DATA (YLPTR (ICOV)%ZDATA)
    YLPTR (ICOV)%ZDATA = 0._JPRB
  ENDDO


  DO JLOC2 = 1, YLFSSC2%SIZE_OWNED ()
    DO II = IOFF (JLOC2)+1, IOFF (JLOC2)+ICNT (JLOC2)
      ICOV = INT (ZCOVR2E (II))
      IF ((ICOV < 1) .OR. (ICOV > INCOVR)) THEN
        CALL ABOR1 ('ATLAS_PGD: UNEXPECTED COVER VALUE')
      ENDIF
      YLPTR (ICOV)%ZDATA (JLOC2) = YLPTR (ICOV)%ZDATA (JLOC2) + 1._JPRB
    ENDDO
    DO ICOV = 1, INCOVR
      YLPTR (ICOV)%ZDATA (JLOC2) = YLPTR (ICOV)%ZDATA (JLOC2) / REAL (ICNT (JLOC2), JPRB)
    ENDDO
  ENDDO

  CALL YLCOVR2E%FINAL ()
ENDBLOCK

CALL WFA ('PGD.fa', YLGRID2, YLFSSC2, YLFLDS2)

CALL YLCOVR1%FINAL ()

DO JFLD = 1, INCOVR
  CALL YLCOVR2 (JFLD)%FINAL ()
ENDDO

CALL YLFLDS1%FINAL ()
CALL YLFLDS2%FINAL ()

CALL YLINTEA%FINAL ()

CALL ATLAS_LIBRARY%FINALISE()


WRITE (*, *) "--- STOP ---"

CONTAINS

SUBROUTINE CREATE_GRID_HDR (YDGRID, YDHDR)

TYPE (ATLAS_STRUCTUREDGRID) :: YDGRID
TYPE (HDR_t)                :: YDHDR

TYPE (ATLAS_CONFIG) :: YLCFGR, YLCFDO

YLCFGR = ATLAS_CONFIG ()
YLCFDO = ATLAS_CONFIG ()

CALL YLCFGR%SET ("nx", YDHDR%ICOLS)
CALL YLCFGR%SET ("ny", YDHDR%IROWS)
CALL YLCFGR%SET ("type", "shifted_lonlat")
CALL YLCFDO%SET ("type", "rectangular")
CALL YLCFDO%SET ("units", "degrees")
CALL YLCFDO%SET ("xmin", YDHDR%ZWEST)
CALL YLCFDO%SET ("xmax", YDHDR%ZEAST)
CALL YLCFDO%SET ("ymin", YDHDR%ZNORTH)
CALL YLCFDO%SET ("ymax", YDHDR%ZSOUTH)
CALL YLCFGR%SET ("domain", YLCFDO)

YDGRID = ATLAS_STRUCTUREDGRID (YLCFGR)

CALL YLCFGR%FINAL ()
CALL YLCFDO%FINAL ()

END SUBROUTINE

SUBROUTINE CREATE_GRID_NML (YDGRID, CDNML)

TYPE (ATLAS_STRUCTUREDGRID) :: YDGRID
CHARACTER (LEN=*)           :: CDNML

LOGICAL :: LLEXIST

TYPE GRID_OPTIONS_t
  INTEGER (KIND=JPIM) :: NLOEN (30000) = 0
  INTEGER (KIND=JPIM) :: NDLON = 0, NDGLG = 0
  LOGICAL :: LELAM    = .FALSE.
  LOGICAL :: LROTATED = .FALSE. 
  LOGICAL :: LSTRETCH = .FALSE.
  REAL (KIND=JPRB) :: RSTRETCH = 1._JPRB
  REAL (KIND=JPRB) :: RLONCENT = 0._JPRB  ! Degrees
  REAL (KIND=JPRB) :: RLATCENT = 90._JPRB ! Degrees

  REAL (KIND=JPRB) :: DXINMETRES = 10000._JPRB
  REAL (KIND=JPRB) :: DYINMETRES = 10000._JPRB

  REAL (KIND=JPRB) :: LADINDEGREES    = 46.2_JPRB
  REAL (KIND=JPRB) :: LATIN1INDEGREES = 46.2_JPRB
  REAL (KIND=JPRB) :: LATIN2INDEGREES = 46.2_JPRB
  REAL (KIND=JPRB) :: LOVINDEGREES    =  2.0_JPRB
  INTEGER (KIND=JPIM) :: NUX, NUY
END TYPE GRID_OPTIONS_t

TYPE (GRID_OPTIONS_t) :: YLGROPT

NAMELIST / NAMGRID / YLGROPT

OPEN (4, FILE=TRIM (CDNML), FORM="FORMATTED")
READ (4, NAMGRID)
CLOSE (4)

IF (YLGROPT%LELAM) THEN
  YDGRID = ATLAS_LAMBERTREGIONALGRID (YLGROPT%NDLON, YLGROPT%NDGLG, &
                                    & -YLGROPT%NUX / 2 * YLGROPT%DXINMETRES, &
                                    & -YLGROPT%NUY / 2 * YLGROPT%DYINMETRES, &
                                    & YLGROPT%DXINMETRES, YLGROPT%DYINMETRES, &
                                    & YLGROPT%LOVINDEGREES, YLGROPT%LADINDEGREES, &
                                    & YLGROPT%LATIN1INDEGREES, YLGROPT%LATIN2INDEGREES)
ELSE IF (YLGROPT%RLONCENT /= 0._JPRB .OR. YLGROPT%RLATCENT /= 90._JPRB) THEN
  YDGRID = ATLAS_REDUCEDGAUSSIANGRID (YLGROPT%NLOEN (1:YLGROPT%NDGLG), &
          & [YLGROPT%RLONCENT, YLGROPT%RLATCENT], YLGROPT%RSTRETCH)
ELSE
  YDGRID = ATLAS_REDUCEDGAUSSIANGRID (YLGROPT%NLOEN (1:YLGROPT%NDGLG))
ENDIF

END SUBROUTINE

SUBROUTINE CREATE_DIST (YDGRID, YDDIST, LDLIGHT)

USE ATLAS_ARPEGE_MODULE, ONLY : ISMGLO, ISMLAM, ISLTLN

TYPE (ATLAS_STRUCTUREDGRID)   :: YDGRID
TYPE (ATLAS_GRIDDISTRIBUTION) :: YDDIST
LOGICAL, OPTIONAL             :: LDLIGHT

#include "abor1.intfb.h"

TYPE (ATLAS_CONFIG) :: YLCONF

CHARACTER (LEN=64)  :: CLDIST
LOGICAL             :: LLLIGHT

IF (ISMGLO (YDGRID)) THEN
  CLDIST = "equal_regions"
ELSE
  CLDIST = "checkerboard"
ENDIF

LLLIGHT = .FALSE.
IF (PRESENT (LDLIGHT)) LLLIGHT = LDLIGHT

YLCONF = ATLAS_CONFIG() 

SELECT CASE (CLDIST)
  CASE ('checkerboard') 
    CALL YLCONF%SET ('type', 'checkerboard')
    IF (LLLIGHT) THEN
      CALL YLCONF%SET ('light', .TRUE.)
      CALL YLCONF%SET ('blocksize', INT (YDGRID%NX (1)))
    ENDIF
  CASE ('equal_regions')
    CALL YLCONF%SET ('type', 'equal_regions')
  CASE DEFAULT
    CALL ABOR1 ('UNKNOWN DISTRIBUTION TYPE :'//TRIM (CLDIST))
END SELECT 

YDDIST = ATLAS_GRIDDISTRIBUTION (YDGRID, YLCONF)

CALL YLCONF%FINAL ()

END SUBROUTINE

FUNCTION DIR (CDFILE, YDHDR, YDFSSC, YDGRID, YDDIST, PSCALE) RESULT (YLFLD)

TYPE (ATLAS_FIELD) :: YLFLD

CHARACTER (LEN=*),                            INTENT (IN)     :: CDFILE
TYPE (HDR_t),                                 INTENT (INOUT)  :: YDHDR
TYPE (ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS), INTENT (IN)     :: YDFSSC
TYPE (ATLAS_STRUCTUREDGRID),                  INTENT (IN)     :: YDGRID
TYPE (ATLAS_GRIDDISTRIBUTION),                INTENT (IN)     :: YDDIST
REAL (KIND=JPRB), OPTIONAL,                   INTENT (IN)     :: PSCALE

INTEGER (KIND=JPIM), ALLOCATABLE :: ISIZE (:)
INTEGER (KIND=JPIM) :: IPROC, IOFFS (NPROC+1), INX

INTEGER*1, ALLOCATABLE :: IL1 (:)
INTEGER*2, ALLOCATABLE :: IL2 (:)
INTEGER (KIND=JPIM) :: IROW, ICOL, IOFF, JLAT, IROW1, IROW2
REAL (KIND=JPRB), POINTER :: ZDATA (:)
TYPE (ATLAS_METADATA) :: YLMETA

YLFLD = ATLAS_FIELD (NAME=TRIM (CDFILE), KIND=JPRB, SHAPE=[YDFSSC%SIZE ()])
YLMETA = YLFLD%METADATA ()

CALL YLFLD%DATA (ZDATA)

ISIZE = YDDIST%NB_PTS ()

IOFFS (1) = 0
DO IPROC = 2, NPROC+1
  IOFFS (IPROC) = IOFFS (IPROC-1) + ISIZE (IPROC-1)
ENDDO

IPROC = IRANK + 1

INX = YDGRID%NX (1)

IF (MODULO (IOFFS (IPROC), INX) /= 0) THEN
  CALL ABOR1 ('DIR: DISTRIBUTION MISMATCH')
ENDIF

IROW1 = 1 + IOFFS (IPROC+0) / INX
IROW2 = 0 + IOFFS (IPROC+1) / INX

IF (SIZE (ZDATA) < INX * (IROW2-IROW1+1)) THEN
  CALL ABOR1 ('DIR: ZDATA IS TOO SMALL')
ENDIF

OPEN (77, FILE=TRIM (CDFILE)//'.dir', FORM='UNFORMATTED', ACTION='READ', &
    & ACCESS='DIRECT', RECL=((YDHDR%ICOLS * YDHDR%IWIDTH) / 8))

SELECT CASE (YDHDR%IWIDTH)

  CASE ( 8)
  
    ALLOCATE (IL1 (YDHDR%ICOLS))

    IOFF = 0
    DO IROW = IROW1, IROW2
      READ (77, REC=IROW) IL1
      WHERE (IL1 < 0)
        ZDATA (IOFF+1:IOFF+YDHDR%ICOLS) = IL1 + 256
      ELSEWHERE
        ZDATA (IOFF+1:IOFF+YDHDR%ICOLS) = IL1 
      ENDWHERE
      IOFF = IOFF + YDHDR%ICOLS
    ENDDO

  CASE (16)

    ALLOCATE (IL2 (YDHDR%ICOLS))

    IOFF = 0
    DO IROW = IROW1, IROW2
      READ (77, REC=IROW) IL2
      ZDATA (IOFF+1:IOFF+YDHDR%ICOLS) = IL2 
      IOFF = IOFF + YDHDR%ICOLS
    ENDDO

  CASE DEFAULT

    STOP

END SELECT

CLOSE (77)


IF (PRESENT (PSCALE)) THEN
  WHERE (ZDATA /= YDHDR%RUNDEF)
    ZDATA = ZDATA * PSCALE
  END WHERE
ENDIF

WHERE (ZDATA == YDHDR%RUNDEF)
  ZDATA = HUGE (YDHDR%RUNDEF)
END WHERE
YDHDR%RUNDEF = HUGE (YDHDR%RUNDEF)

CALL YLMETA%SET ("undef", YDHDR%RUNDEF)
CALL YLMETA%FINAL ()

CALL YLFLD%RETURN ()

END FUNCTION

SUBROUTINE HDR (CDFILE, YDHDR)

CHARACTER (LEN=*), INTENT (IN)  :: CDFILE
TYPE (HDR_t),      INTENT (OUT) :: YDHDR

CHARACTER (LEN=256) :: CLLINE

OPEN (77, FILE=TRIM (CDFILE)//'.hdr', FORM='FORMATTED')

READ (77, '(A)') CLLINE

YDHDR%CLCOMMENT = CLLINE

DO 
  READ (77, '(A256)', END=999) CLLINE
  IF (CLLINE (1:7) == 'nodata:'             ) READ (CLLINE ( 8:), *) YDHDR%RUNDEF
  IF (CLLINE (1:6) == 'north:'              ) READ (CLLINE ( 7:), *) YDHDR%ZNORTH
  IF (CLLINE (1:6) == 'south:'              ) READ (CLLINE ( 7:), *) YDHDR%ZSOUTH
  IF (CLLINE (1:5) == 'west:'               ) READ (CLLINE ( 6:), *) YDHDR%ZWEST
  IF (CLLINE (1:5) == 'east:'               ) READ (CLLINE ( 6:), *) YDHDR%ZEAST
  IF (CLLINE (1:5) == 'rows:'               ) READ (CLLINE ( 6:), *) YDHDR%IROWS
  IF (CLLINE (1:5) == 'cols:'               ) READ (CLLINE ( 6:), *) YDHDR%ICOLS
  IF (CLLINE (1:19) == 'recordtype: integer') READ (CLLINE (20:), *) YDHDR%IWIDTH
ENDDO

999 CONTINUE

CLOSE (77)

SELECT CASE (YDHDR%IWIDTH)

  CASE ( 8)
  
    IF (YDHDR%RUNDEF < 0) YDHDR%RUNDEF = YDHDR%RUNDEF + 256._JPRB

  CASE DEFAULT

END SELECT


END SUBROUTINE 

SUBROUTINE COMPARE_GEOMHDR (YDHDR1, YDHDR2)

TYPE (HDR_t),  INTENT (IN) :: YDHDR1, YDHDR2

#include "abor1.intfb.h"

IF (YDHDR1%ZWEST  /= YDHDR2%ZWEST ) CALL ABOR1 ('COMPARE_GEOMHDR: DIFFERENT ZWEST ')
IF (YDHDR1%ZEAST  /= YDHDR2%ZEAST ) CALL ABOR1 ('COMPARE_GEOMHDR: DIFFERENT ZEAST ')
IF (YDHDR1%ZNORTH /= YDHDR2%ZNORTH) CALL ABOR1 ('COMPARE_GEOMHDR: DIFFERENT ZNORTH')
IF (YDHDR1%ZSOUTH /= YDHDR2%ZSOUTH) CALL ABOR1 ('COMPARE_GEOMHDR: DIFFERENT ZSOUTH')
IF (YDHDR1%ICOLS  /= YDHDR2%ICOLS ) CALL ABOR1 ('COMPARE_GEOMHDR: DIFFERENT ICOLS ')
IF (YDHDR1%IROWS  /= YDHDR2%IROWS ) CALL ABOR1 ('COMPARE_GEOMHDR: DIFFERENT IROWS ')

END SUBROUTINE

END

