PROGRAM ATLAS_PGD

USE PARKIND1, ONLY : JPIM, JPRB
USE INTERPOLATIONA_MOD
USE GRADIENT_MOD
USE ATLAS_ARPEGE_MODULE, ONLY : WFA, GFA
USE FCKIT_MODULE, ONLY : FCKIT_MPI_COMM
USE ATLAS_MODULE  
USE XRD_GETOPTIONS

!

IMPLICIT NONE

TYPE (ATLAS_STRUCTUREDGRID)                  :: YLGRID1
TYPE (ATLAS_STRUCTUREDGRID)                  :: YLGRID2
TYPE (ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS) :: YLFSSC1
TYPE (ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS) :: YLFSSC2
TYPE (ATLAS_GRIDDISTRIBUTION)                :: YLDIST1
TYPE (ATLAS_GRIDDISTRIBUTION)                :: YLDIST2
TYPE (INTERPOLATIONA)                        :: YLINTEA
TYPE (ATLAS_FIELDSET)                        :: YLFLDS1  
TYPE (ATLAS_FIELDSET)                        :: YLFLDS2
TYPE (ATLAS_FIELDSET)                        :: YLFLDS2I
TYPE (FCKIT_MPI_COMM)                        :: YLCOMM

REAL (KIND=JPRB), PARAMETER :: RPI = 2.0_JPRB * ASIN (1.0_JPRB)

INTEGER (KIND=JPIM) :: I, JFLD
INTEGER (KIND=JPIM) :: NPROC, IRANK

TYPE HDR_t
  REAL (KIND=JPRB) :: RUNDEF = HUGE (0._JPRB)
  REAL (KIND=JPRB) :: ZWEST = -999, ZEAST = -999, ZNORTH = -999, ZSOUTH = -999
  INTEGER (KIND=JPIM) :: ICOLS = -999, IROWS = -999, IWIDTH = -999
  CHARACTER (LEN=256) :: CLCOMMENT = ''
END TYPE HDR_t

TYPE PTR
  REAL (KIND=JPRB), POINTER :: ZDATA (:) => NULL ()
END TYPE PTR

INTERFACE CREATE_GRID
  PROCEDURE CREATE_GRID_HDR
  PROCEDURE CREATE_GRID_NML
END INTERFACE CREATE_GRID

TYPE (ATLAS_FIELD) :: YLCOVR1, YLOROG1, YLSAND1, YLCLAY1
TYPE (ATLAS_FIELD) :: YLOROG2, YLSAND2, YLCLAY2
TYPE (ATLAS_FIELD), ALLOCATABLE :: YLCOVR2 (:)

INTEGER (KIND=JPIM), PARAMETER :: INCOVR = 256_JPIM
LOGICAL, ALLOCATABLE :: LCOVER (:)
REAL (KIND=JPRB), PARAMETER :: ZUNDEF = HUGE (1._JPRB)

TYPE (HDR_t) :: YLHDRS (4), YLHDR
CHARACTER (LEN=32), PARAMETER :: CLDATA (4) = [ &
!                         01234567890123456789012345678901
&                        'SFX.ZS                          ', &
&                        'SFX.CLAY                        ', &
&                        'SFX.SAND                        ', &
&                        'SFX.COVER                       ' ]

INTEGER (KIND=JPIM), PARAMETER :: JOROG_DAT = 1, JCLAY_DAT = 2, &
                                & JSAND_DAT = 3, JCOVR_DAT = 4

LOGICAL, PARAMETER :: LGARDEN = .FALSE., LWATER_TO_NATURE = .FALSE., LTOWN_TO_ROCK = .TRUE.

CALL INITOPTIONS 

CALL CHECKOPTIONS

CALL ATLAS_LIBRARY%INITIALISE ()

DO I = 1, SIZE (CLDATA)
  CALL HDR (TRIM (CLDATA (I)), YLHDRS (I))
ENDDO

YLHDR = YLHDRS (1)

DO I = 1, 4
  CALL COMPARE_GEOMHDR (YLHDR, YLHDRS (I))
ENDDO

YLCOMM = FCKIT_MPI_COMM ()
NPROC  = YLCOMM%SIZE ()
IRANK  = YLCOMM%RANK ()

CALL LINUX_BIND (IRANK, NPROC)

CALL CREATE_GRID (YLGRID1, YLHDR)
CALL CREATE_GRID (YLGRID2, 'fort.4')

CALL CREATE_DIST (YLGRID1, YLDIST1, .TRUE.)
CALL CREATE_DIST (YLGRID2, YLDIST2)

BLOCK
  TYPE (ATLAS_CONFIG) :: YLCONF
  YLCONF = ATLAS_CONFIG ()
  CALL YLCONF%SET ("halo", 1)
  CALL YLCONF%SET ("periodic_points", .TRUE.)
  YLFSSC1 = ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS (YLGRID1, YLDIST1, YLCONF)
  YLFSSC2 = ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS (YLGRID2, YLDIST2, YLCONF)
  CALL YLCONF%FINAL ()
ENDBLOCK

YLFLDS1 = ATLAS_FIELDSET ()
YLFLDS2 = ATLAS_FIELDSET ()


YLINTEA = INTERPOLATIONA (YLDIST1, YLFSSC1, YLDIST2, YLFSSC2)

YLOROG1 = DIR (CLDATA (JOROG_DAT), YLHDRS (JOROG_DAT), YLFSSC1, YLGRID1, YLDIST1)
YLCLAY1 = DIR (CLDATA (JCLAY_DAT), YLHDRS (JCLAY_DAT), YLFSSC1, YLGRID1, YLDIST1, 0.01_JPRB)
YLSAND1 = DIR (CLDATA (JSAND_DAT), YLHDRS (JSAND_DAT), YLFSSC1, YLGRID1, YLDIST1, 0.01_JPRB)
YLCOVR1 = DIR (CLDATA (JCOVR_DAT), YLHDRS (JCOVR_DAT), YLFSSC1, YLGRID1, YLDIST1)

CALL YLFLDS1%ADD (YLOROG1)
CALL YLFLDS1%ADD (YLCLAY1)
CALL YLFLDS1%ADD (YLSAND1)

! Create covers

BLOCK
  TYPE (ATLAS_FIELD) :: YLCOVR2E
  INTEGER (KIND=JPIM), ALLOCATABLE :: IOFF (:), ICNT (:)
  TYPE (PTR), ALLOCATABLE :: YLPTR (:)
  REAL (KIND=JPRB), POINTER :: ZCOVR2E (:)
  INTEGER (KIND=JPIM) :: JLOC2, ICOV, II
  CHARACTER (LEN=16) :: CLNOMA

  IOFF = YLINTEA%GETOFF ()
  ICNT = YLINTEA%GETCNT ()

  YLCOVR2E = YLINTEA%SHUFFLE (YLCOVR1)

  CALL YLCOVR2E%DATA (ZCOVR2E)

  ALLOCATE (YLCOVR2 (INCOVR), YLPTR (INCOVR))

  DO ICOV = 1, INCOVR
    WRITE (CLNOMA, '("SFX.COVER",I3.3)') ICOV
    YLCOVR2 (ICOV) = ATLAS_FIELD (NAME=TRIM (CLNOMA), KIND=JPRB, SHAPE=[YLFSSC2%SIZE ()])
    CALL YLFLDS2%ADD (YLCOVR2 (ICOV))
    CALL YLCOVR2 (ICOV)%DATA (YLPTR (ICOV)%ZDATA)
    YLPTR (ICOV)%ZDATA = 0._JPRB
  ENDDO


  DO JLOC2 = 1, YLFSSC2%SIZE_OWNED ()
    DO II = IOFF (JLOC2)+1, IOFF (JLOC2)+ICNT (JLOC2)
      ICOV = INT (ZCOVR2E (II))
      IF ((ICOV < 1) .OR. (ICOV > INCOVR)) THEN
        CALL ABOR1 ('ATLAS_PGD: UNEXPECTED COVER VALUE')
      ENDIF
      YLPTR (ICOV)%ZDATA (JLOC2) = YLPTR (ICOV)%ZDATA (JLOC2) + 1._JPRB
    ENDDO
    DO ICOV = 1, INCOVR
      YLPTR (ICOV)%ZDATA (JLOC2) = YLPTR (ICOV)%ZDATA (JLOC2) / REAL (ICNT (JLOC2), JPRB)
    ENDDO
  ENDDO

  CALL YLCOVR2E%FINAL ()
ENDBLOCK


! Set missing values of orography

BLOCK
  REAL (KIND=JPRB), POINTER :: ZOROG1 (:), ZCOVR1 (:)
  CALL YLCOVR1%DATA (ZCOVR1)
  CALL YLOROG1%DATA (ZOROG1)
  WHERE (ZCOVR1 == 1._JPRB) ! Sea 
    ZOROG1 = ZUNDEF
  ENDWHERE
ENDBLOCK



! Compute orography gradient

BLOCK
  TYPE (ATLAS_FIELDSET) :: YLFSGR1
  TYPE (ATLAS_FIELD) :: YLOROG1DX, YLOROG1DY
  TYPE (ATLAS_FIELD) :: YLOROG1_2, YLOROG1DX_DX, YLOROG1DY_DY, YLOROG1DX_DY
  REAL (KIND=JPRB), POINTER :: ZOROG1DX (:), ZOROG1DY (:), ZOROG1_2 (:), ZOROG1DX_DX (:), &
                             & ZOROG1DY_DY (:), ZOROG1DX_DY (:), ZOROG1 (:)

  YLFSGR1 = GRADIENT (YLFSSC1, YLOROG1)

  YLOROG1DX = YLFSGR1%FIELD ("SFX.ZS.DX")
  YLOROG1DY = YLFSGR1%FIELD ("SFX.ZS.DY")

  CALL YLOROG1  %DATA (ZOROG1  )
  CALL YLOROG1DX%DATA (ZOROG1DX)
  CALL YLOROG1DY%DATA (ZOROG1DY)

  CALL ROTATE (YLFSSC1, YLGRID2, YLFSGR1)

  YLOROG1_2    = NEWFLD (YLFSSC1, "SFX.ZS_2"    , ZUNDEF)
  YLOROG1DX_DX = NEWFLD (YLFSSC1, "SFX.ZS.DX_DX", ZUNDEF)
  YLOROG1DY_DY = NEWFLD (YLFSSC1, "SFX.ZS.DY_DY", ZUNDEF)
  YLOROG1DX_DY = NEWFLD (YLFSSC1, "SFX.ZS.DX_DY", ZUNDEF)

  CALL YLFLDS1%ADD (YLOROG1_2   )
  CALL YLFLDS1%ADD (YLOROG1DX_DX)
  CALL YLFLDS1%ADD (YLOROG1DY_DY)
  CALL YLFLDS1%ADD (YLOROG1DX_DY)

  CALL YLOROG1_2   %DATA (ZOROG1_2   )
  CALL YLOROG1DX_DX%DATA (ZOROG1DX_DX)
  CALL YLOROG1DY_DY%DATA (ZOROG1DY_DY)
  CALL YLOROG1DX_DY%DATA (ZOROG1DX_DY)

  WHERE (ZOROG1 /= ZUNDEF)
    ZOROG1DX_DX = ZOROG1DX * ZOROG1DX 
    ZOROG1DY_DY = ZOROG1DY * ZOROG1DY
    ZOROG1DX_DY = ZOROG1DX * ZOROG1DY
    ZOROG1_2    = ZOROG1   * ZOROG1
  ELSEWHERE
    ZOROG1DX_DX = ZUNDEF
    ZOROG1DY_DY = ZUNDEF
    ZOROG1DX_DY = ZUNDEF
    ZOROG1_2    = ZUNDEF
  ENDWHERE

  CALL YLOROG1DX   %FINAL ()
  CALL YLOROG1DY   %FINAL ()

  CALL YLOROG1_2   %FINAL ()
  CALL YLOROG1DX_DX%FINAL () 
  CALL YLOROG1DY_DY%FINAL () 
  CALL YLOROG1DX_DY%FINAL ()

ENDBLOCK

! Interpolate fields


YLFLDS2I = YLINTEA%INTERPOLATE (YLFLDS1)
YLOROG2 = YLFLDS2I%FIELD ("SFX.ZS")
YLSAND2 = YLFLDS2I%FIELD ("SFX.SAND")
YLCLAY2 = YLFLDS2I%FIELD ("SFX.CLAY")

CALL YLFLDS2%ADD (YLOROG2)
CALL YLFLDS2%ADD (YLSAND2)
CALL YLFLDS2%ADD (YLCLAY2)

! Min, max, avg orography

BLOCK

  TYPE (ATLAS_FIELD) :: YLOROG2_AVG, YLOROG2_MIN, YLOROG2_MAX, YLOROG2_SIL
  REAL (KIND=JPRB), POINTER :: ZOROG2 (:), ZOROG2_AVG (:), ZOROG2_SIL (:)

  YLOROG2_AVG = NEWFLD (YLFSSC2, "SFX.AVG_ZS", ZUNDEF)
  YLOROG2_SIL = NEWFLD (YLFSSC2, "SFX.SIL_ZS", ZUNDEF)

  CALL YLOROG2    %DATA (ZOROG2   )
  CALL YLOROG2_SIL%DATA (ZOROG2_SIL)
  CALL YLOROG2_AVG%DATA (ZOROG2_AVG)

  ZOROG2_SIL = ZOROG2
  ZOROG2_AVG = ZOROG2

  YLOROG2_MIN = YLINTEA%INTERPOLATE (YLOROG1, YLINTEA%OPT_MIN ())
  CALL YLOROG2_MIN%RENAME ("SFX.MIN_ZS")
  YLOROG2_MAX = YLINTEA%INTERPOLATE (YLOROG1, YLINTEA%OPT_MAX ())
  CALL YLOROG2_MAX%RENAME ("SFX.MAX_ZS")

  CALL YLFLDS2%ADD (YLOROG2_AVG)
  CALL YLFLDS2%ADD (YLOROG2_MIN)
  CALL YLFLDS2%ADD (YLOROG2_MAX)
  CALL YLFLDS2%ADD (YLOROG2_SIL)

  CALL YLOROG2_AVG%FINAL ()
  CALL YLOROG2_MIN%FINAL ()
  CALL YLOROG2_MAX%FINAL ()
  CALL YLOROG2_SIL%FINAL ()

  CALL YLOROG1%FINAL ()

ENDBLOCK


! Compute SSO parameters

BLOCK
  REAL (KIND=JPIM), PARAMETER :: XPI = RPI
  TYPE (ATLAS_FIELD) :: YLOROG2_2, YLOROG2DX_DX, YLOROG2DY_DY, YLOROG2DX_DY
  TYPE (ATLAS_FIELD) :: YLSSODIR2, YLSSOSLO2, YLSSOANI2, YLSSOSTD2
  REAL (KIND=JPRB), POINTER :: ZH (:), ZH2 (:), ZHXX (:), ZHYY (:), ZHXY (:)
  REAL (KIND=JPRB), POINTER :: XSSO_DIR  (:), XSSO_SLOPE (:), &
                             & XSSO_ANIS (:), XSSO_STDEV (:)
  LOGICAL :: OSSO (YLFSSC2%SIZE ()), OSSO_ANIS (YLFSSC2%SIZE ())
  REAL (KIND=JPRB) :: ZK (YLFSSC2%SIZE ()), ZL (YLFSSC2%SIZE ()), ZM (YLFSSC2%SIZE ())

  YLOROG2_2    = YLFLDS2I%FIELD ("SFX.ZS_2"    )
  YLOROG2DX_DX = YLFLDS2I%FIELD ("SFX.ZS.DX_DX")
  YLOROG2DY_DY = YLFLDS2I%FIELD ("SFX.ZS.DY_DY")
  YLOROG2DX_DY = YLFLDS2I%FIELD ("SFX.ZS.DX_DY")

  YLSSODIR2 = NEWFLD (YLFSSC2, "SFX.SSO_DIR"  , ZUNDEF)
  YLSSOSLO2 = NEWFLD (YLFSSC2, "SFX.SSO_SLOPE", ZUNDEF)
  YLSSOANI2 = NEWFLD (YLFSSC2, "SFX.SSO_ANIS" , ZUNDEF)
  YLSSOSTD2 = NEWFLD (YLFSSC2, "SFX.SSO_STDEV", ZUNDEF)

  CALL YLOROG2     %DATA (ZH  )
  CALL YLOROG2_2   %DATA (ZH2 )
  CALL YLOROG2DX_DX%DATA (ZHXX)
  CALL YLOROG2DY_DY%DATA (ZHYY)
  CALL YLOROG2DX_DY%DATA (ZHXY)

  CALL YLSSODIR2%DATA (XSSO_DIR  )
  CALL YLSSOSLO2%DATA (XSSO_SLOPE)
  CALL YLSSOANI2%DATA (XSSO_ANIS )
  CALL YLSSOSTD2%DATA (XSSO_STDEV)

  OSSO = ZH /= ZUNDEF
  OSSO_ANIS = OSSO 

  WHERE (OSSO (:)) 
    ZK(:)=0.5*(ZHXX(:)+ZHYY(:))
    ZL(:)=0.5*(ZHXX(:)-ZHYY(:))
    ZM(:)=     ZHXY(:)
  ELSE WHERE
    ZK(:) = ZUNDEF
    ZL(:) = ZUNDEF
    ZM(:) = ZUNDEF
    ZHXX = ZUNDEF
    ZHYY = ZUNDEF
    ZHXY = ZUNDEF
    XSSO_DIR   = ZUNDEF
    XSSO_SLOPE = ZUNDEF
    XSSO_ANIS  = ZUNDEF
  END WHERE

  !
  !*    8.     S.S.O. characteristics
  !            ----------------------
  !
  !*    8.1    S.S.O. direction of main axis
  !            -----------------------------
  !
  WHERE (OSSO(:))
    XSSO_DIR(:) = 0.5_JPRB * ATAN2 (ZM, ZL) * (180._JPRB / XPI) 
  END WHERE
  !
  !*    8.2    S.S.O. slope
  !            ------------
  !
  WHERE (OSSO(:))
    XSSO_SLOPE(:) = SQRT( ZK+SQRT(ZL*ZL+ZM*ZM) )
  END WHERE
  !
  !*    8.3    S.S.O. anisotropy
  !            -----------------
  !
  WHERE (OSSO_ANIS(:) .AND. (ZK+SQRT(ZL*ZL+ZM*ZM)) >0. )
    XSSO_ANIS(:)=SQRT( MAX(ZK-SQRT(ZL*ZL+ZM*ZM),0.) / (ZK+SQRT(ZL*ZL+ZM*ZM)))
  END WHERE
  !
  WHERE (OSSO_ANIS(:) .AND. (ZK+SQRT(ZL*ZL+ZM*ZM))==0. )
    XSSO_ANIS(:)=1.
  END WHERE

! Orography standard deviation

  WHERE (OSSO (:))
    XSSO_STDEV = SQRT (ZH2 - ZH**2)
  ELSE WHERE
    XSSO_STDEV = ZUNDEF
  END WHERE

! Add enveloppe

  WHERE (ZH (:) /= ZUNDEF)
    ZH (:) = ZH (:) + XSSO_STDEV (:)
  ENDWHERE

  CALL YLFLDS2%ADD (YLSSODIR2)
  CALL YLFLDS2%ADD (YLSSOSLO2)
  CALL YLFLDS2%ADD (YLSSOANI2)
  CALL YLFLDS2%ADD (YLSSOSTD2)

  CALL YLSSODIR2%FINAL ()
  CALL YLSSOSLO2%FINAL ()
  CALL YLSSOANI2%FINAL ()
  CALL YLSSOSTD2%FINAL ()

  CALL YLOROG2_2   %FINAL ()
  CALL YLOROG2DX_DX%FINAL () 
  CALL YLOROG2DY_DY%FINAL () 
  CALL YLOROG2DX_DY%FINAL ()

ENDBLOCK


! Compute AOS parameters

BLOCK
  TYPE (INTERPOLATION4) :: YLINTE4

  ! Interpolate from target geometry to origin geometry (fine lat/lon)
  YLINTE4 = INTERPOLATION4 (YLDIST2, YLFSSC2, YLDIST1, YLFSSC1)


  CALL YLINTE4%FINAL ()

ENDBLOCK

! Compute fractions

BLOCK
  USE READCOVERS_MOD
  TYPE (COVERS_t) :: YLCOVERS
  REAL (KIND=JPRB) :: ZAVGCOVR2 (INCOVR)
  REAL (KIND=JPRB) :: ZMINCOVR2 (INCOVR)
  REAL (KIND=JPRB) :: ZMAXCOVR2 (INCOVR)
  INTEGER (KIND=JPIM) :: JCOV

  TYPE (ATLAS_FIELD) :: YLFRAC_SEA, YLFRAC_NATURE, YLFRAC_TOWN, YLFRAC_WATER
  REAL (KIND=JPRB), POINTER :: ZFRAC_SEA (:), ZFRAC_NATURE (:), ZFRAC_TOWN (:), ZFRAC_WATER (:)

  YLFRAC_SEA    = NEWFLD (YLFSSC2, "SFX.FRAC_SEA"   , ZUNDEF)
  YLFRAC_NATURE = NEWFLD (YLFSSC2, "SFX.FRAC_NATURE", ZUNDEF)
  YLFRAC_TOWN   = NEWFLD (YLFSSC2, "SFX.FRAC_TOWN"  , ZUNDEF)
  YLFRAC_WATER  = NEWFLD (YLFSSC2, "SFX.FRAC_WATER" , ZUNDEF)

  CALL YLFRAC_SEA   %DATA (ZFRAC_SEA   )
  CALL YLFRAC_NATURE%DATA (ZFRAC_NATURE)
  CALL YLFRAC_TOWN  %DATA (ZFRAC_TOWN  )
  CALL YLFRAC_WATER %DATA (ZFRAC_WATER )
  
  CALL READCOVERS (YLCOVERS, 1, LGARDEN, LWATER_TO_NATURE, LTOWN_TO_ROCK)
  CALL FIELDSTAT (YLFSSC2, YLCOVR2, PMIN=ZMINCOVR2, PMAX=ZMAXCOVR2, PAVG=ZAVGCOVR2)

  ALLOCATE (LCOVER (YLCOVERS%JPCOVER))
  LCOVER = .FALSE.

  LCOVER = ZAVGCOVR2 > 0._JPRB

  CALL MAKEFRAC (ZFRAC_SEA   , YLCOVR2, YLCOVERS%XDATA_SEA   , LCOVER)
  CALL MAKEFRAC (ZFRAC_NATURE, YLCOVR2, YLCOVERS%XDATA_NATURE, LCOVER)
  CALL MAKEFRAC (ZFRAC_TOWN  , YLCOVR2, YLCOVERS%XDATA_TOWN  , LCOVER)
  CALL MAKEFRAC (ZFRAC_WATER , YLCOVR2, YLCOVERS%XDATA_WATER , LCOVER)

  CALL YLFLDS2%ADD (YLFRAC_SEA   )
  CALL YLFLDS2%ADD (YLFRAC_NATURE)
  CALL YLFLDS2%ADD (YLFRAC_TOWN  )
  CALL YLFLDS2%ADD (YLFRAC_WATER )

  CALL YLFRAC_SEA   %FINAL ()
  CALL YLFRAC_NATURE%FINAL ()
  CALL YLFRAC_TOWN  %FINAL ()
  CALL YLFRAC_WATER %FINAL ()
  
ENDBLOCK

! Other

BLOCK
  TYPE (ATLAS_FIELD) :: YLBATHY2, YLRUNOFFB2, YLWDRAIN2, YLFRAC_SEA, YLFRAC_NATURE
  REAL (KIND=JPRB), POINTER :: ZBATHY2 (:), ZRUNOFF2 (:), ZWDRAIN2 (:), ZFRAC_SEA (:), ZFRAC_NATURE (:)

  YLFRAC_SEA    = YLFLDS2%FIELD ("SFX.FRAC_SEA"   )
  YLFRAC_NATURE = YLFLDS2%FIELD ("SFX.FRAC_NATURE")

  CALL YLFRAC_SEA   %DATA (ZFRAC_SEA   )
  CALL YLFRAC_NATURE%DATA (ZFRAC_NATURE)

  YLBATHY2   = NEWFLD (YLFSSC2, "SFX.BATHY"    , ZUNDEF)
  YLRUNOFFB2 = NEWFLD (YLFSSC2, "SFX.RUNOFF"   , ZUNDEF)
  YLWDRAIN2  = NEWFLD (YLFSSC2, "SFX.WDRAIN"   , ZUNDEF)

  CALL YLBATHY2  %DATA (ZBATHY2 )
  CALL YLRUNOFFB2%DATA (ZRUNOFF2)
  CALL YLWDRAIN2 %DATA (ZWDRAIN2)

  WHERE (ZFRAC_SEA > 0._JPRB)
    ZBATHY2 = -300._JPRB
  ELSEWHERE
    ZBATHY2 = ZUNDEF
  ENDWHERE

  WHERE (ZFRAC_NATURE > 0._JPRB)
    ZRUNOFF2 = 0.5_JPRB
    ZRUNOFF2 = 0.0_JPRB
  ELSEWHERE
    ZWDRAIN2 = ZUNDEF
    ZWDRAIN2 = ZUNDEF
  ENDWHERE

  CALL YLFLDS2%ADD (YLBATHY2  )
  CALL YLFLDS2%ADD (YLRUNOFFB2)
  CALL YLFLDS2%ADD (YLWDRAIN2 )

  CALL YLBATHY2  %FINAL ()
  CALL YLRUNOFFB2%FINAL ()
  CALL YLWDRAIN2 %FINAL ()

ENDBLOCK

! Fix missing values: orography stuff, set to zero

BLOCK
  CHARACTER (LEN=16) :: CLNOMA
  CHARACTER (LEN=16), PARAMETER :: CLSUFF (*) = &
& ["ZS              ", "SSO_DIR         ", "SSO_SLOPE       ", &
&  "SSO_ANIS        ", "SSO_STDEV       ", "AOSIP           ", &
&  "AOSIM           ", "AOSJP           ", "AOSJM           ", & 
&  "HO2IP           ", "HO2IM           ", "HO2JP           ", &
&  "HO2JM,          ", "MIN_ZS          ", "MAX_ZS          ", &
&  "AVG_ZS          ", "SIL_ZS          "]
  REAL (KIND=JPRB), POINTER :: ZFLD (:)
  TYPE (ATLAS_FIELD) :: YLFLD

  DO JFLD = 1, SIZE (CLSUFF)
    CLNOMA = "SFX."//CLSUFF (JFLD)
    IF (YLFLDS2%HAS_FIELD (TRIM (CLNOMA))) THEN
      YLFLD = YLFLDS2%FIELD (TRIM (CLNOMA))
      CALL YLFLD%DATA (ZFLD)
      WHERE (ZFLD == ZUNDEF)
        ZFLD = 0._JPRB
      ENDWHERE
      CALL YLFLD%FINAL ()
    ENDIF
  ENDDO

ENDBLOCK


CALL WFA ('PGD2.fa', YLGRID2, YLFSSC2, YLFLDS2)

CALL YLOROG1%FINAL ()
CALL YLSAND1%FINAL ()
CALL YLCLAY1%FINAL ()
CALL YLCOVR1%FINAL ()

DO JFLD = 1, INCOVR
  CALL YLCOVR2 (JFLD)%FINAL ()
ENDDO

CALL YLFLDS2I%FINAL ()
CALL YLFLDS2%FINAL ()

CALL YLINTEA%FINAL ()

CALL ATLAS_LIBRARY%FINALISE()


WRITE (*, *) "--- STOP ---"

CONTAINS

LOGICAL ELEMENTAL FUNCTION ISINF (X)

REAL (KIND=JPRB), INTENT (IN) :: X

ISINF = X > HUGE (X)

END FUNCTION

SUBROUTINE CREATE_GRID_HDR (YDGRID, YDHDR)

TYPE (ATLAS_STRUCTUREDGRID) :: YDGRID
TYPE (HDR_t)                :: YDHDR

TYPE (ATLAS_CONFIG) :: YLCFGR, YLCFDO

YLCFGR = ATLAS_CONFIG ()
YLCFDO = ATLAS_CONFIG ()

CALL YLCFGR%SET ("nx", YDHDR%ICOLS)
CALL YLCFGR%SET ("ny", YDHDR%IROWS)
CALL YLCFGR%SET ("type", "shifted_lonlat")
CALL YLCFDO%SET ("type", "global")
CALL YLCFDO%SET ("units", "degrees")
CALL YLCFDO%SET ("west", YDHDR%ZWEST)
CALL YLCFGR%SET ("domain", YLCFDO)

YDGRID = ATLAS_STRUCTUREDGRID (YLCFGR)

CALL YLCFGR%FINAL ()
CALL YLCFDO%FINAL ()

END SUBROUTINE

SUBROUTINE CREATE_GRID_NML (YDGRID, CDNML)

TYPE (ATLAS_STRUCTUREDGRID) :: YDGRID
CHARACTER (LEN=*)           :: CDNML

LOGICAL :: LLEXIST

TYPE GRID_OPTIONS_t
  INTEGER (KIND=JPIM) :: NLOEN (30000) = 0
  INTEGER (KIND=JPIM) :: NDLON = 0, NDGLG = 0
  LOGICAL :: LELAM    = .FALSE.
  LOGICAL :: LROTATED = .FALSE. 
  LOGICAL :: LSTRETCH = .FALSE.
  REAL (KIND=JPRB) :: RSTRETCH = 1._JPRB
  REAL (KIND=JPRB) :: RLONCENT = 0._JPRB  ! Degrees
  REAL (KIND=JPRB) :: RLATCENT = 90._JPRB ! Degrees

  REAL (KIND=JPRB) :: DXINMETRES = 10000._JPRB
  REAL (KIND=JPRB) :: DYINMETRES = 10000._JPRB

  REAL (KIND=JPRB) :: LADINDEGREES    = 46.2_JPRB
  REAL (KIND=JPRB) :: LATIN1INDEGREES = 46.2_JPRB
  REAL (KIND=JPRB) :: LATIN2INDEGREES = 46.2_JPRB
  REAL (KIND=JPRB) :: LOVINDEGREES    =  2.0_JPRB
  INTEGER (KIND=JPIM) :: NUX, NUY
END TYPE GRID_OPTIONS_t

TYPE (GRID_OPTIONS_t) :: YLGROPT

NAMELIST / NAMGRID / YLGROPT

OPEN (4, FILE=TRIM (CDNML), FORM="FORMATTED")
READ (4, NAMGRID)
CLOSE (4)

IF (YLGROPT%LELAM) THEN
  YDGRID = ATLAS_LAMBERTREGIONALGRID (YLGROPT%NDLON, YLGROPT%NDGLG, &
                                    & -YLGROPT%NUX / 2 * YLGROPT%DXINMETRES, &
                                    & -YLGROPT%NUY / 2 * YLGROPT%DYINMETRES, &
                                    & YLGROPT%DXINMETRES, YLGROPT%DYINMETRES, &
                                    & YLGROPT%LOVINDEGREES, YLGROPT%LADINDEGREES, &
                                    & YLGROPT%LATIN1INDEGREES, YLGROPT%LATIN2INDEGREES)
ELSE IF (YLGROPT%RLONCENT /= 0._JPRB .OR. YLGROPT%RLATCENT /= 90._JPRB) THEN
  YDGRID = ATLAS_REDUCEDGAUSSIANGRID (YLGROPT%NLOEN (1:YLGROPT%NDGLG), &
          & [YLGROPT%RLONCENT, YLGROPT%RLATCENT], YLGROPT%RSTRETCH)
ELSE
  YDGRID = ATLAS_REDUCEDGAUSSIANGRID (YLGROPT%NLOEN (1:YLGROPT%NDGLG))
ENDIF

END SUBROUTINE

SUBROUTINE CREATE_DIST (YDGRID, YDDIST, LDLIGHT)

USE ATLAS_ARPEGE_MODULE, ONLY : ISMGLO, ISMLAM, ISLTLN

TYPE (ATLAS_STRUCTUREDGRID)   :: YDGRID
TYPE (ATLAS_GRIDDISTRIBUTION) :: YDDIST
LOGICAL, OPTIONAL             :: LDLIGHT

#include "abor1.intfb.h"

TYPE (ATLAS_CONFIG) :: YLCONF

CHARACTER (LEN=64)  :: CLDIST
LOGICAL             :: LLLIGHT

IF (ISMGLO (YDGRID)) THEN
  CLDIST = "equal_regions"
ELSE
  CLDIST = "checkerboard"
ENDIF

LLLIGHT = .FALSE.
IF (PRESENT (LDLIGHT)) LLLIGHT = LDLIGHT

YLCONF = ATLAS_CONFIG() 

SELECT CASE (CLDIST)
  CASE ('checkerboard') 
    CALL YLCONF%SET ('type', 'checkerboard')
    IF (LLLIGHT) THEN
      CALL YLCONF%SET ('light', .TRUE.)
      CALL YLCONF%SET ('blocksize', INT (YDGRID%NX (1)))
    ENDIF
  CASE ('equal_regions')
    CALL YLCONF%SET ('type', 'equal_regions')
  CASE DEFAULT
    CALL ABOR1 ('UNKNOWN DISTRIBUTION TYPE :'//TRIM (CLDIST))
END SELECT 

YDDIST = ATLAS_GRIDDISTRIBUTION (YDGRID, YLCONF)

CALL YLCONF%FINAL ()

END SUBROUTINE

FUNCTION NEWFLD (YDFSSC, CDNAME, PUNDEF) RESULT (YLFLD)

TYPE (ATLAS_FIELD) :: YLFLD

TYPE (ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS), INTENT (IN)  :: YDFSSC
CHARACTER (LEN=*),                            INTENT (IN)  :: CDNAME
REAL (KIND=JPRB), OPTIONAL,                   INTENT (IN)  :: PUNDEF

TYPE (ATLAS_METADATA) :: YLMETA

YLFLD = ATLAS_FIELD (NAME=TRIM (CDNAME), KIND=JPRB, SHAPE=[YDFSSC%SIZE ()])

IF (PRESENT (PUNDEF)) THEN
  YLMETA = YLFLD%METADATA ()
  CALL YLMETA%SET ("undef", PUNDEF)
  CALL YLMETA%FINAL ()
ENDIF

CALL YLFLD%RETURN ()

END FUNCTION

FUNCTION DIR (CDFILE, YDHDR, YDFSSC, YDGRID, YDDIST, PSCALE) RESULT (YLFLD)

TYPE (ATLAS_FIELD) :: YLFLD

CHARACTER (LEN=*),                            INTENT (IN)     :: CDFILE
TYPE (HDR_t),                                 INTENT (INOUT)  :: YDHDR
TYPE (ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS), INTENT (IN)     :: YDFSSC
TYPE (ATLAS_STRUCTUREDGRID),                  INTENT (IN)     :: YDGRID
TYPE (ATLAS_GRIDDISTRIBUTION),                INTENT (IN)     :: YDDIST
REAL (KIND=JPRB), OPTIONAL,                   INTENT (IN)     :: PSCALE

INTEGER (KIND=JPIM), ALLOCATABLE :: ISIZE (:)
INTEGER (KIND=JPIM) :: IPROC, IOFFS (NPROC+1), INX

INTEGER*1, ALLOCATABLE :: IL1 (:)
INTEGER*2, ALLOCATABLE :: IL2 (:)
INTEGER (KIND=JPIM) :: IROW, ICOL, IOFF, JLAT, IROW1, IROW2
REAL (KIND=JPRB), POINTER :: ZDATA (:)

YLFLD = NEWFLD (YDFSSC, TRIM (CDFILE), ZUNDEF)

CALL YLFLD%DATA (ZDATA)

ISIZE = YDDIST%NB_PTS ()

IOFFS (1) = 0
DO IPROC = 2, NPROC+1
  IOFFS (IPROC) = IOFFS (IPROC-1) + ISIZE (IPROC-1)
ENDDO

IPROC = IRANK + 1

INX = YDGRID%NX (1)

IF (MODULO (IOFFS (IPROC), INX) /= 0) THEN
  CALL ABOR1 ('DIR: DISTRIBUTION MISMATCH')
ENDIF

IROW1 = 1 + IOFFS (IPROC+0) / INX
IROW2 = 0 + IOFFS (IPROC+1) / INX

IF (SIZE (ZDATA) < INX * (IROW2-IROW1+1)) THEN
  CALL ABOR1 ('DIR: ZDATA IS TOO SMALL')
ENDIF

OPEN (77, FILE=TRIM (CDFILE)//'.dir', FORM='UNFORMATTED', ACTION='READ', &
    & ACCESS='DIRECT', RECL=((YDHDR%ICOLS * YDHDR%IWIDTH) / 8))

SELECT CASE (YDHDR%IWIDTH)

  CASE ( 8)
  
    ALLOCATE (IL1 (YDHDR%ICOLS))

    IOFF = 0
    DO IROW = IROW1, IROW2
      READ (77, REC=IROW) IL1
      WHERE (IL1 < 0)
        ZDATA (IOFF+1:IOFF+YDHDR%ICOLS) = IL1 + 256
      ELSEWHERE
        ZDATA (IOFF+1:IOFF+YDHDR%ICOLS) = IL1 
      ENDWHERE
      IOFF = IOFF + YDHDR%ICOLS
    ENDDO

  CASE (16)

    ALLOCATE (IL2 (YDHDR%ICOLS))

    IOFF = 0
    DO IROW = IROW1, IROW2
      READ (77, REC=IROW) IL2
      ZDATA (IOFF+1:IOFF+YDHDR%ICOLS) = IL2 
      IOFF = IOFF + YDHDR%ICOLS
    ENDDO

  CASE DEFAULT

    STOP

END SELECT

CLOSE (77)


IF (PRESENT (PSCALE)) THEN
  WHERE (ZDATA /= YDHDR%RUNDEF)
    ZDATA = ZDATA * PSCALE
  END WHERE
ENDIF

WHERE (ZDATA == YDHDR%RUNDEF)
  ZDATA = ZUNDEF
END WHERE
YDHDR%RUNDEF = ZUNDEF

CALL YLFLD%RETURN ()

END FUNCTION

SUBROUTINE HDR (CDFILE, YDHDR)

CHARACTER (LEN=*), INTENT (IN)  :: CDFILE
TYPE (HDR_t),      INTENT (OUT) :: YDHDR

CHARACTER (LEN=256) :: CLLINE

OPEN (77, FILE=TRIM (CDFILE)//'.hdr', FORM='FORMATTED')

READ (77, '(A)') CLLINE

YDHDR%CLCOMMENT = CLLINE

DO 
  READ (77, '(A256)', END=999) CLLINE
  IF (CLLINE (1:7) == 'nodata:'             ) READ (CLLINE ( 8:), *) YDHDR%RUNDEF
  IF (CLLINE (1:6) == 'north:'              ) READ (CLLINE ( 7:), *) YDHDR%ZNORTH
  IF (CLLINE (1:6) == 'south:'              ) READ (CLLINE ( 7:), *) YDHDR%ZSOUTH
  IF (CLLINE (1:5) == 'west:'               ) READ (CLLINE ( 6:), *) YDHDR%ZWEST
  IF (CLLINE (1:5) == 'east:'               ) READ (CLLINE ( 6:), *) YDHDR%ZEAST
  IF (CLLINE (1:5) == 'rows:'               ) READ (CLLINE ( 6:), *) YDHDR%IROWS
  IF (CLLINE (1:5) == 'cols:'               ) READ (CLLINE ( 6:), *) YDHDR%ICOLS
  IF (CLLINE (1:19) == 'recordtype: integer') READ (CLLINE (20:), *) YDHDR%IWIDTH
ENDDO

999 CONTINUE

CLOSE (77)

SELECT CASE (YDHDR%IWIDTH)

  CASE ( 8)
  
    IF (YDHDR%RUNDEF < 0) YDHDR%RUNDEF = YDHDR%RUNDEF + 256._JPRB

  CASE DEFAULT

END SELECT


END SUBROUTINE 

SUBROUTINE COMPARE_GEOMHDR (YDHDR1, YDHDR2)

TYPE (HDR_t),  INTENT (IN) :: YDHDR1, YDHDR2

#include "abor1.intfb.h"

IF (YDHDR1%ZWEST  /= YDHDR2%ZWEST ) CALL ABOR1 ('COMPARE_GEOMHDR: DIFFERENT ZWEST ')
IF (YDHDR1%ZEAST  /= YDHDR2%ZEAST ) CALL ABOR1 ('COMPARE_GEOMHDR: DIFFERENT ZEAST ')
IF (YDHDR1%ZNORTH /= YDHDR2%ZNORTH) CALL ABOR1 ('COMPARE_GEOMHDR: DIFFERENT ZNORTH')
IF (YDHDR1%ZSOUTH /= YDHDR2%ZSOUTH) CALL ABOR1 ('COMPARE_GEOMHDR: DIFFERENT ZSOUTH')
IF (YDHDR1%ICOLS  /= YDHDR2%ICOLS ) CALL ABOR1 ('COMPARE_GEOMHDR: DIFFERENT ICOLS ')
IF (YDHDR1%IROWS  /= YDHDR2%IROWS ) CALL ABOR1 ('COMPARE_GEOMHDR: DIFFERENT IROWS ')

END SUBROUTINE

SUBROUTINE FIELDSTAT (YLFSSC, YLFLDS, PMIN, PMAX, PAVG)

USE FCKIT_MPI_MODULE

TYPE (ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS), INTENT (IN)  :: YLFSSC
TYPE (ATLAS_FIELD),                           INTENT (IN)  :: YLFLDS (:)
REAL (KIND=JPRB), OPTIONAL,                   INTENT (OUT) :: PMIN (:), PMAX (:), PAVG (:)

INTEGER (KIND=JPIM)   :: NPROC, INFLD, IGPTOT
TYPE (FCKIT_MPI_COMM) :: YLCOMM

TYPE (PTR),          ALLOCATABLE :: YLPTR (:)
LOGICAL,             ALLOCATABLE :: LLUNDEF (:)
REAL (KIND=JPRB),    ALLOCATABLE :: ZUNDEF (:), ZMMSALL (:), ZMMS (:)
INTEGER (KIND=JPIM), ALLOCATABLE :: ICNTALL (:), ICNT (:), IRECVCNT (:), IDISPCNT (:)
INTEGER (KIND=JPIM) :: JFLD, IOFF, INUM, IPROC

TYPE (ATLAS_METADATA) :: YLMETA

IGPTOT = YLFSSC%SIZE_OWNED ()
INFLD  = SIZE (YLFLDS)
YLCOMM = FCKIT_MPI_COMM ()
NPROC  = YLCOMM%SIZE ()

ALLOCATE (YLPTR (INFLD), LLUNDEF (INFLD), ZUNDEF (INFLD), ZMMSALL (3 * INFLD * NPROC), &
        & ZMMS (3 * INFLD), ICNTALL (INFLD * NPROC), ICNT (INFLD), IRECVCNT (NPROC), IDISPCNT (NPROC))

ZUNDEF = HUGE (1._JPRB)

DO JFLD = 1, INFLD
  CALL YLFLDS (JFLD)%DATA (YLPTR (JFLD)%ZDATA)
  YLMETA = YLFLDS (JFLD)%METADATA ()
  LLUNDEF (JFLD) = YLMETA%HAS ("undef")
  IF (LLUNDEF (JFLD)) CALL YLMETA%GET ("undef", ZUNDEF (JFLD))
  CALL YLMETA%FINAL ()
ENDDO


!$OMP PARALLEL DO PRIVATE (JFLD)
DO JFLD = 1, INFLD
  IF (LLUNDEF (JFLD)) THEN
    ICNT (JFLD) = COUNT  (YLPTR (JFLD)%ZDATA (1:IGPTOT) /= ZUNDEF (JFLD))
    IF (ICNT (JFLD) > 0) THEN
      ZMMS (3*(JFLD-1)+1) = MINVAL (YLPTR (JFLD)%ZDATA (1:IGPTOT), MASK=YLPTR (JFLD)%ZDATA (1:IGPTOT)/=ZUNDEF (JFLD))
      ZMMS (3*(JFLD-1)+2) = MAXVAL (YLPTR (JFLD)%ZDATA (1:IGPTOT), MASK=YLPTR (JFLD)%ZDATA (1:IGPTOT)/=ZUNDEF (JFLD))
      ZMMS (3*(JFLD-1)+3) = SUM    (YLPTR (JFLD)%ZDATA (1:IGPTOT), MASK=YLPTR (JFLD)%ZDATA (1:IGPTOT)/=ZUNDEF (JFLD))
    ELSE
      ZMMS (3*(JFLD-1)+1) = ZUNDEF (JFLD)
      ZMMS (3*(JFLD-1)+2) = ZUNDEF (JFLD)
      ZMMS (3*(JFLD-1)+3) = ZUNDEF (JFLD)
    ENDIF
  ELSE
    ICNT (JFLD) = IGPTOT
    ZMMS (3*(JFLD-1)+1) = MINVAL (YLPTR (JFLD)%ZDATA (1:IGPTOT))
    ZMMS (3*(JFLD-1)+2) = MAXVAL (YLPTR (JFLD)%ZDATA (1:IGPTOT))
    ZMMS (3*(JFLD-1)+3) = SUM    (YLPTR (JFLD)%ZDATA (1:IGPTOT))
  ENDIF
ENDDO
!$OMP END PARALLEL DO

IRECVCNT (:) = 1
IDISPCNT (1) = 0
DO IPROC = 2, NPROC
  IDISPCNT (IPROC) = IDISPCNT (IPROC-1) + IRECVCNT (IPROC-1)
ENDDO

CALL YLCOMM%ALLGATHER (ZMMS, ZMMSALL, INFLD * 3, IRECVCNT * INFLD * 3, IDISPCNT * INFLD * 3)
CALL YLCOMM%ALLGATHER (ICNT, ICNTALL, INFLD * 1, IRECVCNT * INFLD * 1, IDISPCNT * INFLD * 1)
  
!$OMP PARALLEL DO PRIVATE (JFLD, IOFF, INUM)
DO JFLD = 1, INFLD
  IOFF = 3*(JFLD-1)
  INUM = 3*INFLD
  IF (LLUNDEF (JFLD)) THEN
    IF (PRESENT (PMIN)) PMIN (JFLD) = MINVAL (ZMMSALL (IOFF+1::INUM), MASK=ZMMSALL (IOFF+1::INUM)/=ZUNDEF (JFLD))
    IF (PRESENT (PMAX)) PMAX (JFLD) = MAXVAL (ZMMSALL (IOFF+2::INUM), MASK=ZMMSALL (IOFF+2::INUM)/=ZUNDEF (JFLD))
    IF (PRESENT (PAVG)) PAVG (JFLD) = SUM    (ZMMSALL (IOFF+3::INUM), MASK=ZMMSALL (IOFF+3::INUM)/=ZUNDEF (JFLD)) 
  ELSE
    IF (PRESENT (PMIN)) PMIN (JFLD) = MINVAL (ZMMSALL (IOFF+1::INUM))
    IF (PRESENT (PMAX)) PMAX (JFLD) = MAXVAL (ZMMSALL (IOFF+2::INUM))
    IF (PRESENT (PAVG)) PAVG (JFLD) = SUM    (ZMMSALL (IOFF+3::INUM))
  ENDIF
  INUM = SUM (ICNTALL ((JFLD-1)+1::INFLD))
  IF (PRESENT (PAVG)) THEN
    IF (INUM > 0) THEN
      PAVG (JFLD) = PAVG (JFLD) / REAL (INUM, JPRB)
    ELSE
      PAVG (JFLD) = ZUNDEF (JFLD)
    ENDIF
  ENDIF
ENDDO
!$OMP END PARALLEL DO

#ifdef UNDEF
DO JFLD = 1, SIZE (YLFLDS)
  WRITE (*, '(A16," > ",F12.4," | ",F12.4," | ",F12.4)') &
       & YLFLDS (JFLD)%NAME (), PAVG (JFLD), PMIN (JFLD), PMAX (JFLD)
ENDDO
#endif

END SUBROUTINE

SUBROUTINE MAKEFRAC (PFRAC, YDCOVER, PDATA, LDCOVER)

REAL (KIND=JPRB),   INTENT (OUT) :: PFRAC (:)
TYPE (ATLAS_FIELD), INTENT (IN)  :: YDCOVER (:)
REAL (KIND=JPRB),   INTENT (IN)  :: PDATA (:)
LOGICAL,            INTENT (IN)  :: LDCOVER (:)

TYPE (PTR) :: YLPTR (SIZE (YDCOVER))

INTEGER (KIND=JPIM) :: JLOC, JCOV, INCOV
REAL (KIND=JPRB) :: ZSUM

INCOV = SIZE (YDCOVER)

DO JCOV = 1, INCOV
  CALL YDCOVER (JCOV)%DATA (YLPTR (JCOV)%ZDATA)
ENDDO

!$OMP PARALLEL DO PRIVATE (JLOC, ZSUM, JCOV)
DO JLOC = 1, SIZE (PFRAC)
  PFRAC (JLOC) = 0._JPRB
  ZSUM = 0._JPRB
  DO JCOV = 1, INCOV
    IF (LDCOVER (JCOV)) THEN
      PFRAC (JLOC) = PFRAC (JLOC) + YLPTR (JCOV)%ZDATA (JLOC) * PDATA (JCOV)
      ZSUM         = ZSUM + YLPTR (JCOV)%ZDATA (JLOC)
    ENDIF
  ENDDO
  PFRAC (JLOC) = PFRAC (JLOC) / ZSUM
ENDDO
!$OMP END PARALLEL DO

END SUBROUTINE


END

