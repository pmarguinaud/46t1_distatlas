PROGRAM ATLAS_PGD

USE PARKIND1, ONLY : JPIM, JPRB
USE INTERPOLATIONA_MOD
USE INTERPOLATION4_MOD
USE GRADIENT_MOD
USE ATLAS_IO, ONLY : ATLAS_IO_t
USE ATLAS_FA, ONLY : ATLAS_FA_t
USE FCKIT_MODULE, ONLY : FCKIT_MPI_COMM
USE ATLAS_MODULE  
USE XRD_GETOPTIONS

!

IMPLICIT NONE

TYPE (ATLAS_STRUCTUREDGRID)                  :: YLGRID1
TYPE (ATLAS_STRUCTUREDGRID)                  :: YLGRID2
TYPE (ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS) :: YLFSSC1
TYPE (ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS) :: YLFSSC2
TYPE (ATLAS_GRIDDISTRIBUTION)                :: YLDIST1
TYPE (ATLAS_GRIDDISTRIBUTION)                :: YLDIST2
TYPE (INTERPOLATIONA)                        :: YLINTEA
TYPE (ATLAS_FIELDSET)                        :: YLFLDS1  
TYPE (ATLAS_FIELDSET)                        :: YLFLDS2
TYPE (ATLAS_FIELDSET)                        :: YLFLDS2I
TYPE (FCKIT_MPI_COMM)                        :: YLCOMM
TYPE (ATLAS_FA_t), TARGET                    :: YLFAIO
CLASS (ATLAS_IO_t), POINTER                  :: YLIO

REAL (KIND=JPRB), PARAMETER :: RPI = 2.0_JPRB * ASIN (1.0_JPRB)
REAL (KIND=JPRB), PARAMETER :: RA = 6371229._JPRB

INTEGER (KIND=JPIM) :: I, JFLD
INTEGER (KIND=JPIM) :: NPROC, IRANK

TYPE HDR_t
  REAL (KIND=JPRB) :: RUNDEF = HUGE (0._JPRB)
  REAL (KIND=JPRB) :: ZWEST = -999, ZEAST = -999, ZNORTH = -999, ZSOUTH = -999
  INTEGER (KIND=JPIM) :: ICOLS = -999, IROWS = -999, IWIDTH = -999
  CHARACTER (LEN=256) :: CLCOMMENT = ''
END TYPE HDR_t

TYPE PTR
  REAL (KIND=JPRB), POINTER :: ZDATA (:) => NULL ()
END TYPE PTR


INTERFACE CREATE_GRID
  PROCEDURE CREATE_GRID_HDR
  PROCEDURE CREATE_GRID_NML
END INTERFACE CREATE_GRID

TYPE (ATLAS_FIELD), ALLOCATABLE :: YLFL1 (:), YLFL2 (:)
TYPE (PTR),         ALLOCATABLE :: YLPT1 (:), YLPT2 (:)

INTEGER (KIND=JPIM) :: INFLD

INTEGER (KIND=JPIM) :: JZS, JZS2, JZS_DXDX, JZS_DYDY, JZS_DXDY, JSAND, JCLAY
INTEGER (KIND=JPIM) :: JMIN_ZS, JMAX_ZS, JAVG_ZS, JSIL_ZS
INTEGER (KIND=JPIM) :: JSSO_DIR, JSSO_SLOPE, JSSO_ANIS, JSSO_STDEV
INTEGER (KIND=JPIM) :: JAOSIP, JAOSIM, JAOSJP, JAOSJM, JHO2IP, JHO2IM, JHO2JP, JHO2JM
INTEGER (KIND=JPIM) :: JLATGAUSS, JLONGAUSS, JLAT_G_XY, JLON_G_XY, JMESHGAUSS, JLONINF, JLONSUP, JLATINF, JLATSUP
INTEGER (KIND=JPIM) :: JFRAC_SEA, JFRAC_WATER, JFRAC_NATURE, JFRAC_TOWN
INTEGER (KIND=JPIM) :: JBATHY, JRUNOFFB, JWDRAIN, JCOVER


INTEGER (KIND=JPIM), PARAMETER :: INCOVR = 256_JPIM
LOGICAL, ALLOCATABLE :: LCOVER (:)
REAL (KIND=JPRB), PARAMETER :: ZUNDEF = HUGE (1._JPRB)

TYPE (HDR_t) :: YLHDRS (4), YLHDR
CHARACTER (LEN=32), PARAMETER :: CLDATA (4) = [ &
!                         01234567890123456789012345678901
&                        'SFX.ZS                          ', &
&                        'SFX.CLAY                        ', &
&                        'SFX.SAND                        ', &
&                        'SFX.COVER                       ' ]

INTEGER (KIND=JPIM), PARAMETER :: JOROG_DAT = 1, JCLAY_DAT = 2, &
                                & JSAND_DAT = 3, JCOVR_DAT = 4

LOGICAL, PARAMETER :: LGARDEN = .FALSE., LWATER_TO_NATURE = .FALSE., LTOWN_TO_ROCK = .TRUE.

CALL INITOPTIONS 

CALL CHECKOPTIONS

YLIO => YLFAIO

CALL ATLAS_LIBRARY%INITIALISE ()

DO I = 1, SIZE (CLDATA)
  CALL HDR (TRIM (CLDATA (I)), YLHDRS (I))
ENDDO

YLHDR = YLHDRS (1)

DO I = 1, 4
  CALL COMPARE_GEOMHDR (YLHDR, YLHDRS (I))
ENDDO

YLCOMM = FCKIT_MPI_COMM ()
NPROC  = YLCOMM%SIZE ()
IRANK  = YLCOMM%RANK ()

CALL LINUX_BIND (IRANK, NPROC)

CALL CREATE_GRID (YLGRID1, YLHDR)
CALL CREATE_GRID (YLGRID2, 'fort.4')

CALL CREATE_DIST (YLGRID1, YLDIST1, .TRUE.)
CALL CREATE_DIST (YLGRID2, YLDIST2)

BLOCK
  TYPE (ATLAS_CONFIG) :: YLCONF
  YLCONF = ATLAS_CONFIG ()
  CALL YLCONF%SET ("halo", 1)
  CALL YLCONF%SET ("periodic_points", .TRUE.)
  YLFSSC1 = ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS (YLGRID1, YLDIST1, YLCONF)
  YLFSSC2 = ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS (YLGRID2, YLDIST2, YLCONF)
  CALL YLCONF%FINAL ()
ENDBLOCK



INFLD = 0

#define ADDFLD(J) INFLD = INFLD + 1; J = INFLD

ADDFLD (JZS         ); ADDFLD (JZS2        ); ADDFLD (JZS_DXDX    ); ADDFLD (JZS_DYDY    );
ADDFLD (JZS_DXDY    ); ADDFLD (JSAND       ); ADDFLD (JCLAY       ); ADDFLD (JSSO_DIR    );
ADDFLD (JSSO_SLOPE  ); ADDFLD (JSSO_ANIS   ); ADDFLD (JSSO_STDEV  ); ADDFLD (JLATINF     );
ADDFLD (JLONINF     ); ADDFLD (JLATSUP     ); ADDFLD (JLONSUP     ); ADDFLD (JLATGAUSS   );
ADDFLD (JLONGAUSS   ); ADDFLD (JLAT_G_XY   ); ADDFLD (JLON_G_XY   ); ADDFLD (JMESHGAUSS  );
ADDFLD (JAOSIP      ); ADDFLD (JAOSIM      ); ADDFLD (JAOSJP      ); ADDFLD (JAOSJM      );
ADDFLD (JHO2IP      ); ADDFLD (JHO2IM      ); ADDFLD (JHO2JP      ); ADDFLD (JHO2JM      );
ADDFLD (JFRAC_SEA   ); ADDFLD (JFRAC_TOWN  ); ADDFLD (JFRAC_WATER ); ADDFLD (JFRAC_NATURE);
ADDFLD (JBATHY      ); ADDFLD (JRUNOFFB    ); ADDFLD (JWDRAIN     ); ADDFLD (JMIN_ZS     );
ADDFLD (JMAX_ZS     ); ADDFLD (JAVG_ZS     ); ADDFLD (JSIL_ZS     );


JCOVER = INFLD
INFLD = INFLD + INCOVR

#undef ADDFLD

ALLOCATE (YLFL1 (INFLD), YLFL2 (INFLD), YLPT1 (INFLD), YLPT2 (INFLD))

YLFLDS1 = ATLAS_FIELDSET ()
YLFLDS2 = ATLAS_FIELDSET ()

YLINTEA = INTERPOLATIONA (YLDIST1, YLFSSC1, YLDIST2, YLFSSC2)

CALL INS1 (JZS     , DIR (CLDATA (JOROG_DAT), YLHDRS (JOROG_DAT), YLFSSC1, YLGRID1))
CALL INS1 (JCLAY   , DIR (CLDATA (JCLAY_DAT), YLHDRS (JCLAY_DAT), YLFSSC1, YLGRID1, 0.01_JPRB))
CALL INS1 (JSAND   , DIR (CLDATA (JSAND_DAT), YLHDRS (JSAND_DAT), YLFSSC1, YLGRID1, 0.01_JPRB))
CALL INS1 (JCOVER+1, DIR (CLDATA (JCOVR_DAT), YLHDRS (JCOVR_DAT), YLFSSC1, YLGRID1))

! Create covers

BLOCK
  TYPE (ATLAS_FIELD) :: YLCOVR2E
  INTEGER (KIND=JPIM), ALLOCATABLE :: IOFF (:), ICNT (:)
  REAL (KIND=JPRB), POINTER :: ZCOVR2E (:)
  INTEGER (KIND=JPIM) :: JLOC2, ICOV, II
  CHARACTER (LEN=16) :: CLNOMA

  IOFF = YLINTEA%GETOFF ()
  ICNT = YLINTEA%GETCNT ()

  YLCOVR2E = YLINTEA%SHUFFLE (YLFL1 (JCOVER+1))

  CALL YLCOVR2E%DATA (ZCOVR2E)

  DO ICOV = 1, INCOVR
    WRITE (CLNOMA, '("SFX.COVER",I3.3)') ICOV
    CALL INS2 (JCOVER+ICOV, NEWFLD (YLFSSC2, TRIM (CLNOMA)))
    YLPT2 (JCOVER+ICOV)%ZDATA = 0._JPRB
  ENDDO


  DO JLOC2 = 1, YLFSSC2%SIZE_OWNED ()
    DO II = IOFF (JLOC2)+1, IOFF (JLOC2)+ICNT (JLOC2)
      ICOV = INT (ZCOVR2E (II))
      IF ((ICOV < 1) .OR. (ICOV > INCOVR)) THEN
        CALL ABOR1 ('ATLAS_PGD: UNEXPECTED COVER VALUE')
      ENDIF
      YLPT2 (JCOVER+ICOV)%ZDATA (JLOC2) = YLPT2 (JCOVER+ICOV)%ZDATA (JLOC2) + 1._JPRB
    ENDDO
    DO ICOV = 1, INCOVR
      YLPT2 (JCOVER+ICOV)%ZDATA (JLOC2) = YLPT2 (JCOVER+ICOV)%ZDATA (JLOC2) / REAL (ICNT (JLOC2), JPRB)
    ENDDO
  ENDDO

  CALL YLCOVR2E%FINAL ()
ENDBLOCK


! Set missing values of orography

!$OMP WORKSHARE
WHERE (YLPT1 (JCOVER+1)%ZDATA == 1._JPRB) ! Sea 
  YLPT1 (JZS)%ZDATA = ZUNDEF
ENDWHERE
!$OMP END WORKSHARE

! Compute orography gradient

BLOCK
  TYPE (ATLAS_FIELDSET) :: YLFSGR1
  TYPE (ATLAS_FIELD) :: YLOROG1DX, YLOROG1DY
  REAL (KIND=JPRB), POINTER :: ZOROG1DX (:), ZOROG1DY (:)

  YLFSGR1 = GRADIENT (YLFSSC1, YLFL1 (JZS))

  YLOROG1DX = YLFSGR1%FIELD ("SFX.ZS.DX")
  YLOROG1DY = YLFSGR1%FIELD ("SFX.ZS.DY")

  CALL YLOROG1DX%DATA (ZOROG1DX)
  CALL YLOROG1DY%DATA (ZOROG1DY)

  CALL ROTATE (YLFSSC1, YLGRID2, YLFSGR1)

  CALL INS1 (JZS2    , NEWFLD (YLFSSC1, "SFX.ZS_2"    , ZUNDEF))
  CALL INS1 (JZS_DXDX, NEWFLD (YLFSSC1, "SFX.ZS.DX_DX", ZUNDEF))
  CALL INS1 (JZS_DYDY, NEWFLD (YLFSSC1, "SFX.ZS.DY_DY", ZUNDEF))
  CALL INS1 (JZS_DXDY, NEWFLD (YLFSSC1, "SFX.ZS.DX_DY", ZUNDEF))

  ! Gradient wrt meters on Earth

!$OMP WORKSHARE
  WHERE (ZOROG1DX /= ZUNDEF) ZOROG1DX = ZOROG1DX / RA
!$OMP END WORKSHARE

!$OMP WORKSHARE
  WHERE (ZOROG1DY /= ZUNDEF) ZOROG1DY = ZOROG1DY / RA
!$OMP END WORKSHARE

!$OMP WORKSHARE
  WHERE (YLPT1 (JZS)%ZDATA /= ZUNDEF)
    YLPT1 (JZS_DXDX)%ZDATA = ZOROG1DX * ZOROG1DX 
    YLPT1 (JZS_DYDY)%ZDATA = ZOROG1DY * ZOROG1DY
    YLPT1 (JZS_DXDY)%ZDATA = ZOROG1DX * ZOROG1DY
    YLPT1 (JZS2    )%ZDATA = YLPT1 (JZS)%ZDATA * YLPT1 (JZS)%ZDATA
  ELSEWHERE
    YLPT1 (JZS_DXDX)%ZDATA = ZUNDEF
    YLPT1 (JZS_DYDY)%ZDATA = ZUNDEF
    YLPT1 (JZS_DXDY)%ZDATA = ZUNDEF
    YLPT1 (JZS2    )%ZDATA = ZUNDEF
  ENDWHERE
!$OMP END WORKSHARE

  CALL YLOROG1DX   %FINAL ()
  CALL YLOROG1DY   %FINAL ()

ENDBLOCK

! Interpolate fields


YLFLDS2I = YLINTEA%INTERPOLATE (YLFLDS1)

CALL INS2 (JZS     , YLFLDS2I%FIELD ("SFX.ZS"      ))
CALL INS2 (JSAND   , YLFLDS2I%FIELD ("SFX.SAND"    ))
CALL INS2 (JCLAY   , YLFLDS2I%FIELD ("SFX.CLAY"    ))
CALL INS2 (JZS2    , YLFLDS2I%FIELD ("SFX.ZS_2"    ))
CALL INS2 (JZS_DXDX, YLFLDS2I%FIELD ("SFX.ZS.DX_DX"))
CALL INS2 (JZS_DYDY, YLFLDS2I%FIELD ("SFX.ZS.DY_DY"))
CALL INS2 (JZS_DXDY, YLFLDS2I%FIELD ("SFX.ZS.DX_DY"))

CALL YLFLDS2I%FINAL ()

! Min, max, avg orography

BLOCK
 
  CALL INS2 (JAVG_ZS, NEWFLD (YLFSSC2, "SFX.AVG_ZS", ZUNDEF))
  CALL INS2 (JSIL_ZS, NEWFLD (YLFSSC2, "SFX.SIL_ZS", ZUNDEF))

  YLPT2 (JAVG_ZS)%ZDATA = YLPT2 (JZS)%ZDATA
  YLPT2 (JSIL_ZS)%ZDATA = YLPT2 (JZS)%ZDATA

  CALL INS2 (JMIN_ZS, YLINTEA%INTERPOLATE (YLFL1 (JZS), YLINTEA%OPT_MIN ()))
  CALL INS2 (JMAX_ZS, YLINTEA%INTERPOLATE (YLFL1 (JZS), YLINTEA%OPT_MAX ()))

  CALL YLFL2 (JMIN_ZS)%RENAME ("SFX.MIN_ZS")
  CALL YLFL2 (JMAX_ZS)%RENAME ("SFX.MAX_ZS")

ENDBLOCK


! Compute SSO parameters

BLOCK
  REAL (KIND=JPIM), PARAMETER :: XPI = RPI
  TYPE (ATLAS_FIELD) :: YLSSODIR2, YLSSOSLO2, YLSSOANI2, YLSSOSTD2
  LOGICAL :: OSSO (YLFSSC2%SIZE ()), OSSO_ANIS (YLFSSC2%SIZE ())
  REAL (KIND=JPRB) :: ZK (YLFSSC2%SIZE ()), ZL (YLFSSC2%SIZE ()), ZM (YLFSSC2%SIZE ())

  CALL INS2 (JSSO_DIR,   NEWFLD (YLFSSC2, "SFX.SSO_DIR"  , ZUNDEF))
  CALL INS2 (JSSO_SLOPE, NEWFLD (YLFSSC2, "SFX.SSO_SLOPE", ZUNDEF))
  CALL INS2 (JSSO_ANIS , NEWFLD (YLFSSC2, "SFX.SSO_ANIS" , ZUNDEF))
  CALL INS2 (JSSO_STDEV, NEWFLD (YLFSSC2, "SFX.SSO_STDEV", ZUNDEF))

  OSSO = YLPT2 (JZS)%ZDATA /= ZUNDEF
  OSSO_ANIS = OSSO 

!$OMP WORKSHARE
  WHERE (OSSO) 
    ZK=0.5*(YLPT2 (JZS_DXDX)%ZDATA+YLPT2 (JZS_DYDY)%ZDATA)
    ZL=0.5*(YLPT2 (JZS_DXDX)%ZDATA-YLPT2 (JZS_DYDY)%ZDATA)
    ZM=     YLPT2 (JZS_DXDY)%ZDATA 
  ELSE WHERE
    ZK = ZUNDEF
    ZL = ZUNDEF
    ZM = ZUNDEF
    YLPT2 (JZS_DXDX  )%ZDATA = ZUNDEF
    YLPT2 (JZS_DYDY  )%ZDATA = ZUNDEF
    YLPT2 (JZS_DXDY  )%ZDATA = ZUNDEF
    YLPT2 (JSSO_DIR  )%ZDATA = ZUNDEF
    YLPT2 (JSSO_SLOPE)%ZDATA = ZUNDEF
    YLPT2 (JSSO_ANIS )%ZDATA = ZUNDEF
  END WHERE
!$OMP END WORKSHARE

  !
  !*    8.     S.S.O. characteristics
  !            ----------------------
  !
  !*    8.1    S.S.O. direction of main axis
  !            -----------------------------
  !
!$OMP WORKSHARE
  WHERE (OSSO)
    YLPT2 (JSSO_DIR)%ZDATA = 0.5_JPRB * ATAN2 (ZM, ZL) * (180._JPRB / XPI) 
  END WHERE
!$OMP END WORKSHARE
  !
  !*    8.2    S.S.O. slope
  !            ------------
  !
!$OMP WORKSHARE
  WHERE (OSSO)
    YLPT2 (JSSO_SLOPE)%ZDATA = SQRT (ZK + SQRT (ZL*ZL + ZM*ZM))
  END WHERE
!$OMP END WORKSHARE
  !
  !*    8.3    S.S.O. anisotropy
  !            -----------------
  !
!$OMP WORKSHARE
  WHERE (OSSO_ANIS .AND. (ZK+SQRT(ZL*ZL+ZM*ZM)) > 0._JPRB)
    YLPT2 (JSSO_ANIS)%ZDATA = SQRT (MAX (ZK-SQRT(ZL*ZL+ZM*ZM), 0._JPRB) / (ZK+SQRT (ZL*ZL+ZM*ZM)))
  END WHERE
!$OMP END WORKSHARE
  !
!$OMP WORKSHARE
  WHERE (OSSO_ANIS .AND. (ZK+SQRT (ZL*ZL+ZM*ZM)) == 0._JPRB)
    YLPT2 (JSSO_ANIS)%ZDATA = 1._JPRB
  END WHERE
!$OMP END WORKSHARE

! Orography standard deviation

!$OMP WORKSHARE
  WHERE (OSSO)
    YLPT2 (JSSO_STDEV)%ZDATA = SQRT (YLPT2 (JZS2)%ZDATA - YLPT2 (JZS)%ZDATA**2)
  ELSE WHERE
    YLPT2 (JSSO_STDEV)%ZDATA = ZUNDEF
  END WHERE
!$OMP END WORKSHARE

! Add enveloppe

!$OMP WORKSHARE
  WHERE (YLPT2 (JZS)%ZDATA (:) /= ZUNDEF)
    YLPT2 (JZS)%ZDATA (:) = YLPT2 (JZS)%ZDATA (:) + YLPT2 (JSSO_STDEV)%ZDATA
  ENDWHERE
!$OMP END WORKSHARE

ENDBLOCK


! Compute AOS parameters

BLOCK
  TYPE (INTERPOLATION4) :: YLINTE4
  TYPE (ATLAS_FIELD) :: YLOROG1INT4, YLOROG1MINT4
  TYPE (ATLAS_FIELD) :: YLOROG1IP, YLOROG1IM, YLOROG1JP, YLOROG1JM
  TYPE (ATLAS_FIELD) :: YLIP, YLIM, YLJP, YLJM
  REAL (KIND=JPRB), POINTER, DIMENSION (:) :: ZOROG1INT4, ZOROG1MINT4
  REAL (KIND=JPRB), POINTER, DIMENSION (:) :: ZOROG1IP, ZOROG1IM, ZOROG1JP, ZOROG1JM
  REAL (KIND=JPRB), POINTER, DIMENSION (:) :: ZIP, ZIM, ZJP, ZJM
  TYPE (ATLAS_FIELDSET) :: YLFLDSHALF, YLFLDSAOS1, YLFLDSAOS2
  INTEGER (KIND=JPIM) :: IAOSHO2 (8)
  INTEGER (KIND=JPIM) :: JFLD

  IAOSHO2 = [JAOSIP, JAOSIM, JAOSJP, JAOSJM, JHO2IP, JHO2IM, JHO2JP, JHO2JM]

  ! Interpolate from target geometry to origin geometry (fine lat/lon)

  YLINTE4 = INTERPOLATION4 (YLDIST2, YLFSSC2, YLDIST1, YLFSSC1)

  YLOROG1MINT4 = NEWFLD (YLFSSC1, "SFX.ZS.MINT4", ZUNDEF)

  YLOROG1INT4  = YLINTE4%INTERPOLATE (YLFL2 (JZS))

  CALL YLOROG1INT4 %DATA (ZOROG1INT4 )
  CALL YLOROG1MINT4%DATA (ZOROG1MINT4)

! Difference of original orography with interpolated orography

!$OMP WORKSHARE
  WHERE (YLPT1 (JZS)%ZDATA /= ZUNDEF)
    ZOROG1MINT4 = YLPT1 (JZS)%ZDATA - ZOROG1INT4
  ELSEWHERE
    ZOROG1MINT4 = ZUNDEF
  ENDWHERE
!$OMP END WORKSHARE

  YLFLDSHALF = ATLAS_FIELDSET ()
  CALL YLFLDSHALF%ADD (YLOROG1MINT4)

  YLFLDSAOS1 = HALFDIFF (YLFSSC1, YLFLDSHALF)

  YLOROG1IP = YLFLDSAOS1%FIELD ("SFX.ZS.MINT4.XP"); CALL YLOROG1IP%DATA (ZOROG1IP)
  YLOROG1IM = YLFLDSAOS1%FIELD ("SFX.ZS.MINT4.XM"); CALL YLOROG1IM%DATA (ZOROG1IM)
  YLOROG1JP = YLFLDSAOS1%FIELD ("SFX.ZS.MINT4.YP"); CALL YLOROG1JP%DATA (ZOROG1JP)
  YLOROG1JM = YLFLDSAOS1%FIELD ("SFX.ZS.MINT4.YM"); CALL YLOROG1JM%DATA (ZOROG1JM)

  YLIP = YLFLDSAOS1%FIELD ("XP"); CALL YLIP%DATA (ZIP)
  YLIM = YLFLDSAOS1%FIELD ("XM"); CALL YLIM%DATA (ZIM)
  YLJP = YLFLDSAOS1%FIELD ("YP"); CALL YLJP%DATA (ZJP)
  YLJM = YLFLDSAOS1%FIELD ("YM"); CALL YLJM%DATA (ZJM)

  CALL YLFLDSAOS1%FINAL ()

  CALL INS1 (JAOSIP, NEWFLD (YLFSSC1, "SFX.AOSIP", ZUNDEF))
  CALL INS1 (JAOSIM, NEWFLD (YLFSSC1, "SFX.AOSIM", ZUNDEF))
  CALL INS1 (JAOSJP, NEWFLD (YLFSSC1, "SFX.AOSJP", ZUNDEF))
  CALL INS1 (JAOSJM, NEWFLD (YLFSSC1, "SFX.AOSJM", ZUNDEF))

!$OMP WORKSHARE
  WHERE (YLPT1 (JZS)%ZDATA /= ZUNDEF)
    YLPT1 (JAOSIP)%ZDATA = + MAX (0._JPRB, ZOROG1IP / (RA * ZIP))
    YLPT1 (JAOSIM)%ZDATA = - MIN (0._JPRB, ZOROG1IM / (RA * ZIM))
    YLPT1 (JAOSJP)%ZDATA = + MAX (0._JPRB, ZOROG1JP / (RA * ZJP))
    YLPT1 (JAOSJM)%ZDATA = - MIN (0._JPRB, ZOROG1JM / (RA * ZJM))
  ELSEWHERE
    YLPT1 (JAOSIP)%ZDATA = ZUNDEF
    YLPT1 (JAOSIM)%ZDATA = ZUNDEF
    YLPT1 (JAOSJP)%ZDATA = ZUNDEF
    YLPT1 (JAOSJM)%ZDATA = ZUNDEF
  ENDWHERE
!$OMP END WORKSHARE

  CALL INS1 (JHO2IP, NEWFLD (YLFSSC1, "SFX.HO2IP", ZUNDEF))
  CALL INS1 (JHO2IM, NEWFLD (YLFSSC1, "SFX.HO2IM", ZUNDEF))
  CALL INS1 (JHO2JP, NEWFLD (YLFSSC1, "SFX.HO2JP", ZUNDEF))
  CALL INS1 (JHO2JM, NEWFLD (YLFSSC1, "SFX.HO2JM", ZUNDEF))

!$OMP WORKSHARE
  WHERE ((YLPT1 (JZS)%ZDATA /= ZUNDEF) .AND. (ZOROG1IP > 0._JPRB))
    YLPT1 (JHO2IP)%ZDATA = + ZOROG1IP * 0.5_JPRB      
  ELSEWHERE
    YLPT1 (JHO2IP)%ZDATA = ZUNDEF
  ENDWHERE
!$OMP END WORKSHARE

!$OMP WORKSHARE
  WHERE ((YLPT1 (JZS)%ZDATA /= ZUNDEF) .AND. (ZOROG1IM < 0._JPRB))
    YLPT1 (JHO2IM)%ZDATA = - ZOROG1IM * 0.5_JPRB       
  ELSEWHERE
    YLPT1 (JHO2IM)%ZDATA = ZUNDEF
  ENDWHERE
!$OMP END WORKSHARE

!$OMP WORKSHARE
  WHERE ((YLPT1 (JZS)%ZDATA /= ZUNDEF) .AND. (ZOROG1JP > 0._JPRB))
    YLPT1 (JHO2JP)%ZDATA = + ZOROG1JP * 0.5_JPRB       
  ELSEWHERE
    YLPT1 (JHO2JP)%ZDATA = ZUNDEF
  ENDWHERE
!$OMP END WORKSHARE

!$OMP WORKSHARE
  WHERE ((YLPT1 (JZS)%ZDATA /= ZUNDEF) .AND. (ZOROG1JM < 0._JPRB))
    YLPT1 (JHO2JM)%ZDATA = - ZOROG1JM * 0.5_JPRB      
  ELSEWHERE
    YLPT1 (JHO2JM)%ZDATA = ZUNDEF
  ENDWHERE
!$OMP END WORKSHARE

  ! Interpolate AOS & HO2 

  YLFLDSAOS1 = ATLAS_FIELDSET ()

  DO JFLD = 1, SIZE (IAOSHO2)
    CALL YLFLDSAOS1%ADD (YLFL1 (IAOSHO2 (JFLD)))
  ENDDO

  YLFLDSAOS2 = YLINTEA%INTERPOLATE (YLFLDSAOS1)

  DO JFLD = 1, SIZE (IAOSHO2)
    CALL INS2 (IAOSHO2 (JFLD), YLFLDSAOS2%FIELD (JFLD))
!$OMP WORKSHARE
    WHERE ((YLPT2 (JZS)%ZDATA /= ZUNDEF) .AND. (YLPT2 (IAOSHO2 (JFLD))%ZDATA == ZUNDEF))
      YLPT2 (IAOSHO2 (JFLD))%ZDATA = 0._JPRB
    ENDWHERE
!$OMP END WORKSHARE
  ENDDO

  CALL YLOROG1IP%FINAL ()
  CALL YLOROG1IM%FINAL ()
  CALL YLOROG1JP%FINAL ()
  CALL YLOROG1JM%FINAL ()

  CALL YLIP%FINAL ()
  CALL YLIM%FINAL ()
  CALL YLJP%FINAL ()
  CALL YLJM%FINAL ()

  CALL YLINTE4    %FINAL ()
  CALL YLOROG1INT4%FINAL ()
  CALL YLFLDSHALF %FINAL ()
  CALL YLFLDSAOS1 %FINAL ()
  CALL YLFLDSAOS2 %FINAL ()

ENDBLOCK

! Compute fractions

BLOCK
  USE READCOVERS_MOD
  TYPE (COVERS_t) :: YLCOVERS
  REAL (KIND=JPRB) :: ZAVGCOVR2 (INCOVR)
  REAL (KIND=JPRB) :: ZMINCOVR2 (INCOVR)
  REAL (KIND=JPRB) :: ZMAXCOVR2 (INCOVR)
  INTEGER (KIND=JPIM) :: JCOV

  CALL INS2 (JFRAC_SEA   , NEWFLD (YLFSSC2, "SFX.FRAC_SEA"   , ZUNDEF))
  CALL INS2 (JFRAC_NATURE, NEWFLD (YLFSSC2, "SFX.FRAC_NATURE", ZUNDEF))
  CALL INS2 (JFRAC_TOWN  , NEWFLD (YLFSSC2, "SFX.FRAC_TOWN"  , ZUNDEF))
  CALL INS2 (JFRAC_WATER , NEWFLD (YLFSSC2, "SFX.FRAC_WATER" , ZUNDEF))

  CALL READCOVERS (YLCOVERS, 1, LGARDEN, LWATER_TO_NATURE, LTOWN_TO_ROCK)
  CALL FIELDSTAT (YLFSSC2, YLFL2 (JCOVER+1:JCOVER+INCOVR), PMIN=ZMINCOVR2, PMAX=ZMAXCOVR2, PAVG=ZAVGCOVR2)

  ALLOCATE (LCOVER (YLCOVERS%JPCOVER))
  LCOVER = .FALSE.

  LCOVER = ZAVGCOVR2 > 0._JPRB

  CALL MAKEFRAC (YLPT2 (JFRAC_SEA   )%ZDATA, YLFL2 (JCOVER+1:JCOVER+INCOVR), YLCOVERS%XDATA_SEA   , LCOVER)
  CALL MAKEFRAC (YLPT2 (JFRAC_NATURE)%ZDATA, YLFL2 (JCOVER+1:JCOVER+INCOVR), YLCOVERS%XDATA_NATURE, LCOVER)
  CALL MAKEFRAC (YLPT2 (JFRAC_TOWN  )%ZDATA, YLFL2 (JCOVER+1:JCOVER+INCOVR), YLCOVERS%XDATA_TOWN  , LCOVER)
  CALL MAKEFRAC (YLPT2 (JFRAC_WATER )%ZDATA, YLFL2 (JCOVER+1:JCOVER+INCOVR), YLCOVERS%XDATA_WATER , LCOVER)

ENDBLOCK

! Other

BLOCK

  CALL INS2 (JBATHY  , NEWFLD (YLFSSC2, "SFX.BATHY" , ZUNDEF))
  CALL INS2 (JRUNOFFB, NEWFLD (YLFSSC2, "SFX.RUNOFF", ZUNDEF))
  CALL INS2 (JWDRAIN , NEWFLD (YLFSSC2, "SFX.WDRAIN", ZUNDEF))

!$OMP WORKSHARE
  WHERE (YLPT2 (JFRAC_SEA)%ZDATA > 0._JPRB)
    YLPT2 (JBATHY)%ZDATA = -300._JPRB
  ELSEWHERE
    YLPT2 (JBATHY)%ZDATA = ZUNDEF
  ENDWHERE
!$OMP END WORKSHARE

!$OMP WORKSHARE
  WHERE (YLPT2 (JFRAC_NATURE)%ZDATA > 0._JPRB)
    YLPT2 (JRUNOFFB)%ZDATA = 0.5_JPRB
    YLPT2 (JWDRAIN)%ZDATA = 0.0_JPRB
  ELSEWHERE
    YLPT2 (JRUNOFFB)%ZDATA = ZUNDEF
    YLPT2 (JWDRAIN)%ZDATA = ZUNDEF
  ENDWHERE
!$OMP END WORKSHARE

ENDBLOCK

! Fix missing values: orography stuff, set to zero

BLOCK
  INTEGER (KIND=JPIM) :: IZS (17)
  IZS = &
& [ JZS   ,  JSSO_DIR, JSSO_SLOPE, JSSO_ANIS,  JSSO_STDEV, JAOSIP, &
&   JAOSIM,  JAOSJP  , JAOSJM    , JHO2IP   ,  JHO2IM    , JHO2JP, &
&   JHO2JM,  JMIN_ZS , JMAX_ZS   , JAVG_ZS  ,  JSIL_ZS   ]

  DO JFLD = 1, SIZE (IZS)
    IF (YLFL2 (IZS (JFLD))%IS_NULL ()) CYCLE
!$OMP WORKSHARE
    WHERE (YLPT2 (IZS (JFLD))%ZDATA == ZUNDEF)
      YLPT2 (IZS (JFLD))%ZDATA = 0._JPRB
    ENDWHERE
!$OMP END WORKSHARE
  ENDDO

ENDBLOCK


CALL YLIO%WRITE ('PGD1.fa', YLFLDS1, YLFSSC1)
CALL YLIO%WRITE ('PGD2.fa', YLFLDS2, YLFSSC2)

DO JFLD = 1, INFLD
  CALL YLFL1 (JFLD)%FINAL ()
  CALL YLFL2 (JFLD)%FINAL ()
ENDDO

CALL YLFLDS2%FINAL ()

CALL YLINTEA%FINAL ()

CALL ATLAS_LIBRARY%FINALISE()


WRITE (*, *) "--- STOP ---"

CONTAINS

LOGICAL ELEMENTAL FUNCTION ISINF (X)

REAL (KIND=JPRB), INTENT (IN) :: X

ISINF = X > HUGE (X)

END FUNCTION

SUBROUTINE CREATE_GRID_HDR (YDGRID, YDHDR)

TYPE (ATLAS_STRUCTUREDGRID) :: YDGRID
TYPE (HDR_t)                :: YDHDR

TYPE (ATLAS_CONFIG) :: YLCFGR, YLCFDO

YLCFGR = ATLAS_CONFIG ()
YLCFDO = ATLAS_CONFIG ()

CALL YLCFGR%SET ("nx", YDHDR%ICOLS)
CALL YLCFGR%SET ("ny", YDHDR%IROWS)
CALL YLCFGR%SET ("type", "shifted_lonlat")
CALL YLCFDO%SET ("type", "global")
CALL YLCFDO%SET ("units", "degrees")
CALL YLCFDO%SET ("west", YDHDR%ZWEST)
CALL YLCFGR%SET ("domain", YLCFDO)

YDGRID = ATLAS_STRUCTUREDGRID (YLCFGR)

CALL YLCFGR%FINAL ()
CALL YLCFDO%FINAL ()

END SUBROUTINE

SUBROUTINE CREATE_GRID_NML (YDGRID, CDNML)

TYPE (ATLAS_STRUCTUREDGRID) :: YDGRID
CHARACTER (LEN=*)           :: CDNML

LOGICAL :: LLEXIST

TYPE GRID_OPTIONS_t
  INTEGER (KIND=JPIM) :: NLOEN (30000) = 0
  INTEGER (KIND=JPIM) :: NDLON = 0, NDGLG = 0
  LOGICAL :: LELAM    = .FALSE.
  LOGICAL :: LROTATED = .FALSE. 
  LOGICAL :: LSTRETCH = .FALSE.
  REAL (KIND=JPRB) :: RSTRETCH = 1._JPRB
  REAL (KIND=JPRB) :: RLONCENT = 0._JPRB  ! Degrees
  REAL (KIND=JPRB) :: RLATCENT = 90._JPRB ! Degrees

  REAL (KIND=JPRB) :: DXINMETRES = 10000._JPRB
  REAL (KIND=JPRB) :: DYINMETRES = 10000._JPRB

  REAL (KIND=JPRB) :: LADINDEGREES    = 46.2_JPRB
  REAL (KIND=JPRB) :: LATIN1INDEGREES = 46.2_JPRB
  REAL (KIND=JPRB) :: LATIN2INDEGREES = 46.2_JPRB
  REAL (KIND=JPRB) :: LOVINDEGREES    =  2.0_JPRB
  INTEGER (KIND=JPIM) :: NUX, NUY
END TYPE GRID_OPTIONS_t

TYPE (GRID_OPTIONS_t) :: YLGROPT

NAMELIST / NAMGRID / YLGROPT

OPEN (4, FILE=TRIM (CDNML), FORM="FORMATTED")
READ (4, NAMGRID)
CLOSE (4)

IF (YLGROPT%LELAM) THEN
  YDGRID = ATLAS_LAMBERTREGIONALGRID (YLGROPT%NDLON, YLGROPT%NDGLG, &
                                    & -YLGROPT%NUX / 2 * YLGROPT%DXINMETRES, &
                                    & -YLGROPT%NUY / 2 * YLGROPT%DYINMETRES, &
                                    & YLGROPT%DXINMETRES, YLGROPT%DYINMETRES, &
                                    & YLGROPT%LOVINDEGREES, YLGROPT%LADINDEGREES, &
                                    & YLGROPT%LATIN1INDEGREES, YLGROPT%LATIN2INDEGREES)
ELSE IF (YLGROPT%RLONCENT /= 0._JPRB .OR. YLGROPT%RLATCENT /= 90._JPRB) THEN
  YDGRID = ATLAS_REDUCEDGAUSSIANGRID (YLGROPT%NLOEN (1:YLGROPT%NDGLG), &
          & [YLGROPT%RLONCENT, YLGROPT%RLATCENT], YLGROPT%RSTRETCH)
ELSE
  YDGRID = ATLAS_REDUCEDGAUSSIANGRID (YLGROPT%NLOEN (1:YLGROPT%NDGLG))
ENDIF

END SUBROUTINE

SUBROUTINE CREATE_DIST (YDGRID, YDDIST, LDLIGHT)

USE ATLAS_FA, ONLY : ISMGLO

TYPE (ATLAS_STRUCTUREDGRID)   :: YDGRID
TYPE (ATLAS_GRIDDISTRIBUTION) :: YDDIST
LOGICAL, OPTIONAL             :: LDLIGHT

#include "abor1.intfb.h"

TYPE (ATLAS_CONFIG) :: YLCONF

CHARACTER (LEN=64)  :: CLDIST
LOGICAL             :: LLLIGHT

IF (ISMGLO (YDGRID)) THEN
  CLDIST = "equal_regions"
ELSE
  CLDIST = "checkerboard"
ENDIF

LLLIGHT = .FALSE.
IF (PRESENT (LDLIGHT)) LLLIGHT = LDLIGHT

YLCONF = ATLAS_CONFIG() 

SELECT CASE (CLDIST)
  CASE ('checkerboard') 
    CALL YLCONF%SET ('type', 'checkerboard')
    IF (LLLIGHT) THEN
      CALL YLCONF%SET ('light', .TRUE.)
      CALL YLCONF%SET ('blocksize', INT (YDGRID%NX (1)))
    ENDIF
  CASE ('equal_regions')
    CALL YLCONF%SET ('type', 'equal_regions')
  CASE DEFAULT
    CALL ABOR1 ('UNKNOWN DISTRIBUTION TYPE :'//TRIM (CLDIST))
END SELECT 

YDDIST = ATLAS_GRIDDISTRIBUTION (YDGRID, YLCONF)

CALL YLCONF%FINAL ()

END SUBROUTINE

FUNCTION NEWFLD (YDFSSC, CDNAME, PUNDEF) RESULT (YLFLD)

TYPE (ATLAS_FIELD) :: YLFLD

TYPE (ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS), INTENT (IN)  :: YDFSSC
CHARACTER (LEN=*),                            INTENT (IN)  :: CDNAME
REAL (KIND=JPRB), OPTIONAL,                   INTENT (IN)  :: PUNDEF

TYPE (ATLAS_METADATA) :: YLMETA

YLFLD = ATLAS_FIELD (NAME=TRIM (CDNAME), KIND=JPRB, SHAPE=[YDFSSC%SIZE ()])

IF (PRESENT (PUNDEF)) THEN
  YLMETA = YLFLD%METADATA ()
  CALL YLMETA%SET ("undef", PUNDEF)
  CALL YLMETA%FINAL ()
ENDIF

CALL YLFLD%RETURN ()

END FUNCTION

FUNCTION DIR (CDFILE, YDHDR, YDFSSC, YDGRID, PSCALE) RESULT (YLFLD)

TYPE (ATLAS_FIELD) :: YLFLD

CHARACTER (LEN=*),                            INTENT (IN)     :: CDFILE
TYPE (HDR_t),                                 INTENT (INOUT)  :: YDHDR
TYPE (ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS), INTENT (IN)     :: YDFSSC
TYPE (ATLAS_STRUCTUREDGRID),                  INTENT (IN)     :: YDGRID
REAL (KIND=JPRB), OPTIONAL,                   INTENT (IN)     :: PSCALE

INTEGER (KIND=JPIM), ALLOCATABLE :: ISIZE (:)
INTEGER (KIND=JPIM) :: IPROC, IOFFS (NPROC+1), INX

INTEGER*1, ALLOCATABLE :: IL1 (:)
INTEGER*2, ALLOCATABLE :: IL2 (:)
INTEGER (KIND=JPIM) :: IROW, ICOL, IOFF, JLAT, IROW1, IROW2, I
REAL (KIND=JPRB), POINTER :: ZDATA (:)

YLFLD = NEWFLD (YDFSSC, TRIM (CDFILE), ZUNDEF)

CALL YLFLD%DATA (ZDATA)

ALLOCATE (ISIZE (YLCOMM%SIZE ()))

CALL YLCOMM%ALLGATHER ([YDFSSC%SIZE_OWNED ()], ISIZE, 1, &
                     & [(1, I = 0, YLCOMM%SIZE ())],      &
                     & [(I, I = 0, YLCOMM%SIZE ())]);

IOFFS (1) = 0
DO IPROC = 2, NPROC+1
  IOFFS (IPROC) = IOFFS (IPROC-1) + ISIZE (IPROC-1)
ENDDO

IPROC = IRANK + 1

INX = YDGRID%NX (1)

IF (MODULO (IOFFS (IPROC), INX) /= 0) THEN
  CALL ABOR1 ('DIR: DISTRIBUTION MISMATCH')
ENDIF

IROW1 = 1 + IOFFS (IPROC+0) / INX
IROW2 = 0 + IOFFS (IPROC+1) / INX

IF (SIZE (ZDATA) < INX * (IROW2-IROW1+1)) THEN
  CALL ABOR1 ('DIR: ZDATA IS TOO SMALL')
ENDIF

OPEN (77, FILE=TRIM (CDFILE)//'.dir', FORM='UNFORMATTED', ACTION='READ', &
    & ACCESS='DIRECT', RECL=((YDHDR%ICOLS * YDHDR%IWIDTH) / 8))

SELECT CASE (YDHDR%IWIDTH)

  CASE ( 8)
  
    ALLOCATE (IL1 (YDHDR%ICOLS))

    IOFF = 0
    DO IROW = IROW1, IROW2
      READ (77, REC=IROW) IL1
      WHERE (IL1 < 0)
        ZDATA (IOFF+1:IOFF+YDHDR%ICOLS) = IL1 + 256
      ELSEWHERE
        ZDATA (IOFF+1:IOFF+YDHDR%ICOLS) = IL1 
      ENDWHERE
      IOFF = IOFF + YDHDR%ICOLS
    ENDDO

  CASE (16)

    ALLOCATE (IL2 (YDHDR%ICOLS))

    IOFF = 0
    DO IROW = IROW1, IROW2
      READ (77, REC=IROW) IL2
      ZDATA (IOFF+1:IOFF+YDHDR%ICOLS) = IL2 
      IOFF = IOFF + YDHDR%ICOLS
    ENDDO

  CASE DEFAULT

    STOP

END SELECT

CLOSE (77)


IF (PRESENT (PSCALE)) THEN
  WHERE (ZDATA /= YDHDR%RUNDEF)
    ZDATA = ZDATA * PSCALE
  END WHERE
ENDIF

WHERE (ZDATA == YDHDR%RUNDEF)
  ZDATA = ZUNDEF
END WHERE
YDHDR%RUNDEF = ZUNDEF

CALL YLFLD%RETURN ()

END FUNCTION

SUBROUTINE HDR (CDFILE, YDHDR)

CHARACTER (LEN=*), INTENT (IN)  :: CDFILE
TYPE (HDR_t),      INTENT (OUT) :: YDHDR

CHARACTER (LEN=256) :: CLLINE

OPEN (77, FILE=TRIM (CDFILE)//'.hdr', FORM='FORMATTED')

READ (77, '(A)') CLLINE

YDHDR%CLCOMMENT = CLLINE

DO 
  READ (77, '(A256)', END=999) CLLINE
  IF (CLLINE (1:7) == 'nodata:'             ) READ (CLLINE ( 8:), *) YDHDR%RUNDEF
  IF (CLLINE (1:6) == 'north:'              ) READ (CLLINE ( 7:), *) YDHDR%ZNORTH
  IF (CLLINE (1:6) == 'south:'              ) READ (CLLINE ( 7:), *) YDHDR%ZSOUTH
  IF (CLLINE (1:5) == 'west:'               ) READ (CLLINE ( 6:), *) YDHDR%ZWEST
  IF (CLLINE (1:5) == 'east:'               ) READ (CLLINE ( 6:), *) YDHDR%ZEAST
  IF (CLLINE (1:5) == 'rows:'               ) READ (CLLINE ( 6:), *) YDHDR%IROWS
  IF (CLLINE (1:5) == 'cols:'               ) READ (CLLINE ( 6:), *) YDHDR%ICOLS
  IF (CLLINE (1:19) == 'recordtype: integer') READ (CLLINE (20:), *) YDHDR%IWIDTH
ENDDO

999 CONTINUE

CLOSE (77)

SELECT CASE (YDHDR%IWIDTH)

  CASE ( 8)
  
    IF (YDHDR%RUNDEF < 0) YDHDR%RUNDEF = YDHDR%RUNDEF + 256._JPRB

  CASE DEFAULT

END SELECT


END SUBROUTINE 

SUBROUTINE COMPARE_GEOMHDR (YDHDR1, YDHDR2)

TYPE (HDR_t),  INTENT (IN) :: YDHDR1, YDHDR2

#include "abor1.intfb.h"

IF (YDHDR1%ZWEST  /= YDHDR2%ZWEST ) CALL ABOR1 ('COMPARE_GEOMHDR: DIFFERENT ZWEST ')
IF (YDHDR1%ZEAST  /= YDHDR2%ZEAST ) CALL ABOR1 ('COMPARE_GEOMHDR: DIFFERENT ZEAST ')
IF (YDHDR1%ZNORTH /= YDHDR2%ZNORTH) CALL ABOR1 ('COMPARE_GEOMHDR: DIFFERENT ZNORTH')
IF (YDHDR1%ZSOUTH /= YDHDR2%ZSOUTH) CALL ABOR1 ('COMPARE_GEOMHDR: DIFFERENT ZSOUTH')
IF (YDHDR1%ICOLS  /= YDHDR2%ICOLS ) CALL ABOR1 ('COMPARE_GEOMHDR: DIFFERENT ICOLS ')
IF (YDHDR1%IROWS  /= YDHDR2%IROWS ) CALL ABOR1 ('COMPARE_GEOMHDR: DIFFERENT IROWS ')

END SUBROUTINE

SUBROUTINE FIELDSTAT (YLFSSC, YLFLDS, PMIN, PMAX, PAVG)

USE FCKIT_MPI_MODULE

TYPE (ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS), INTENT (IN)  :: YLFSSC
TYPE (ATLAS_FIELD),                           INTENT (IN)  :: YLFLDS (:)
REAL (KIND=JPRB), OPTIONAL,                   INTENT (OUT) :: PMIN (:), PMAX (:), PAVG (:)

INTEGER (KIND=JPIM)   :: NPROC, INFLD, IGPTOT
TYPE (FCKIT_MPI_COMM) :: YLCOMM

TYPE (PTR),          ALLOCATABLE :: YLPTR (:)
LOGICAL,             ALLOCATABLE :: LLUNDEF (:)
REAL (KIND=JPRB),    ALLOCATABLE :: ZUNDEF (:), ZMMSALL (:), ZMMS (:)
INTEGER (KIND=JPIM), ALLOCATABLE :: ICNTALL (:), ICNT (:), IRECVCNT (:), IDISPCNT (:)
INTEGER (KIND=JPIM) :: JFLD, IOFF, INUM, IPROC

TYPE (ATLAS_METADATA) :: YLMETA

IGPTOT = YLFSSC%SIZE_OWNED ()
INFLD  = SIZE (YLFLDS)
YLCOMM = FCKIT_MPI_COMM ()
NPROC  = YLCOMM%SIZE ()

ALLOCATE (YLPTR (INFLD), LLUNDEF (INFLD), ZUNDEF (INFLD), ZMMSALL (3 * INFLD * NPROC), &
        & ZMMS (3 * INFLD), ICNTALL (INFLD * NPROC), ICNT (INFLD), IRECVCNT (NPROC), IDISPCNT (NPROC))

ZUNDEF = HUGE (1._JPRB)

DO JFLD = 1, INFLD
  CALL YLFLDS (JFLD)%DATA (YLPTR (JFLD)%ZDATA)
  YLMETA = YLFLDS (JFLD)%METADATA ()
  LLUNDEF (JFLD) = YLMETA%HAS ("undef")
  IF (LLUNDEF (JFLD)) CALL YLMETA%GET ("undef", ZUNDEF (JFLD))
  CALL YLMETA%FINAL ()
ENDDO


!$OMP PARALLEL DO PRIVATE (JFLD)
DO JFLD = 1, INFLD
  IF (LLUNDEF (JFLD)) THEN
    ICNT (JFLD) = COUNT  (YLPTR (JFLD)%ZDATA (1:IGPTOT) /= ZUNDEF (JFLD))
    IF (ICNT (JFLD) > 0) THEN
      ZMMS (3*(JFLD-1)+1) = MINVAL (YLPTR (JFLD)%ZDATA (1:IGPTOT), MASK=YLPTR (JFLD)%ZDATA (1:IGPTOT)/=ZUNDEF (JFLD))
      ZMMS (3*(JFLD-1)+2) = MAXVAL (YLPTR (JFLD)%ZDATA (1:IGPTOT), MASK=YLPTR (JFLD)%ZDATA (1:IGPTOT)/=ZUNDEF (JFLD))
      ZMMS (3*(JFLD-1)+3) = SUM    (YLPTR (JFLD)%ZDATA (1:IGPTOT), MASK=YLPTR (JFLD)%ZDATA (1:IGPTOT)/=ZUNDEF (JFLD))
    ELSE
      ZMMS (3*(JFLD-1)+1) = ZUNDEF (JFLD)
      ZMMS (3*(JFLD-1)+2) = ZUNDEF (JFLD)
      ZMMS (3*(JFLD-1)+3) = ZUNDEF (JFLD)
    ENDIF
  ELSE
    ICNT (JFLD) = IGPTOT
    ZMMS (3*(JFLD-1)+1) = MINVAL (YLPTR (JFLD)%ZDATA (1:IGPTOT))
    ZMMS (3*(JFLD-1)+2) = MAXVAL (YLPTR (JFLD)%ZDATA (1:IGPTOT))
    ZMMS (3*(JFLD-1)+3) = SUM    (YLPTR (JFLD)%ZDATA (1:IGPTOT))
  ENDIF
ENDDO
!$OMP END PARALLEL DO

IRECVCNT (:) = 1
IDISPCNT (1) = 0
DO IPROC = 2, NPROC
  IDISPCNT (IPROC) = IDISPCNT (IPROC-1) + IRECVCNT (IPROC-1)
ENDDO

CALL YLCOMM%ALLGATHER (ZMMS, ZMMSALL, INFLD * 3, IRECVCNT * INFLD * 3, IDISPCNT * INFLD * 3)
CALL YLCOMM%ALLGATHER (ICNT, ICNTALL, INFLD * 1, IRECVCNT * INFLD * 1, IDISPCNT * INFLD * 1)
  
!$OMP PARALLEL DO PRIVATE (JFLD, IOFF, INUM)
DO JFLD = 1, INFLD
  IOFF = 3*(JFLD-1)
  INUM = 3*INFLD
  IF (LLUNDEF (JFLD)) THEN
    IF (PRESENT (PMIN)) PMIN (JFLD) = MINVAL (ZMMSALL (IOFF+1::INUM), MASK=ZMMSALL (IOFF+1::INUM)/=ZUNDEF (JFLD))
    IF (PRESENT (PMAX)) PMAX (JFLD) = MAXVAL (ZMMSALL (IOFF+2::INUM), MASK=ZMMSALL (IOFF+2::INUM)/=ZUNDEF (JFLD))
    IF (PRESENT (PAVG)) PAVG (JFLD) = SUM    (ZMMSALL (IOFF+3::INUM), MASK=ZMMSALL (IOFF+3::INUM)/=ZUNDEF (JFLD)) 
  ELSE
    IF (PRESENT (PMIN)) PMIN (JFLD) = MINVAL (ZMMSALL (IOFF+1::INUM))
    IF (PRESENT (PMAX)) PMAX (JFLD) = MAXVAL (ZMMSALL (IOFF+2::INUM))
    IF (PRESENT (PAVG)) PAVG (JFLD) = SUM    (ZMMSALL (IOFF+3::INUM))
  ENDIF
  INUM = SUM (ICNTALL ((JFLD-1)+1::INFLD))
  IF (PRESENT (PAVG)) THEN
    IF (INUM > 0) THEN
      PAVG (JFLD) = PAVG (JFLD) / REAL (INUM, JPRB)
    ELSE
      PAVG (JFLD) = ZUNDEF (JFLD)
    ENDIF
  ENDIF
ENDDO
!$OMP END PARALLEL DO

#ifdef UNDEF
DO JFLD = 1, SIZE (YLFLDS)
  WRITE (*, '(A16," > ",F12.4," | ",F12.4," | ",F12.4)') &
       & YLFLDS (JFLD)%NAME (), PAVG (JFLD), PMIN (JFLD), PMAX (JFLD)
ENDDO
#endif

END SUBROUTINE

SUBROUTINE MAKEFRAC (PFRAC, YDCOVER, PDATA, LDCOVER)

REAL (KIND=JPRB),   INTENT (OUT) :: PFRAC (:)
TYPE (ATLAS_FIELD), INTENT (IN)  :: YDCOVER (:)
REAL (KIND=JPRB),   INTENT (IN)  :: PDATA (:)
LOGICAL,            INTENT (IN)  :: LDCOVER (:)

TYPE (PTR) :: YLPTR (SIZE (YDCOVER))

INTEGER (KIND=JPIM) :: JLOC, JCOV, INCOV
REAL (KIND=JPRB) :: ZSUM

INCOV = SIZE (YDCOVER)

DO JCOV = 1, INCOV
  CALL YDCOVER (JCOV)%DATA (YLPTR (JCOV)%ZDATA)
ENDDO

!$OMP PARALLEL DO PRIVATE (JLOC, ZSUM, JCOV)
DO JLOC = 1, SIZE (PFRAC)
  PFRAC (JLOC) = 0._JPRB
  ZSUM = 0._JPRB
  DO JCOV = 1, INCOV
    IF (LDCOVER (JCOV)) THEN
      PFRAC (JLOC) = PFRAC (JLOC) + YLPTR (JCOV)%ZDATA (JLOC) * PDATA (JCOV)
      ZSUM         = ZSUM + YLPTR (JCOV)%ZDATA (JLOC)
    ENDIF
  ENDDO
  PFRAC (JLOC) = PFRAC (JLOC) / ZSUM
ENDDO
!$OMP END PARALLEL DO

END SUBROUTINE

SUBROUTINE INS1 (KRANK, YDFL)

INTEGER (KIND=JPIM), INTENT (IN) :: KRANK
TYPE (ATLAS_FIELD),  INTENT (IN) :: YDFL

#include "abor1.intfb.h"

IF (.NOT. YLFL1 (KRANK)%IS_NULL ()) CALL ABOR1 ('FIELD ALREADY EXISTS')
IF (YDFL%SIZE () /= YLFSSC1%SIZE ()) CALL ABOR1 ('SIZE MISMATCH')
YLFL1 (KRANK) = YDFL
CALL YDFL%DATA (YLPT1 (KRANK)%ZDATA)
CALL YLFLDS1%ADD (YDFL)

END SUBROUTINE

SUBROUTINE INS2 (KRANK, YDFL)

INTEGER (KIND=JPIM), INTENT (IN) :: KRANK
TYPE (ATLAS_FIELD),  INTENT (IN) :: YDFL

#include "abor1.intfb.h"

IF (.NOT. YLFL2 (KRANK)%IS_NULL ()) CALL ABOR1 ('FIELD ALREADY EXISTS')
IF (YDFL%SIZE () /= YLFSSC2%SIZE ()) CALL ABOR1 ('SIZE MISMATCH')
YLFL2 (KRANK) = YDFL
CALL YDFL%DATA (YLPT2 (KRANK)%ZDATA)
CALL YLFLDS2%ADD (YDFL)

END SUBROUTINE

END

