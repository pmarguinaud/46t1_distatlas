SUBROUTINE ATLAS_PGD_IMPL (YDIO1, YDIO2, YDGRID2, LDOPENMP, LDROTATE, PELLIPSE, LDENVELOPPE)

USE PARKIND1, ONLY : JPIM, JPRB
USE INTERPOLATIONA_MOD
USE INTERPOLATION4_MOD
USE GRADIENT_MOD
USE ATLAS_IO, ONLY : ATLAS_IO_t
USE FCKIT_MODULE, ONLY : FCKIT_MPI_COMM, FCKIT_EXCEPTION
USE ATLAS_MODULE  
USE ATLAS_HELPER
USE READCOVERS_MOD

#include "atlas-abort.h"

!

IMPLICIT NONE

! Constants

REAL (KIND=JPRB), PARAMETER :: RPI = 2.0_JPRB * ASIN (1.0_JPRB)
REAL (KIND=JPRB), PARAMETER :: RA = 6371229._JPRB
REAL (KIND=JPRB), PARAMETER :: ZUNDEF = HUGE (1._JPRB)
INTEGER (KIND=JPIM), PARAMETER :: INCOVR = 256_JPIM
LOGICAL, PARAMETER :: LGARDEN = .FALSE., LWATER_TO_NATURE = .FALSE., LTOWN_TO_ROCK = .TRUE.

! Objects defined on source geometry are labelled with "1"
! Objects defined on target geometry are labelled with "2"

! Objects for handling fileformats

CLASS (ATLAS_IO_t)                           :: YDIO1
CLASS (ATLAS_IO_t)                           :: YDIO2

! Grids

TYPE  (ATLAS_STRUCTUREDGRID)                 :: YLGRID1
CLASS (ATLAS_STRUCTUREDGRID)                 :: YDGRID2

LOGICAL, OPTIONAL                            :: LDOPENMP
LOGICAL, OPTIONAL                            :: LDROTATE
LOGICAL, OPTIONAL                            :: LDENVELOPPE
REAL (KIND=JPRB), OPTIONAL, POINTER          :: PELLIPSE (:)

#include "atlas-compute-covers.h"
#include "atlas-compute-sso.h"
#include "atlas-compute-aos.h"

! Grids of input files

TYPE (ATLAS_STRUCTUREDGRID)                  :: YLGRID_OROG
TYPE (ATLAS_STRUCTUREDGRID)                  :: YLGRID_SAND
TYPE (ATLAS_STRUCTUREDGRID)                  :: YLGRID_CLAY
TYPE (ATLAS_STRUCTUREDGRID)                  :: YLGRID_COVR

! Functionspaces

TYPE (ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS) :: YLFSSC1
TYPE (ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS) :: YLFSSC2

! Distributions (of grids on MPI tasks)

TYPE (ATLAS_GRIDDISTRIBUTION)                :: YLDIST1
TYPE (ATLAS_GRIDDISTRIBUTION)                :: YLDIST2

! Interpolation (source grid -> target grid)

TYPE (INTERPOLATIONA)                        :: YLINTEA

! Field sets

TYPE (ATLAS_FIELDSET)                        :: YLFLDS1  
TYPE (ATLAS_FIELDSET)                        :: YLFLDS2
TYPE (ATLAS_FIELDSET)                        :: YLFLDS2I

! Communicator

TYPE (FCKIT_MPI_COMM)                        :: YLCOMM

INTEGER (KIND=JPIM) :: I, JFLD
INTEGER (KIND=JPIM) :: NPROC, IRANK


! Atlas fields for target geometry

TYPE (ATLAS_FIELD), ALLOCATABLE :: YLFL2 (:)

! Pointers to access data of target fields

TYPE (PTR),         ALLOCATABLE :: YLPT2 (:)

INTEGER (KIND=JPIM) :: INFLD

TYPE (ATLAS_FIELD) :: YLOROG1, YLCLAY1, YLSAND1, YLCOVR1
REAL (KIND=JPRB), POINTER, DIMENSION (:) :: ZOROG1, ZCLAY1, ZSAND1, ZCOVR1

! Indices of all fields

INTEGER (KIND=JPIM) :: JZS, JSAND, JCLAY
INTEGER (KIND=JPIM) :: JMIN_ZS, JMAX_ZS, JAVG_ZS, JSIL_ZS
INTEGER (KIND=JPIM) :: JSSO_DIR, JSSO_SLOPE, JSSO_ANIS, JSSO_STDEV
INTEGER (KIND=JPIM) :: JAOSIP, JAOSIM, JAOSJP, JAOSJM, JHO2IP, JHO2IM, JHO2JP, JHO2JM
INTEGER (KIND=JPIM) :: JFRAC_SEA, JFRAC_WATER, JFRAC_NATURE, JFRAC_TOWN
INTEGER (KIND=JPIM) :: JBATHY, JRUNOFFB, JWDRAIN, JCOVER


LOGICAL :: LLOPENMP, LLROTATE, LLELLIPSE, LLENVELOPPE

LLOPENMP = .TRUE.
IF (PRESENT (LDOPENMP)) LLOPENMP = LDOPENMP

LLROTATE = .TRUE.
IF (PRESENT (LDROTATE)) LLROTATE = LDROTATE

LLELLIPSE = .FALSE.
IF (PRESENT (PELLIPSE)) LLELLIPSE = ASSOCIATED (PELLIPSE) 

LLENVELOPPE = .TRUE.
IF (PRESENT (LDENVELOPPE)) LLENVELOPPE = LDENVELOPPE

! MPI info

YLCOMM = FCKIT_MPI_COMM ()
NPROC  = YLCOMM%SIZE ()
IRANK  = YLCOMM%RANK ()

! Create source grids & check compatibility

YLGRID_OROG = YDIO1%GRID ("SFX.ZS"   )
YLGRID_CLAY = YDIO1%GRID ("SFX.CLAY" )
YLGRID_SAND = YDIO1%GRID ("SFX.SAND" )
YLGRID_COVR = YDIO1%GRID ("SFX.COVER")

IF (.NOT. (GRID_EQ (YLGRID_OROG, YLGRID_CLAY))) CALL ABORT ("GEOMETRY MISMATCH")
IF (.NOT. (GRID_EQ (YLGRID_OROG, YLGRID_SAND))) CALL ABORT ("GEOMETRY MISMATCH")
IF (.NOT. (GRID_EQ (YLGRID_OROG, YLGRID_COVR))) CALL ABORT ("GEOMETRY MISMATCH")

YLGRID1 = YLGRID_OROG

! Not needed anymore, finalize

CALL YLGRID_OROG%FINAL ()
CALL YLGRID_CLAY%FINAL ()
CALL YLGRID_SAND%FINAL ()
CALL YLGRID_COVR%FINAL ()

! Create distributions for both source & target grids

CALL CREATE_DIST (YLGRID1, YLDIST1, .TRUE.)
CALL CREATE_DIST (YDGRID2, YLDIST2)

! Create functionspaces

BLOCK
  TYPE (ATLAS_CONFIG) :: YLCONF
  YLCONF = ATLAS_CONFIG ()
  CALL YLCONF%SET ("halo", 1)
  YLFSSC1 = ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS (YLGRID1, YLDIST1, YLCONF)
  YLFSSC2 = ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS (YDGRID2, YLDIST2, YLCONF)
  CALL YLCONF%FINAL ()
ENDBLOCK

! Define indices for all fields

INFLD = 0

#define ADDFLD(J) INFLD = INFLD + 1; J = INFLD

ADDFLD (JZS         ); ADDFLD (JSAND       ); ADDFLD (JCLAY       ); 
ADDFLD (JSSO_DIR    ); ADDFLD (JSSO_SLOPE  ); ADDFLD (JSSO_ANIS   ); ADDFLD (JSSO_STDEV  ); 
ADDFLD (JAOSIP      ); ADDFLD (JAOSIM      ); ADDFLD (JAOSJP      ); ADDFLD (JAOSJM      );
ADDFLD (JHO2IP      ); ADDFLD (JHO2IM      ); ADDFLD (JHO2JP      ); ADDFLD (JHO2JM      );
ADDFLD (JFRAC_SEA   ); ADDFLD (JFRAC_TOWN  ); ADDFLD (JFRAC_WATER ); ADDFLD (JFRAC_NATURE);
ADDFLD (JBATHY      ); ADDFLD (JRUNOFFB    ); ADDFLD (JWDRAIN     ); ADDFLD (JMIN_ZS     );
ADDFLD (JMAX_ZS     ); ADDFLD (JAVG_ZS     ); ADDFLD (JSIL_ZS     );


JCOVER = INFLD
INFLD = INFLD + INCOVR

#undef ADDFLD

! Allocate fields & pointers

ALLOCATE (YLFL2 (INFLD), YLPT2 (INFLD))

YLFLDS2 = ATLAS_FIELDSET ()

! Create interpolation object (source -> target)

YLINTEA = INTERPOLATIONA (YLDIST1, YLFSSC1, YLDIST2, YLFSSC2, LDOPENMP)

! Read input fields on source geometry

YLOROG1 = RNS1 ("SFX.ZS"                    ); CALL YLOROG1%DATA (ZOROG1)
YLCLAY1 = RNS1 ("SFX.CLAY", PSCALE=0.01_JPRB); CALL YLCLAY1%DATA (ZCLAY1)
YLSAND1 = RNS1 ("SFX.SAND", PSCALE=0.01_JPRB); CALL YLSAND1%DATA (ZSAND1)
YLCOVR1 = RNS1 ("SFX.COVER"                 ); CALL YLCOVR1%DATA (ZCOVR1)

IF (LLELLIPSE) CALL ELLIPSE ()

BLOCK
  TYPE (ATLAS_FIELDSET) :: YLFLDSCOVR2
  TYPE (ATLAS_FIELD) :: YLCOVR2
  INTEGER (KIND=JPIM) :: ICOV
  CHARACTER (LEN=:), ALLOCATABLE :: CLNAME

  YLFLDSCOVR2 = ATLAS_COMPUTE_COVERS (YLFSSC1, YLFSSC2, YLCOVR1, YLINTEA, LLOPENMP) 

  DO ICOV = 1, YLFLDSCOVR2%SIZE ()
    YLCOVR2 = YLFLDSCOVR2%FIELD (ICOV)
    CLNAME = YLCOVR2%NAME ()
    CALL YLCOVR2%RENAME ("SFX."//CLNAME)
    CALL INS2 (JCOVER+ICOV, YLCOVR2)
    DEALLOCATE (CLNAME)
  ENDDO
  
  CALL YLFLDSCOVR2%FINAL ()
ENDBLOCK

! Set missing values of orography

!$OMP WORKSHARE
WHERE (ZCOVR1 == 1._JPRB) ! Sea 
  ZOROG1 = ZUNDEF
ENDWHERE
!$OMP END WORKSHARE

! Interpolate fields using box averaging

YLFLDS1 = ATLAS_FIELDSET ()
CALL YLFLDS1%ADD (YLOROG1)
CALL YLFLDS1%ADD (YLCLAY1)
CALL YLFLDS1%ADD (YLSAND1)
YLFLDS2I = YLINTEA%INTERPOLATE (YLFLDS1)
CALL YLFLDS1%FINAL ()

! Insert interpolated fields in the list of fields of target geometry

CALL INS2 (JZS     , YLFLDS2I%FIELD ("SFX.ZS"      ))
CALL INS2 (JSAND   , YLFLDS2I%FIELD ("SFX.SAND"    ))
CALL INS2 (JCLAY   , YLFLDS2I%FIELD ("SFX.CLAY"    ))

CALL YLFLDS2I%FINAL ()

! Min, max, avg orography

BLOCK
 
  CALL INS2 (JAVG_ZS, NEWFLD (YLFSSC2, "SFX.AVG_ZS", ZUNDEF))
  CALL INS2 (JSIL_ZS, NEWFLD (YLFSSC2, "SFX.SIL_ZS", ZUNDEF))

  YLPT2 (JAVG_ZS)%ZDATA = YLPT2 (JZS)%ZDATA
  YLPT2 (JSIL_ZS)%ZDATA = YLPT2 (JZS)%ZDATA

! Use min and max reduction of interpolation object; default reduction is +

  CALL INS2 (JMIN_ZS, YLINTEA%INTERPOLATE (YLOROG1, YLINTEA%OPT_MIN ()))
  CALL INS2 (JMAX_ZS, YLINTEA%INTERPOLATE (YLOROG1, YLINTEA%OPT_MAX ()))

  CALL YLFL2 (JMIN_ZS)%RENAME ("SFX.MIN_ZS")
  CALL YLFL2 (JMAX_ZS)%RENAME ("SFX.MAX_ZS")

ENDBLOCK

BLOCK
  TYPE (ATLAS_FIELDSET) :: YLFLDS2SSO
  TYPE (ATLAS_FIELD)    :: YLFLD2

  YLFLDS2SSO = ATLAS_COMPUTE_SSO (YLFSSC1, YLFSSC2, YLOROG1, YLINTEA, LLOPENMP, LLROTATE) 

  YLFLD2 = YLFLDS2SSO%FIELD ("SSO_DIR"  ); CALL YLFLD2%RENAME ("SFX.SSO_DIR"  ); CALL INS2 (JSSO_DIR  , YLFLD2)
  YLFLD2 = YLFLDS2SSO%FIELD ("SSO_SLOPE"); CALL YLFLD2%RENAME ("SFX.SSO_SLOPE"); CALL INS2 (JSSO_SLOPE, YLFLD2)
  YLFLD2 = YLFLDS2SSO%FIELD ("SSO_ANIS" ); CALL YLFLD2%RENAME ("SFX.SSO_ANIS" ); CALL INS2 (JSSO_ANIS , YLFLD2)
  YLFLD2 = YLFLDS2SSO%FIELD ("SSO_STDEV"); CALL YLFLD2%RENAME ("SFX.SSO_STDEV"); CALL INS2 (JSSO_STDEV, YLFLD2)
ENDBLOCK

IF (LLENVELOPPE) THEN

!$OMP WORKSHARE 
  WHERE (YLPT2 (JZS)%ZDATA (:) /= ZUNDEF)
    YLPT2 (JZS)%ZDATA (:) = YLPT2 (JZS)%ZDATA (:) + YLPT2 (JSSO_STDEV)%ZDATA
  ENDWHERE
!$OMP END WORKSHARE

ENDIF


BLOCK
  INTEGER (KIND=JPIM) :: JFLD
  TYPE (ATLAS_FIELD) :: YLFLD2
  INTEGER (KIND=JPIM) :: IAOSHO (8)
  CHARACTER (LEN=16) :: CLAOSN (8) 
  TYPE (ATLAS_FIELDSET) :: YLFLDSAOS2
  TYPE (INTERPOLATION4) :: YLINTE4

  YLINTE4 = INTERPOLATION4 (YLDIST2, YLFSSC2, YLDIST1, YLFSSC1)

  YLFLDSAOS2 = ATLAS_COMPUTE_AOS (YLFSSC1, YLFSSC2, YLOROG1, YLFL2 (JZS), YLINTEA, YLINTE4, LLOPENMP) 

  CLAOSN = ["AOSIP           ", "AOSIM           ", "AOSJP           ", "AOSJM           ", &
            "HO2IP           ", "HO2IM           ", "HO2JP           ", "HO2JM           "]
  IAOSHO = [JAOSIP, JAOSIM, JAOSJP, JAOSJM, JHO2IP, JHO2IM, JHO2JP, JHO2JM]
  
  DO JFLD = 1, 8
    YLFLD2 = YLFLDSAOS2%FIELD (TRIM (CLAOSN (JFLD)))
    CALL YLFLD2%RENAME ("SFX."//TRIM (CLAOSN (JFLD)))
    CALL INS2 (IAOSHO (JFLD), YLFLD2)
  ENDDO

  CALL YLINTE4%FINAL ()
ENDBLOCK

CALL COMPUTE_FRACTIONS

! Other; insert dummy fields for now

BLOCK

  CALL INS2 (JBATHY  , NEWFLD (YLFSSC2, "SFX.BATHY" , ZUNDEF))
  CALL INS2 (JRUNOFFB, NEWFLD (YLFSSC2, "SFX.RUNOFF", ZUNDEF))
  CALL INS2 (JWDRAIN , NEWFLD (YLFSSC2, "SFX.WDRAIN", ZUNDEF))

!$OMP WORKSHARE 
  WHERE (YLPT2 (JFRAC_SEA)%ZDATA > 0._JPRB)
    YLPT2 (JBATHY)%ZDATA = -300._JPRB
  ELSEWHERE
    YLPT2 (JBATHY)%ZDATA = ZUNDEF
  ENDWHERE
!$OMP END WORKSHARE

!$OMP WORKSHARE 
  WHERE (YLPT2 (JFRAC_NATURE)%ZDATA > 0._JPRB)
    YLPT2 (JRUNOFFB)%ZDATA = 0.5_JPRB
    YLPT2 (JWDRAIN)%ZDATA = 0.0_JPRB
  ELSEWHERE
    YLPT2 (JRUNOFFB)%ZDATA = ZUNDEF
    YLPT2 (JWDRAIN)%ZDATA = ZUNDEF
  ENDWHERE
!$OMP END WORKSHARE

ENDBLOCK

! Fix missing values: orography parameters, set to zero

BLOCK
  INTEGER (KIND=JPIM) :: IZS (17)
  IZS = &
& [ JZS   ,  JSSO_DIR, JSSO_SLOPE, JSSO_ANIS,  JSSO_STDEV, JAOSIP, &
&   JAOSIM,  JAOSJP  , JAOSJM    , JHO2IP   ,  JHO2IM    , JHO2JP, &
&   JHO2JM,  JMIN_ZS , JMAX_ZS   , JAVG_ZS  ,  JSIL_ZS   ]

  DO JFLD = 1, SIZE (IZS)
    IF (YLFL2 (IZS (JFLD))%IS_NULL ()) CYCLE
!$OMP WORKSHARE 
    WHERE (YLPT2 (IZS (JFLD))%ZDATA == ZUNDEF)
      YLPT2 (IZS (JFLD))%ZDATA = 0._JPRB
    ENDWHERE
!$OMP END WORKSHARE
  ENDDO

ENDBLOCK

CALL YDIO2%WRITE ('PGD2', YLFLDS2, YLFSSC2)

DO JFLD = 1, INFLD
  CALL YLFL2 (JFLD)%FINAL ()
ENDDO


CALL YLOROG1%FINAL ()
CALL YLCLAY1%FINAL ()
CALL YLSAND1%FINAL ()
CALL YLCOVR1%FINAL ()
CALL YLFLDS2%FINAL ()
CALL YLINTEA%FINAL ()
CALL YLGRID1%FINAL ()
CALL YLDIST1%FINAL ()
CALL YLDIST2%FINAL ()
CALL YLFSSC1%FINAL ()
CALL YLFSSC2%FINAL ()

CONTAINS

SUBROUTINE COMPUTE_FRACTIONS

TYPE (COVERS_t) :: YLCOVERS
LOGICAL, ALLOCATABLE :: LCOVER (:)

REAL (KIND=JPRB) :: ZAVGCOVR2 (INCOVR)
REAL (KIND=JPRB) :: ZMINCOVR2 (INCOVR)
REAL (KIND=JPRB) :: ZMAXCOVR2 (INCOVR)

! Create fractions fields

CALL INS2 (JFRAC_SEA   , NEWFLD (YLFSSC2, "SFX.FRAC_SEA"   , ZUNDEF))
CALL INS2 (JFRAC_NATURE, NEWFLD (YLFSSC2, "SFX.FRAC_NATURE", ZUNDEF))
CALL INS2 (JFRAC_TOWN  , NEWFLD (YLFSSC2, "SFX.FRAC_TOWN"  , ZUNDEF))
CALL INS2 (JFRAC_WATER , NEWFLD (YLFSSC2, "SFX.FRAC_WATER" , ZUNDEF))

CALL READCOVERS (YLCOVERS, 1, LGARDEN, LWATER_TO_NATURE, LTOWN_TO_ROCK)
CALL FIELDSTAT (YLFSSC2, YLFL2 (JCOVER+1:JCOVER+INCOVR), PMIN=ZMINCOVR2, PMAX=ZMAXCOVR2, PAVG=ZAVGCOVR2)

ALLOCATE (LCOVER (YLCOVERS%JPCOVER))
LCOVER = .FALSE.

LCOVER = ZAVGCOVR2 > 0._JPRB

CALL MAKEFRAC (YLPT2 (JFRAC_SEA   )%ZDATA, YLFL2 (JCOVER+1:JCOVER+INCOVR), YLCOVERS%XDATA_SEA   , LCOVER)
CALL MAKEFRAC (YLPT2 (JFRAC_NATURE)%ZDATA, YLFL2 (JCOVER+1:JCOVER+INCOVR), YLCOVERS%XDATA_NATURE, LCOVER)
CALL MAKEFRAC (YLPT2 (JFRAC_TOWN  )%ZDATA, YLFL2 (JCOVER+1:JCOVER+INCOVR), YLCOVERS%XDATA_TOWN  , LCOVER)
CALL MAKEFRAC (YLPT2 (JFRAC_WATER )%ZDATA, YLFL2 (JCOVER+1:JCOVER+INCOVR), YLCOVERS%XDATA_WATER , LCOVER)

END SUBROUTINE

SUBROUTINE MAKEFRAC (PFRAC, YDCOVER, PDATA, LDCOVER)

REAL (KIND=JPRB),   INTENT (OUT) :: PFRAC (:)
TYPE (ATLAS_FIELD), INTENT (IN)  :: YDCOVER (:)
REAL (KIND=JPRB),   INTENT (IN)  :: PDATA (:)
LOGICAL,            INTENT (IN)  :: LDCOVER (:)

TYPE (PTR) :: YLPTR (SIZE (YDCOVER))

INTEGER (KIND=JPIM) :: JLOC, JCOV, INCOV
REAL (KIND=JPRB) :: ZSUM

INCOV = SIZE (YDCOVER)

DO JCOV = 1, INCOV
  CALL YDCOVER (JCOV)%DATA (YLPTR (JCOV)%ZDATA)
ENDDO

! 1D computation

!$OMP PARALLEL DO PRIVATE (JLOC, ZSUM, JCOV) IF (LLOPENMP)
DO JLOC = 1, SIZE (PFRAC)
  PFRAC (JLOC) = 0._JPRB
  ZSUM = 0._JPRB
  DO JCOV = 1, INCOV
    IF (LDCOVER (JCOV)) THEN
      PFRAC (JLOC) = PFRAC (JLOC) + YLPTR (JCOV)%ZDATA (JLOC) * PDATA (JCOV)
      ZSUM         = ZSUM + YLPTR (JCOV)%ZDATA (JLOC)
    ENDIF
  ENDDO
  PFRAC (JLOC) = PFRAC (JLOC) / ZSUM
ENDDO
!$OMP END PARALLEL DO

END SUBROUTINE

FUNCTION RNS1 (CDNAME, PSCALE) RESULT (YLFL)

CHARACTER (LEN=*),   INTENT (IN) :: CDNAME
REAL (KIND=JPRB),    INTENT (IN), OPTIONAL :: PSCALE

TYPE (ATLAS_FIELDSET) :: YLFS
TYPE (ATLAS_FIELD) :: YLFL

! Read a field on source geometry, and insert it in the list #1

YLFS = YDIO1%READ (CDNAME, [CDNAME], YLFSSC1, PUNDEF=ZUNDEF, PSCALE=PSCALE)

YLFL = YLFS%FIELD (1)

CALL YLFS%FINAL ()

CALL YLFL%RETURN ()

END FUNCTION

SUBROUTINE INS2 (KRANK, YDFL)

INTEGER (KIND=JPIM), INTENT (IN) :: KRANK
TYPE (ATLAS_FIELD),  INTENT (IN) :: YDFL

! Insert a field in list #2 (target)

IF (.NOT. YLFL2 (KRANK)%IS_NULL ()) CALL ABORT ('FIELD ALREADY EXISTS')
IF (YDFL%SIZE () /= YLFSSC2%SIZE ()) CALL ABORT ('SIZE MISMATCH')
YLFL2 (KRANK) = YDFL
CALL YDFL%DATA (YLPT2 (KRANK)%ZDATA)
CALL YLFLDS2%ADD (YDFL)

END SUBROUTINE

FUNCTION CROSS (P1, P2) RESULT (P)

REAL (KIND=JPRB), INTENT (IN) :: P1 (3), P2 (3)
REAL (KIND=JPRB) :: P (3)


P (1) = P1 (2) * P2 (3) - P2 (2) * P1 (3)
P (2) = P1 (3) * P2 (1) - P2 (3) * P1 (1)
P (3) = P1 (1) * P2 (2) - P2 (1) * P1 (2)

END FUNCTION

REAL (KIND=JPRB) FUNCTION NORM (P) 

REAL (KIND=JPRB), INTENT (IN) :: P (3)

NORM = SQRT (SUM (P * P))

END FUNCTION

ELEMENTAL LOGICAL FUNCTION ISINF (P)

REAL (KIND=JPRB), INTENT (IN) :: P

ISINF = ABS (P) > HUGE (P)

END FUNCTION

SUBROUTINE ELLIPSE

REAL (KIND=JPRB), POINTER  :: ZLONLAT1 (:,:)
REAL (KIND=JPRB) :: ZLON1, ZLAT1, ZLON0, ZLAT0
REAL (KIND=JPRB) :: ZU0 (3), ZV0 (3), ZW0 (3)
REAL (KIND=JPRB) :: ZW1 (3), ZW1ZU0, ZW1ZV0, ZW1ZW0, ZWA (3), ZWB (3)
REAL (KIND=JPRB) :: ZAA, ZBB, ZA1, ZB1, ZHH
TYPE (ATLAS_FIELD) :: YLFLLONLAT1
INTEGER (KIND=JPIM) :: JLOC1

ZLON0 = PELLIPSE (1) * RPI / 180._JPRB
ZLAT0 = PELLIPSE (2) * RPI / 180._JPRB
ZAA   = PELLIPSE (3) * RPI / 180._JPRB
ZBB   = PELLIPSE (4) * RPI / 180._JPRB
ZHH   = PELLIPSE (5)

! Center of ellipse; this is also the local vector pointing up
ZW0 (1) = COS (ZLON0) * COS (ZLAT0)
ZW0 (2) = SIN (ZLON0) * COS (ZLAT0)
ZW0 (3) =               SIN (ZLAT0)

! Tangent U vector at center of ellipse; this is first axis of the ellipse
ZU0 = CROSS ([0._JPRB, 0._JPRB, 1._JPRB], ZW0)
ZU0 = ZU0 / NORM (ZU0)
! Tangent V vector at center of ellipse; second axis of the ellipse
ZV0 = CROSS (ZW0, ZU0)

YLFLLONLAT1 = YLFSSC1%XY () ! Input grid is lat/lon
CALL YLFLLONLAT1%DATA (ZLONLAT1)

DO JLOC1 = 1, SIZE (ZLONLAT1, 2)

  ZLON1 = ZLONLAT1 (1, JLOC1) * RPI / 180._JPRB
  ZLAT1 = ZLONLAT1 (2, JLOC1) * RPI / 180._JPRB

! Current point
  ZW1 (1) = COS (ZLON1) * COS (ZLAT1)
  ZW1 (2) = SIN (ZLON1) * COS (ZLAT1)
  ZW1 (3) =               SIN (ZLAT1)

! Projection of current point on U, V, W at center of ellipse
  ZW1ZU0 = DOT_PRODUCT (ZW1, ZU0)
  ZW1ZV0 = DOT_PRODUCT (ZW1, ZV0)
  ZW1ZW0 = DOT_PRODUCT (ZW1, ZW0)

! A is the projection of current point onto ellipse U axis
! B is the projection of current point onto ellipse V axis
  ZWA = ZW1ZU0 * ZU0 + ZW1ZW0 * ZW0; ZWA = ZWA / NORM (ZWA)
  ZWB = ZW1ZV0 * ZV0 + ZW1ZW0 * ZW0; ZWB = ZWB / NORM (ZWB)

  ZA1 = ACOS (DOT_PRODUCT (ZWA, ZW0))
  ZB1 = ACOS (DOT_PRODUCT (ZWB, ZW0))

  ZOROG1 (JLOC1) = ZHH / SQRT ((ZA1/ZAA)**2 + (ZB1/ZBB)**2)

ENDDO

ZCLAY1 = 0._JPRB
ZSAND1 = 0._JPRB
ZCOVR1 = 2._JPRB
CALL YLFLLONLAT1%FINAL ()
END SUBROUTINE


END

