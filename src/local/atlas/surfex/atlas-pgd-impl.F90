SUBROUTINE ATLAS_PGD_IMPL (YDIO1, YDIO2, YDGRID2, LDOPENMP, LDROTATE, PELLIPSE, LDENVELOPPE)

USE PARKIND1, ONLY : JPIM, JPRB
USE INTERPOLATIONA_MOD
USE INTERPOLATION4_MOD
USE GRADIENT_MOD
USE ATLAS_IO, ONLY : ATLAS_IO_t
USE FCKIT_MODULE, ONLY : FCKIT_MPI_COMM, FCKIT_EXCEPTION
USE ATLAS_MODULE  
USE ATLAS_HELPER
USE READCOVERS_MOD

#include "atlas-abort.h"

!

IMPLICIT NONE

! Constants

REAL (KIND=JPRB), PARAMETER :: RPI = 2.0_JPRB * ASIN (1.0_JPRB)
REAL (KIND=JPRB), PARAMETER :: RA = 6371229._JPRB
REAL (KIND=JPRB), PARAMETER :: ZUNDEF = HUGE (1._JPRB)
INTEGER (KIND=JPIM), PARAMETER :: INCOVR = 256_JPIM
LOGICAL, PARAMETER :: LGARDEN = .FALSE., LWATER_TO_NATURE = .FALSE., LTOWN_TO_ROCK = .TRUE.

! Objects defined on source geometry are labelled with "1"
! Objects defined on target geometry are labelled with "2"

! Objects for handling fileformats

CLASS (ATLAS_IO_t)                           :: YDIO1
CLASS (ATLAS_IO_t)                           :: YDIO2

! Grids

TYPE  (ATLAS_STRUCTUREDGRID)                 :: YLGRID1
CLASS (ATLAS_STRUCTUREDGRID)                 :: YDGRID2

LOGICAL, OPTIONAL                            :: LDOPENMP
LOGICAL, OPTIONAL                            :: LDROTATE
LOGICAL, OPTIONAL                            :: LDENVELOPPE
REAL (KIND=JPRB), OPTIONAL, POINTER          :: PELLIPSE (:)

#include "atlas-compute-covers.h"
#include "atlas-compute-sso.h"

! Grids of input files

TYPE (ATLAS_STRUCTUREDGRID)                  :: YLGRID_ZS
TYPE (ATLAS_STRUCTUREDGRID)                  :: YLGRID_SAND
TYPE (ATLAS_STRUCTUREDGRID)                  :: YLGRID_CLAY
TYPE (ATLAS_STRUCTUREDGRID)                  :: YLGRID_COVER

! Functionspaces

TYPE (ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS) :: YLFSSC1
TYPE (ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS) :: YLFSSC2

! Distributions (of grids on MPI tasks)

TYPE (ATLAS_GRIDDISTRIBUTION)                :: YLDIST1
TYPE (ATLAS_GRIDDISTRIBUTION)                :: YLDIST2

! Interpolation (source grid -> target grid)

TYPE (INTERPOLATIONA)                        :: YLINTEA

! Field sets

TYPE (ATLAS_FIELDSET)                        :: YLFLDS1  
TYPE (ATLAS_FIELDSET)                        :: YLFLDS2
TYPE (ATLAS_FIELDSET)                        :: YLFLDS2I

! Communicator

TYPE (FCKIT_MPI_COMM)                        :: YLCOMM

INTEGER (KIND=JPIM) :: I, JFLD
INTEGER (KIND=JPIM) :: NPROC, IRANK


! Atlas fields for source & target geometries

TYPE (ATLAS_FIELD), ALLOCATABLE :: YLFL1 (:), YLFL2 (:)

! Pointers to access data of source & target fields

TYPE (PTR),         ALLOCATABLE :: YLPT1 (:), YLPT2 (:)

INTEGER (KIND=JPIM) :: INFLD

! Indices of all fields

INTEGER (KIND=JPIM) :: JZS, JZS2, JZS_DXDX, JZS_DYDY, JZS_DXDY, JSAND, JCLAY
INTEGER (KIND=JPIM) :: JMIN_ZS, JMAX_ZS, JAVG_ZS, JSIL_ZS
INTEGER (KIND=JPIM) :: JSSO_DIR, JSSO_SLOPE, JSSO_ANIS, JSSO_STDEV
INTEGER (KIND=JPIM) :: JAOSIP, JAOSIM, JAOSJP, JAOSJM, JHO2IP, JHO2IM, JHO2JP, JHO2JM
INTEGER (KIND=JPIM) :: JFRAC_SEA, JFRAC_WATER, JFRAC_NATURE, JFRAC_TOWN
INTEGER (KIND=JPIM) :: JBATHY, JRUNOFFB, JWDRAIN, JCOVER


LOGICAL :: LLOPENMP, LLROTATE, LLELLIPSE, LLENVELOPPE

LLOPENMP = .TRUE.
IF (PRESENT (LDOPENMP)) LLOPENMP = LDOPENMP

LLROTATE = .TRUE.
IF (PRESENT (LDROTATE)) LLROTATE = LDROTATE

LLELLIPSE = .FALSE.
IF (PRESENT (PELLIPSE)) LLELLIPSE = ASSOCIATED (PELLIPSE) 

LLENVELOPPE = .TRUE.
IF (PRESENT (LDENVELOPPE)) LLENVELOPPE = LDENVELOPPE

! MPI info

YLCOMM = FCKIT_MPI_COMM ()
NPROC  = YLCOMM%SIZE ()
IRANK  = YLCOMM%RANK ()

! Create source grids & check compatibility

YLGRID_ZS    = YDIO1%GRID ("SFX.ZS"   )
YLGRID_CLAY  = YDIO1%GRID ("SFX.CLAY" )
YLGRID_SAND  = YDIO1%GRID ("SFX.SAND" )
YLGRID_COVER = YDIO1%GRID ("SFX.COVER")

IF (.NOT. (GRID_EQ (YLGRID_ZS, YLGRID_CLAY ))) CALL ABORT ("GEOMETRY MISMATCH")
IF (.NOT. (GRID_EQ (YLGRID_ZS, YLGRID_SAND ))) CALL ABORT ("GEOMETRY MISMATCH")
IF (.NOT. (GRID_EQ (YLGRID_ZS, YLGRID_COVER))) CALL ABORT ("GEOMETRY MISMATCH")

YLGRID1 = YLGRID_ZS

! Not needed anymore, finalize

CALL YLGRID_ZS   %FINAL ()
CALL YLGRID_CLAY %FINAL ()
CALL YLGRID_SAND %FINAL ()
CALL YLGRID_COVER%FINAL ()

! Create distributions for both source & target grids

CALL CREATE_DIST (YLGRID1, YLDIST1, .TRUE.)
CALL CREATE_DIST (YDGRID2, YLDIST2)

! Create functionspaces

BLOCK
  TYPE (ATLAS_CONFIG) :: YLCONF
  YLCONF = ATLAS_CONFIG ()
  CALL YLCONF%SET ("halo", 1)
  YLFSSC1 = ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS (YLGRID1, YLDIST1, YLCONF)
  YLFSSC2 = ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS (YDGRID2, YLDIST2, YLCONF)
  CALL YLCONF%FINAL ()
ENDBLOCK

! Define indices for all fields

INFLD = 0

#define ADDFLD(J) INFLD = INFLD + 1; J = INFLD

ADDFLD (JZS         ); ADDFLD (JZS2        ); ADDFLD (JZS_DXDX    ); ADDFLD (JZS_DYDY    );
ADDFLD (JZS_DXDY    ); ADDFLD (JSAND       ); ADDFLD (JCLAY       ); ADDFLD (JSSO_DIR    );
ADDFLD (JSSO_SLOPE  ); ADDFLD (JSSO_ANIS   ); ADDFLD (JSSO_STDEV  ); 
ADDFLD (JAOSIP      ); ADDFLD (JAOSIM      ); ADDFLD (JAOSJP      ); ADDFLD (JAOSJM      );
ADDFLD (JHO2IP      ); ADDFLD (JHO2IM      ); ADDFLD (JHO2JP      ); ADDFLD (JHO2JM      );
ADDFLD (JFRAC_SEA   ); ADDFLD (JFRAC_TOWN  ); ADDFLD (JFRAC_WATER ); ADDFLD (JFRAC_NATURE);
ADDFLD (JBATHY      ); ADDFLD (JRUNOFFB    ); ADDFLD (JWDRAIN     ); ADDFLD (JMIN_ZS     );
ADDFLD (JMAX_ZS     ); ADDFLD (JAVG_ZS     ); ADDFLD (JSIL_ZS     );


JCOVER = INFLD
INFLD = INFLD + INCOVR

#undef ADDFLD

! Allocate fields & pointers

ALLOCATE (YLFL1 (INFLD), YLFL2 (INFLD), YLPT1 (INFLD), YLPT2 (INFLD))

YLFLDS1 = ATLAS_FIELDSET ()
YLFLDS2 = ATLAS_FIELDSET ()

! Create interpolation object (source -> target)

YLINTEA = INTERPOLATIONA (YLDIST1, YLFSSC1, YLDIST2, YLFSSC2, LDOPENMP)

! Read input fields on source geometry

CALL RNS1 (JZS     , "SFX.ZS"   )
CALL RNS1 (JCLAY   , "SFX.CLAY", PSCALE=0.01_JPRB)
CALL RNS1 (JSAND   , "SFX.SAND", PSCALE=0.01_JPRB)
CALL RNS1 (JCOVER+1, "SFX.COVER")

IF (LLELLIPSE) CALL ELLIPSE ()


BLOCK
  TYPE (ATLAS_FIELDSET) :: YLFLDSCOVR2
  TYPE (ATLAS_FIELD) :: YLCOVR2
  INTEGER (KIND=JPIM) :: ICOV
  CHARACTER (LEN=:), ALLOCATABLE :: CLNAME

  YLFLDSCOVR2 = ATLAS_COMPUTE_COVERS (YLFSSC1, YLFSSC2, YLFL1 (JCOVER+1), YLINTEA, LLOPENMP) 

  DO ICOV = 1, YLFLDSCOVR2%SIZE ()
    YLCOVR2 = YLFLDSCOVR2%FIELD (ICOV)
    CLNAME = YLCOVR2%NAME ()
    CALL YLCOVR2%RENAME ("SFX."//CLNAME)
    CALL INS2 (JCOVER+ICOV, YLCOVR2)
    DEALLOCATE (CLNAME)
  ENDDO
  
  CALL YLFLDSCOVR2%FINAL ()
ENDBLOCK

! Set missing values of orography

!$OMP WORKSHARE
WHERE (YLPT1 (JCOVER+1)%ZDATA == 1._JPRB) ! Sea 
  YLPT1 (JZS)%ZDATA = ZUNDEF
ENDWHERE
!$OMP END WORKSHARE

! Interpolate fields using box averaging

YLFLDS2I = YLINTEA%INTERPOLATE (YLFLDS1)

! Insert interpolated fields in the list of fields of target geometry

CALL INS2 (JZS     , YLFLDS2I%FIELD ("SFX.ZS"      ))
CALL INS2 (JSAND   , YLFLDS2I%FIELD ("SFX.SAND"    ))
CALL INS2 (JCLAY   , YLFLDS2I%FIELD ("SFX.CLAY"    ))

CALL YLFLDS2I%FINAL ()

! Min, max, avg orography

BLOCK
 
  CALL INS2 (JAVG_ZS, NEWFLD (YLFSSC2, "SFX.AVG_ZS", ZUNDEF))
  CALL INS2 (JSIL_ZS, NEWFLD (YLFSSC2, "SFX.SIL_ZS", ZUNDEF))

  YLPT2 (JAVG_ZS)%ZDATA = YLPT2 (JZS)%ZDATA
  YLPT2 (JSIL_ZS)%ZDATA = YLPT2 (JZS)%ZDATA

! Use min and max reduction of interpolation object; default reduction is +

  CALL INS2 (JMIN_ZS, YLINTEA%INTERPOLATE (YLFL1 (JZS), YLINTEA%OPT_MIN ()))
  CALL INS2 (JMAX_ZS, YLINTEA%INTERPOLATE (YLFL1 (JZS), YLINTEA%OPT_MAX ()))

  CALL YLFL2 (JMIN_ZS)%RENAME ("SFX.MIN_ZS")
  CALL YLFL2 (JMAX_ZS)%RENAME ("SFX.MAX_ZS")

ENDBLOCK

BLOCK
  TYPE (ATLAS_FIELDSET) :: YLFLDS2SSO
  TYPE (ATLAS_FIELD)    :: YLFLD2

  YLFLDS2SSO = ATLAS_COMPUTE_SSO (YLFSSC1, YLFSSC2, YLFL1 (JZS), YLINTEA, LLOPENMP, LLROTATE) 

  YLFLD2 = YLFLDS2SSO%FIELD ("SSO_DIR"  ); CALL YLFLD2%RENAME ("SFX.SSO_DIR"  ); CALL INS2 (JSSO_DIR  , YLFLD2)
  YLFLD2 = YLFLDS2SSO%FIELD ("SSO_SLOPE"); CALL YLFLD2%RENAME ("SFX.SSO_SLOPE"); CALL INS2 (JSSO_SLOPE, YLFLD2)
  YLFLD2 = YLFLDS2SSO%FIELD ("SSO_ANIS" ); CALL YLFLD2%RENAME ("SFX.SSO_ANIS" ); CALL INS2 (JSSO_ANIS , YLFLD2)
  YLFLD2 = YLFLDS2SSO%FIELD ("SSO_STDEV"); CALL YLFLD2%RENAME ("SFX.SSO_STDEV"); CALL INS2 (JSSO_STDEV, YLFLD2)
ENDBLOCK

IF (LLENVELOPPE) THEN

!$OMP WORKSHARE 
  WHERE (YLPT2 (JZS)%ZDATA (:) /= ZUNDEF)
    YLPT2 (JZS)%ZDATA (:) = YLPT2 (JZS)%ZDATA (:) + YLPT2 (JSSO_STDEV)%ZDATA
  ENDWHERE
!$OMP END WORKSHARE

ENDIF


CALL COMPUTE_AOS

CALL COMPUTE_FRACTIONS

! Other; insert dummy fields for now

BLOCK

  CALL INS2 (JBATHY  , NEWFLD (YLFSSC2, "SFX.BATHY" , ZUNDEF))
  CALL INS2 (JRUNOFFB, NEWFLD (YLFSSC2, "SFX.RUNOFF", ZUNDEF))
  CALL INS2 (JWDRAIN , NEWFLD (YLFSSC2, "SFX.WDRAIN", ZUNDEF))

!$OMP WORKSHARE 
  WHERE (YLPT2 (JFRAC_SEA)%ZDATA > 0._JPRB)
    YLPT2 (JBATHY)%ZDATA = -300._JPRB
  ELSEWHERE
    YLPT2 (JBATHY)%ZDATA = ZUNDEF
  ENDWHERE
!$OMP END WORKSHARE

!$OMP WORKSHARE 
  WHERE (YLPT2 (JFRAC_NATURE)%ZDATA > 0._JPRB)
    YLPT2 (JRUNOFFB)%ZDATA = 0.5_JPRB
    YLPT2 (JWDRAIN)%ZDATA = 0.0_JPRB
  ELSEWHERE
    YLPT2 (JRUNOFFB)%ZDATA = ZUNDEF
    YLPT2 (JWDRAIN)%ZDATA = ZUNDEF
  ENDWHERE
!$OMP END WORKSHARE

ENDBLOCK

! Fix missing values: orography parameters, set to zero

BLOCK
  INTEGER (KIND=JPIM) :: IZS (17)
  IZS = &
& [ JZS   ,  JSSO_DIR, JSSO_SLOPE, JSSO_ANIS,  JSSO_STDEV, JAOSIP, &
&   JAOSIM,  JAOSJP  , JAOSJM    , JHO2IP   ,  JHO2IM    , JHO2JP, &
&   JHO2JM,  JMIN_ZS , JMAX_ZS   , JAVG_ZS  ,  JSIL_ZS   ]

  DO JFLD = 1, SIZE (IZS)
    IF (YLFL2 (IZS (JFLD))%IS_NULL ()) CYCLE
!$OMP WORKSHARE 
    WHERE (YLPT2 (IZS (JFLD))%ZDATA == ZUNDEF)
      YLPT2 (IZS (JFLD))%ZDATA = 0._JPRB
    ENDWHERE
!$OMP END WORKSHARE
  ENDDO

ENDBLOCK

CALL YDIO2%WRITE ('PGD2', YLFLDS2, YLFSSC2)

DO JFLD = 1, INFLD
  CALL YLFL1 (JFLD)%FINAL ()
  CALL YLFL2 (JFLD)%FINAL ()
ENDDO


CALL YLFLDS2%FINAL ()
CALL YLINTEA%FINAL ()
CALL YLGRID1%FINAL ()
CALL YLDIST1%FINAL ()
CALL YLDIST2%FINAL ()
CALL YLFSSC1%FINAL ()
CALL YLFSSC2%FINAL ()

CONTAINS

SUBROUTINE COMPUTE_AOS

TYPE (INTERPOLATION4) :: YLINTE4
TYPE (ATLAS_FIELD) :: YLOROG1INT4, YLOROG1MINT4
TYPE (ATLAS_FIELD) :: YLOROG1IP, YLOROG1IM, YLOROG1JP, YLOROG1JM
TYPE (ATLAS_FIELD) :: YLIP, YLIM, YLJP, YLJM
REAL (KIND=JPRB), POINTER, DIMENSION (:) :: ZOROG1INT4, ZOROG1MINT4
REAL (KIND=JPRB), POINTER, DIMENSION (:) :: ZOROG1IP, ZOROG1IM, ZOROG1JP, ZOROG1JM
REAL (KIND=JPRB), POINTER, DIMENSION (:) :: ZIP, ZIM, ZJP, ZJM
TYPE (ATLAS_FIELDSET) :: YLFLDSHALF, YLFLDSAOS1, YLFLDSAOS2
INTEGER (KIND=JPIM) :: IAOSHO2 (8)
INTEGER (KIND=JPIM) :: JFLD, JLOC1

IAOSHO2 = [JAOSIP, JAOSIM, JAOSJP, JAOSJM, JHO2IP, JHO2IM, JHO2JP, JHO2JM]

! Interpolate from target geometry to origin geometry (fine lat/lon)

YLINTE4 = INTERPOLATION4 (YLDIST2, YLFSSC2, YLDIST1, YLFSSC1)

YLOROG1MINT4 = NEWFLD (YLFSSC1, "SFX.ZS.MINT4", ZUNDEF)

YLOROG1INT4  = YLINTE4%INTERPOLATE (YLFL2 (JZS))

CALL YLOROG1INT4 %DATA (ZOROG1INT4 )
CALL YLOROG1MINT4%DATA (ZOROG1MINT4)

! Difference of original orography with interpolated orography

!$OMP PARALLEL DO PRIVATE (JLOC1) IF (LLOPENMP)
DO JLOC1 = 1, SIZE (YLPT1 (JZS)%ZDATA)
  IF (YLPT1 (JZS)%ZDATA (JLOC1) /= ZUNDEF) THEN
    ZOROG1MINT4 (JLOC1) = YLPT1 (JZS)%ZDATA (JLOC1) - ZOROG1INT4 (JLOC1)
  ELSE
    ZOROG1MINT4 (JLOC1) = ZUNDEF
  ENDIF
ENDDO
!$OMP END PARALLEL DO

YLFLDSHALF = ATLAS_FIELDSET ()
CALL YLFLDSHALF%ADD (YLOROG1MINT4)


! Compute half gradients

YLFLDSAOS1 = HALFDIFF (YLFSSC1, YLFLDSHALF)

YLOROG1IP = YLFLDSAOS1%FIELD ("SFX.ZS.MINT4.XP"); CALL YLOROG1IP%DATA (ZOROG1IP)
YLOROG1IM = YLFLDSAOS1%FIELD ("SFX.ZS.MINT4.XM"); CALL YLOROG1IM%DATA (ZOROG1IM)
YLOROG1JP = YLFLDSAOS1%FIELD ("SFX.ZS.MINT4.YP"); CALL YLOROG1JP%DATA (ZOROG1JP)
YLOROG1JM = YLFLDSAOS1%FIELD ("SFX.ZS.MINT4.YM"); CALL YLOROG1JM%DATA (ZOROG1JM)

YLIP = YLFLDSAOS1%FIELD ("XP"); CALL YLIP%DATA (ZIP)
YLIM = YLFLDSAOS1%FIELD ("XM"); CALL YLIM%DATA (ZIM)
YLJP = YLFLDSAOS1%FIELD ("YP"); CALL YLJP%DATA (ZJP)
YLJM = YLFLDSAOS1%FIELD ("YM"); CALL YLJM%DATA (ZJM)

CALL YLFLDSAOS1%FINAL ()

CALL INS1 (JAOSIP, NEWFLD (YLFSSC1, "SFX.AOSIP", ZUNDEF))
CALL INS1 (JAOSIM, NEWFLD (YLFSSC1, "SFX.AOSIM", ZUNDEF))
CALL INS1 (JAOSJP, NEWFLD (YLFSSC1, "SFX.AOSJP", ZUNDEF))
CALL INS1 (JAOSJM, NEWFLD (YLFSSC1, "SFX.AOSJM", ZUNDEF))

! Work with data provided by the half gradient operator

!$OMP PARALLEL DO PRIVATE (JLOC1) IF (LLOPENMP)
DO JLOC1 = 1, SIZE (YLPT1 (JZS)%ZDATA)
  IF (YLPT1 (JZS)%ZDATA (JLOC1) /= ZUNDEF) THEN
    YLPT1 (JAOSIP)%ZDATA (JLOC1) = + MAX (0._JPRB, ZOROG1IP (JLOC1) / (RA * ZIP (JLOC1)))
    YLPT1 (JAOSIM)%ZDATA (JLOC1) = - MIN (0._JPRB, ZOROG1IM (JLOC1) / (RA * ZIM (JLOC1)))
    YLPT1 (JAOSJP)%ZDATA (JLOC1) = + MAX (0._JPRB, ZOROG1JP (JLOC1) / (RA * ZJP (JLOC1)))
    YLPT1 (JAOSJM)%ZDATA (JLOC1) = - MIN (0._JPRB, ZOROG1JM (JLOC1) / (RA * ZJM (JLOC1)))
  ELSE
    YLPT1 (JAOSIP)%ZDATA (JLOC1) = ZUNDEF
    YLPT1 (JAOSIM)%ZDATA (JLOC1) = ZUNDEF
    YLPT1 (JAOSJP)%ZDATA (JLOC1) = ZUNDEF
    YLPT1 (JAOSJM)%ZDATA (JLOC1) = ZUNDEF
  ENDIF
ENDDO
!$OMP END PARALLEL DO

CALL INS1 (JHO2IP, NEWFLD (YLFSSC1, "SFX.HO2IP", ZUNDEF))
CALL INS1 (JHO2IM, NEWFLD (YLFSSC1, "SFX.HO2IM", ZUNDEF))
CALL INS1 (JHO2JP, NEWFLD (YLFSSC1, "SFX.HO2JP", ZUNDEF))
CALL INS1 (JHO2JM, NEWFLD (YLFSSC1, "SFX.HO2JM", ZUNDEF))

!$OMP PARALLEL DO PRIVATE (JLOC1) IF (LLOPENMP)
DO JLOC1 = 1, SIZE (YLPT1 (JZS)%ZDATA)
  IF ((YLPT1 (JZS)%ZDATA (JLOC1) /= ZUNDEF) .AND. (ZOROG1IP (JLOC1) > 0._JPRB)) THEN
    YLPT1 (JHO2IP)%ZDATA (JLOC1) = + ZOROG1IP (JLOC1) * 0.5_JPRB      
  ELSE
    YLPT1 (JHO2IP)%ZDATA (JLOC1) = ZUNDEF
  ENDIF
ENDDO
!$OMP END PARALLEL DO

!$OMP PARALLEL DO PRIVATE (JLOC1) IF (LLOPENMP)
DO JLOC1 = 1, SIZE (YLPT1 (JZS)%ZDATA)
  IF ((YLPT1 (JZS)%ZDATA (JLOC1) /= ZUNDEF) .AND. (ZOROG1IM (JLOC1) < 0._JPRB)) THEN
    YLPT1 (JHO2IM)%ZDATA (JLOC1) = - ZOROG1IM (JLOC1) * 0.5_JPRB       
  ELSE
    YLPT1 (JHO2IM)%ZDATA (JLOC1) = ZUNDEF
  ENDIF
ENDDO
!$OMP END PARALLEL DO
  
!$OMP PARALLEL DO PRIVATE (JLOC1) IF (LLOPENMP)
DO JLOC1 = 1, SIZE (YLPT1 (JZS)%ZDATA)
  IF ((YLPT1 (JZS)%ZDATA (JLOC1) /= ZUNDEF) .AND. (ZOROG1JP (JLOC1) > 0._JPRB)) THEN
    YLPT1 (JHO2JP)%ZDATA (JLOC1) = + ZOROG1JP (JLOC1) * 0.5_JPRB       
  ELSE
    YLPT1 (JHO2JP)%ZDATA (JLOC1) = ZUNDEF
  ENDIF
ENDDO
!$OMP END PARALLEL DO
  
!$OMP PARALLEL DO PRIVATE (JLOC1) IF (LLOPENMP)
DO JLOC1 = 1, SIZE (YLPT1 (JZS)%ZDATA)
  IF ((YLPT1 (JZS)%ZDATA (JLOC1) /= ZUNDEF) .AND. (ZOROG1JM (JLOC1) < 0._JPRB)) THEN
    YLPT1 (JHO2JM)%ZDATA (JLOC1) = - ZOROG1JM (JLOC1) * 0.5_JPRB      
  ELSE
    YLPT1 (JHO2JM)%ZDATA (JLOC1) = ZUNDEF
  ENDIF
ENDDO
!$OMP END PARALLEL DO

! Interpolate AOS & HO2 

YLFLDSAOS1 = ATLAS_FIELDSET ()

DO JFLD = 1, SIZE (IAOSHO2)
  CALL YLFLDSAOS1%ADD (YLFL1 (IAOSHO2 (JFLD)))
ENDDO

YLFLDSAOS2 = YLINTEA%INTERPOLATE (YLFLDSAOS1)

DO JFLD = 1, SIZE (IAOSHO2)
  CALL INS2 (IAOSHO2 (JFLD), YLFLDSAOS2%FIELD (JFLD))
!$OMP WORKSHARE 
  WHERE ((YLPT2 (JZS)%ZDATA /= ZUNDEF) .AND. (YLPT2 (IAOSHO2 (JFLD))%ZDATA == ZUNDEF))
    YLPT2 (IAOSHO2 (JFLD))%ZDATA = 0._JPRB
  ENDWHERE
!$OMP END WORKSHARE
ENDDO

CALL YLOROG1IP%FINAL ()
CALL YLOROG1IM%FINAL ()
CALL YLOROG1JP%FINAL ()
CALL YLOROG1JM%FINAL ()

CALL YLIP%FINAL ()
CALL YLIM%FINAL ()
CALL YLJP%FINAL ()
CALL YLJM%FINAL ()

CALL YLINTE4    %FINAL ()
CALL YLOROG1INT4%FINAL ()
CALL YLFLDSHALF %FINAL ()
CALL YLFLDSAOS1 %FINAL ()
CALL YLFLDSAOS2 %FINAL ()

END SUBROUTINE

SUBROUTINE COMPUTE_FRACTIONS

TYPE (COVERS_t) :: YLCOVERS
LOGICAL, ALLOCATABLE :: LCOVER (:)

REAL (KIND=JPRB) :: ZAVGCOVR2 (INCOVR)
REAL (KIND=JPRB) :: ZMINCOVR2 (INCOVR)
REAL (KIND=JPRB) :: ZMAXCOVR2 (INCOVR)

! Create fractions fields

CALL INS2 (JFRAC_SEA   , NEWFLD (YLFSSC2, "SFX.FRAC_SEA"   , ZUNDEF))
CALL INS2 (JFRAC_NATURE, NEWFLD (YLFSSC2, "SFX.FRAC_NATURE", ZUNDEF))
CALL INS2 (JFRAC_TOWN  , NEWFLD (YLFSSC2, "SFX.FRAC_TOWN"  , ZUNDEF))
CALL INS2 (JFRAC_WATER , NEWFLD (YLFSSC2, "SFX.FRAC_WATER" , ZUNDEF))

CALL READCOVERS (YLCOVERS, 1, LGARDEN, LWATER_TO_NATURE, LTOWN_TO_ROCK)
CALL FIELDSTAT (YLFSSC2, YLFL2 (JCOVER+1:JCOVER+INCOVR), PMIN=ZMINCOVR2, PMAX=ZMAXCOVR2, PAVG=ZAVGCOVR2)

ALLOCATE (LCOVER (YLCOVERS%JPCOVER))
LCOVER = .FALSE.

LCOVER = ZAVGCOVR2 > 0._JPRB

CALL MAKEFRAC (YLPT2 (JFRAC_SEA   )%ZDATA, YLFL2 (JCOVER+1:JCOVER+INCOVR), YLCOVERS%XDATA_SEA   , LCOVER)
CALL MAKEFRAC (YLPT2 (JFRAC_NATURE)%ZDATA, YLFL2 (JCOVER+1:JCOVER+INCOVR), YLCOVERS%XDATA_NATURE, LCOVER)
CALL MAKEFRAC (YLPT2 (JFRAC_TOWN  )%ZDATA, YLFL2 (JCOVER+1:JCOVER+INCOVR), YLCOVERS%XDATA_TOWN  , LCOVER)
CALL MAKEFRAC (YLPT2 (JFRAC_WATER )%ZDATA, YLFL2 (JCOVER+1:JCOVER+INCOVR), YLCOVERS%XDATA_WATER , LCOVER)

END SUBROUTINE

SUBROUTINE MAKEFRAC (PFRAC, YDCOVER, PDATA, LDCOVER)

REAL (KIND=JPRB),   INTENT (OUT) :: PFRAC (:)
TYPE (ATLAS_FIELD), INTENT (IN)  :: YDCOVER (:)
REAL (KIND=JPRB),   INTENT (IN)  :: PDATA (:)
LOGICAL,            INTENT (IN)  :: LDCOVER (:)

TYPE (PTR) :: YLPTR (SIZE (YDCOVER))

INTEGER (KIND=JPIM) :: JLOC, JCOV, INCOV
REAL (KIND=JPRB) :: ZSUM

INCOV = SIZE (YDCOVER)

DO JCOV = 1, INCOV
  CALL YDCOVER (JCOV)%DATA (YLPTR (JCOV)%ZDATA)
ENDDO

! 1D computation

!$OMP PARALLEL DO PRIVATE (JLOC, ZSUM, JCOV) IF (LLOPENMP)
DO JLOC = 1, SIZE (PFRAC)
  PFRAC (JLOC) = 0._JPRB
  ZSUM = 0._JPRB
  DO JCOV = 1, INCOV
    IF (LDCOVER (JCOV)) THEN
      PFRAC (JLOC) = PFRAC (JLOC) + YLPTR (JCOV)%ZDATA (JLOC) * PDATA (JCOV)
      ZSUM         = ZSUM + YLPTR (JCOV)%ZDATA (JLOC)
    ENDIF
  ENDDO
  PFRAC (JLOC) = PFRAC (JLOC) / ZSUM
ENDDO
!$OMP END PARALLEL DO

END SUBROUTINE

SUBROUTINE RNS1 (KRANK, CDNAME, PSCALE)

INTEGER (KIND=JPIM), INTENT (IN) :: KRANK
CHARACTER (LEN=*),   INTENT (IN) :: CDNAME
REAL (KIND=JPRB),    INTENT (IN), OPTIONAL :: PSCALE

TYPE (ATLAS_FIELDSET) :: YLFS

! Read a field on source geometry, and insert it in the list #1

YLFS = YDIO1%READ (CDNAME, [CDNAME], YLFSSC1, PUNDEF=ZUNDEF, PSCALE=PSCALE)
CALL INS1 (KRANK, YLFS%FIELD (1))
CALL YLFS%FINAL ()

END SUBROUTINE

SUBROUTINE INS1 (KRANK, YDFL)

INTEGER (KIND=JPIM), INTENT (IN) :: KRANK
TYPE (ATLAS_FIELD),  INTENT (IN) :: YDFL

! Insert a field in list#1 (origin)

IF (.NOT. YLFL1 (KRANK)%IS_NULL ()) CALL ABORT ('FIELD ALREADY EXISTS')
IF (YDFL%SIZE () /= YLFSSC1%SIZE ()) CALL ABORT ('SIZE MISMATCH')
YLFL1 (KRANK) = YDFL
CALL YDFL%DATA (YLPT1 (KRANK)%ZDATA)
CALL YLFLDS1%ADD (YDFL)

END SUBROUTINE

SUBROUTINE INS2 (KRANK, YDFL)

INTEGER (KIND=JPIM), INTENT (IN) :: KRANK
TYPE (ATLAS_FIELD),  INTENT (IN) :: YDFL

! Insert a field in list #2 (target)

IF (.NOT. YLFL2 (KRANK)%IS_NULL ()) CALL ABORT ('FIELD ALREADY EXISTS')
IF (YDFL%SIZE () /= YLFSSC2%SIZE ()) CALL ABORT ('SIZE MISMATCH')
YLFL2 (KRANK) = YDFL
CALL YDFL%DATA (YLPT2 (KRANK)%ZDATA)
CALL YLFLDS2%ADD (YDFL)

END SUBROUTINE

FUNCTION CROSS (P1, P2) RESULT (P)

REAL (KIND=JPRB), INTENT (IN) :: P1 (3), P2 (3)
REAL (KIND=JPRB) :: P (3)


P (1) = P1 (2) * P2 (3) - P2 (2) * P1 (3)
P (2) = P1 (3) * P2 (1) - P2 (3) * P1 (1)
P (3) = P1 (1) * P2 (2) - P2 (1) * P1 (2)

END FUNCTION

REAL (KIND=JPRB) FUNCTION NORM (P) 

REAL (KIND=JPRB), INTENT (IN) :: P (3)

NORM = SQRT (SUM (P * P))

END FUNCTION

ELEMENTAL LOGICAL FUNCTION ISINF (P)

REAL (KIND=JPRB), INTENT (IN) :: P

ISINF = ABS (P) > HUGE (P)

END FUNCTION

SUBROUTINE ELLIPSE

REAL (KIND=JPRB), POINTER  :: ZLONLAT1 (:,:)
REAL (KIND=JPRB) :: ZLON1, ZLAT1, ZLON0, ZLAT0
REAL (KIND=JPRB) :: ZU0 (3), ZV0 (3), ZW0 (3)
REAL (KIND=JPRB) :: ZW1 (3), ZW1ZU0, ZW1ZV0, ZW1ZW0, ZWA (3), ZWB (3)
REAL (KIND=JPRB) :: ZAA, ZBB, ZA1, ZB1, ZHH
TYPE (ATLAS_FIELD) :: YLFLLONLAT1
INTEGER (KIND=JPIM) :: JLOC1

ZLON0 = PELLIPSE (1) * RPI / 180._JPRB
ZLAT0 = PELLIPSE (2) * RPI / 180._JPRB
ZAA   = PELLIPSE (3) * RPI / 180._JPRB
ZBB   = PELLIPSE (4) * RPI / 180._JPRB
ZHH   = PELLIPSE (5)

! Center of ellipse; this is also the local vector pointing up
ZW0 (1) = COS (ZLON0) * COS (ZLAT0)
ZW0 (2) = SIN (ZLON0) * COS (ZLAT0)
ZW0 (3) =               SIN (ZLAT0)

! Tangent U vector at center of ellipse; this is first axis of the ellipse
ZU0 = CROSS ([0._JPRB, 0._JPRB, 1._JPRB], ZW0)
ZU0 = ZU0 / NORM (ZU0)
! Tangent V vector at center of ellipse; second axis of the ellipse
ZV0 = CROSS (ZW0, ZU0)

YLFLLONLAT1 = YLFSSC1%XY () ! Input grid is lat/lon
CALL YLFLLONLAT1%DATA (ZLONLAT1)

DO JLOC1 = 1, SIZE (ZLONLAT1, 2)

  ZLON1 = ZLONLAT1 (1, JLOC1) * RPI / 180._JPRB
  ZLAT1 = ZLONLAT1 (2, JLOC1) * RPI / 180._JPRB

! Current point
  ZW1 (1) = COS (ZLON1) * COS (ZLAT1)
  ZW1 (2) = SIN (ZLON1) * COS (ZLAT1)
  ZW1 (3) =               SIN (ZLAT1)

! Projection of current point on U, V, W at center of ellipse
  ZW1ZU0 = DOT_PRODUCT (ZW1, ZU0)
  ZW1ZV0 = DOT_PRODUCT (ZW1, ZV0)
  ZW1ZW0 = DOT_PRODUCT (ZW1, ZW0)

! A is the projection of current point onto ellipse U axis
! B is the projection of current point onto ellipse V axis
  ZWA = ZW1ZU0 * ZU0 + ZW1ZW0 * ZW0; ZWA = ZWA / NORM (ZWA)
  ZWB = ZW1ZV0 * ZV0 + ZW1ZW0 * ZW0; ZWB = ZWB / NORM (ZWB)

  ZA1 = ACOS (DOT_PRODUCT (ZWA, ZW0))
  ZB1 = ACOS (DOT_PRODUCT (ZWB, ZW0))

  YLPT1 (JZS)%ZDATA (JLOC1) = ZHH / SQRT ((ZA1/ZAA)**2 + (ZB1/ZBB)**2)

ENDDO

YLPT1 (JCLAY)%ZDATA = 0._JPRB
YLPT1 (JSAND)%ZDATA = 0._JPRB
YLPT1 (JCOVER+1)%ZDATA = 2._JPRB
CALL YLFLLONLAT1%FINAL ()
END SUBROUTINE


END

