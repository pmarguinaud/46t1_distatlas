SUBROUTINE ATLAS_PGD_IMPL (YDIO1, YDIO2, YDGRID2, LDOPENMP, LDROTATE, PELLIPSE)

USE PARKIND1, ONLY : JPIM, JPRB
USE INTERPOLATIONA_MOD
USE INTERPOLATION4_MOD
USE GRADIENT_MOD
USE ATLAS_IO, ONLY : ATLAS_IO_t
USE FCKIT_MODULE, ONLY : FCKIT_MPI_COMM, FCKIT_EXCEPTION
USE ATLAS_MODULE  
USE ATLAS_HELPER
USE READCOVERS_MOD

#include "atlas-abort.h"

!

IMPLICIT NONE

! Constants

REAL (KIND=JPRB), PARAMETER :: RPI = 2.0_JPRB * ASIN (1.0_JPRB)
REAL (KIND=JPRB), PARAMETER :: RA = 6371229._JPRB
REAL (KIND=JPRB), PARAMETER :: ZUNDEF = HUGE (1._JPRB)
INTEGER (KIND=JPIM), PARAMETER :: INCOVR = 256_JPIM
LOGICAL, PARAMETER :: LGARDEN = .FALSE., LWATER_TO_NATURE = .FALSE., LTOWN_TO_ROCK = .TRUE.

! Objects defined on source geometry are labelled with "1"
! Objects defined on target geometry are labelled with "2"

! Objects for handling fileformats

CLASS (ATLAS_IO_t)                           :: YDIO1
CLASS (ATLAS_IO_t)                           :: YDIO2

! Grids

TYPE  (ATLAS_STRUCTUREDGRID)                 :: YLGRID1
CLASS (ATLAS_STRUCTUREDGRID)                 :: YDGRID2

LOGICAL, OPTIONAL                            :: LDOPENMP
LOGICAL, OPTIONAL                            :: LDROTATE
REAL (KIND=JPRB), OPTIONAL, POINTER          :: PELLIPSE (:)

! Grids of input files

TYPE (ATLAS_STRUCTUREDGRID)                  :: YLGRID_ZS
TYPE (ATLAS_STRUCTUREDGRID)                  :: YLGRID_SAND
TYPE (ATLAS_STRUCTUREDGRID)                  :: YLGRID_CLAY
TYPE (ATLAS_STRUCTUREDGRID)                  :: YLGRID_COVER

! Functionspaces

TYPE (ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS) :: YLFSSC1
TYPE (ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS) :: YLFSSC2

! Distributions (of grids on MPI tasks)

TYPE (ATLAS_GRIDDISTRIBUTION)                :: YLDIST1
TYPE (ATLAS_GRIDDISTRIBUTION)                :: YLDIST2

! Interpolation (source grid -> target grid)

TYPE (INTERPOLATIONA)                        :: YLINTEA

! Field sets

TYPE (ATLAS_FIELDSET)                        :: YLFLDS1  
TYPE (ATLAS_FIELDSET)                        :: YLFLDS2
TYPE (ATLAS_FIELDSET)                        :: YLFLDS2I

! Communicator

TYPE (FCKIT_MPI_COMM)                        :: YLCOMM

INTEGER (KIND=JPIM) :: I, JFLD
INTEGER (KIND=JPIM) :: NPROC, IRANK


! Atlas fields for source & target geometries

TYPE (ATLAS_FIELD), ALLOCATABLE :: YLFL1 (:), YLFL2 (:)

! Pointers to access data of source & target fields

TYPE (PTR),         ALLOCATABLE :: YLPT1 (:), YLPT2 (:)

INTEGER (KIND=JPIM) :: INFLD

! Indices of all fields

INTEGER (KIND=JPIM) :: JZS, JZS2, JZS_DXDX, JZS_DYDY, JZS_DXDY, JSAND, JCLAY
INTEGER (KIND=JPIM) :: JMIN_ZS, JMAX_ZS, JAVG_ZS, JSIL_ZS
INTEGER (KIND=JPIM) :: JSSO_DIR, JSSO_SLOPE, JSSO_ANIS, JSSO_STDEV
INTEGER (KIND=JPIM) :: JAOSIP, JAOSIM, JAOSJP, JAOSJM, JHO2IP, JHO2IM, JHO2JP, JHO2JM
INTEGER (KIND=JPIM) :: JFRAC_SEA, JFRAC_WATER, JFRAC_NATURE, JFRAC_TOWN
INTEGER (KIND=JPIM) :: JBATHY, JRUNOFFB, JWDRAIN, JCOVER


LOGICAL :: LLOPENMP, LLROTATE, LLELLIPSE

LLOPENMP = .TRUE.
IF (PRESENT (LDOPENMP)) LLOPENMP = LDOPENMP

LLROTATE = .TRUE.
IF (PRESENT (LDROTATE)) LLROTATE = LDROTATE

LLELLIPSE = .FALSE.
IF (PRESENT (PELLIPSE)) LLELLIPSE = ASSOCIATED (PELLIPSE) 

! MPI info

YLCOMM = FCKIT_MPI_COMM ()
NPROC  = YLCOMM%SIZE ()
IRANK  = YLCOMM%RANK ()

! Create source grids & check compatibility

YLGRID_ZS    = YDIO1%GRID ("SFX.ZS"   )
YLGRID_CLAY  = YDIO1%GRID ("SFX.CLAY" )
YLGRID_SAND  = YDIO1%GRID ("SFX.SAND" )
YLGRID_COVER = YDIO1%GRID ("SFX.COVER")

IF (.NOT. (GRID_EQ (YLGRID_ZS, YLGRID_CLAY ))) CALL ABORT ("GEOMETRY MISMATCH")
IF (.NOT. (GRID_EQ (YLGRID_ZS, YLGRID_SAND ))) CALL ABORT ("GEOMETRY MISMATCH")
IF (.NOT. (GRID_EQ (YLGRID_ZS, YLGRID_COVER))) CALL ABORT ("GEOMETRY MISMATCH")

YLGRID1 = YLGRID_ZS

! Not needed anymore, finalize

CALL YLGRID_ZS   %FINAL ()
CALL YLGRID_CLAY %FINAL ()
CALL YLGRID_SAND %FINAL ()
CALL YLGRID_COVER%FINAL ()

! Create distributions for both source & target grids

CALL CREATE_DIST (YLGRID1, YLDIST1, .TRUE.)
CALL CREATE_DIST (YDGRID2, YLDIST2)

! Create functionspaces

BLOCK
  TYPE (ATLAS_CONFIG) :: YLCONF
  YLCONF = ATLAS_CONFIG ()
  CALL YLCONF%SET ("halo", 1)
  YLFSSC1 = ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS (YLGRID1, YLDIST1, YLCONF)
  YLFSSC2 = ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS (YDGRID2, YLDIST2, YLCONF)
  CALL YLCONF%FINAL ()
ENDBLOCK


! Define indices for all fields

INFLD = 0

#define ADDFLD(J) INFLD = INFLD + 1; J = INFLD

ADDFLD (JZS         ); ADDFLD (JZS2        ); ADDFLD (JZS_DXDX    ); ADDFLD (JZS_DYDY    );
ADDFLD (JZS_DXDY    ); ADDFLD (JSAND       ); ADDFLD (JCLAY       ); ADDFLD (JSSO_DIR    );
ADDFLD (JSSO_SLOPE  ); ADDFLD (JSSO_ANIS   ); ADDFLD (JSSO_STDEV  ); 
ADDFLD (JAOSIP      ); ADDFLD (JAOSIM      ); ADDFLD (JAOSJP      ); ADDFLD (JAOSJM      );
ADDFLD (JHO2IP      ); ADDFLD (JHO2IM      ); ADDFLD (JHO2JP      ); ADDFLD (JHO2JM      );
ADDFLD (JFRAC_SEA   ); ADDFLD (JFRAC_TOWN  ); ADDFLD (JFRAC_WATER ); ADDFLD (JFRAC_NATURE);
ADDFLD (JBATHY      ); ADDFLD (JRUNOFFB    ); ADDFLD (JWDRAIN     ); ADDFLD (JMIN_ZS     );
ADDFLD (JMAX_ZS     ); ADDFLD (JAVG_ZS     ); ADDFLD (JSIL_ZS     );


JCOVER = INFLD
INFLD = INFLD + INCOVR

#undef ADDFLD

! Allocate fields & pointers

ALLOCATE (YLFL1 (INFLD), YLFL2 (INFLD), YLPT1 (INFLD), YLPT2 (INFLD))

YLFLDS1 = ATLAS_FIELDSET ()
YLFLDS2 = ATLAS_FIELDSET ()

! Create interpolation object (source -> target)

YLINTEA = INTERPOLATIONA (YLDIST1, YLFSSC1, YLDIST2, YLFSSC2, LDOPENMP)

! Read input fields on source geometry

CALL RNS1 (JZS     , "SFX.ZS"   )
CALL RNS1 (JCLAY   , "SFX.CLAY", PSCALE=0.01_JPRB)
CALL RNS1 (JSAND   , "SFX.SAND", PSCALE=0.01_JPRB)
CALL RNS1 (JCOVER+1, "SFX.COVER")

IF (LLELLIPSE) THEN
  BLOCK
    REAL (KIND=JPRB), POINTER  :: ZLONLAT1 (:,:)
    REAL (KIND=JPRB) :: ZLON1, ZLAT1, ZLON0, ZLAT0
    REAL (KIND=JPRB) :: ZU0 (3), ZV0 (3), ZW0 (3)
    REAL (KIND=JPRB) :: ZW1 (3), ZW1ZU0, ZW1ZV0, ZW1ZW0, ZWA (3), ZWB (3)
    REAL (KIND=JPRB) :: ZAA, ZBB, ZA1, ZB1, ZHH
    TYPE (ATLAS_FIELD) :: YLFLLONLAT1
    INTEGER (KIND=JPIM) :: JLOC1

    ZLON0 = PELLIPSE (1) * RPI / 180._JPRB
    ZLAT0 = PELLIPSE (2) * RPI / 180._JPRB
    ZAA   = PELLIPSE (3) * RPI / 180._JPRB
    ZBB   = PELLIPSE (4) * RPI / 180._JPRB
    ZHH   = PELLIPSE (5)

! Center of ellipse; this is also the local vector pointing up
    ZW0 (1) = COS (ZLON0) * COS (ZLAT0)
    ZW0 (2) = SIN (ZLON0) * COS (ZLAT0)
    ZW0 (3) =               SIN (ZLAT0)

! Tangent U vector at center of ellipse; this is first axis of the ellipse
    ZU0 = CROSS ([0._JPRB, 0._JPRB, 1._JPRB], ZW0)
    ZU0 = ZU0 / NORM (ZU0)
! Tangent V vector at center of ellipse; second axis of the ellipse
    ZV0 = CROSS (ZW0, ZU0)

    YLFLLONLAT1 = YLFSSC1%XY () ! Input grid is lat/lon
    CALL YLFLLONLAT1%DATA (ZLONLAT1)

    DO JLOC1 = 1, SIZE (ZLONLAT1, 2)

      ZLON1 = ZLONLAT1 (1, JLOC1) * RPI / 180._JPRB
      ZLAT1 = ZLONLAT1 (2, JLOC1) * RPI / 180._JPRB

! Current point
      ZW1 (1) = COS (ZLON1) * COS (ZLAT1)
      ZW1 (2) = SIN (ZLON1) * COS (ZLAT1)
      ZW1 (3) =               SIN (ZLAT1)

! Projection of current point on U, V, W at center of ellipse
      ZW1ZU0 = DOT_PRODUCT (ZW1, ZU0)
      ZW1ZV0 = DOT_PRODUCT (ZW1, ZV0)
      ZW1ZW0 = DOT_PRODUCT (ZW1, ZW0)

! A is the projection of current point onto ellipse U axis
! B is the projection of current point onto ellipse V axis
      ZWA = ZW1ZU0 * ZU0 + ZW1ZW0 * ZW0; ZWA = ZWA / NORM (ZWA)
      ZWB = ZW1ZV0 * ZV0 + ZW1ZW0 * ZW0; ZWB = ZWB / NORM (ZWB)

      ZA1 = ACOS (DOT_PRODUCT (ZWA, ZW0))
      ZB1 = ACOS (DOT_PRODUCT (ZWB, ZW0))

      YLPT1 (JZS)%ZDATA (JLOC1) = ZHH / SQRT ((ZA1/ZAA)**2 + (ZB1/ZBB)**2)

    ENDDO

    YLPT1 (JCLAY)%ZDATA = 0._JPRB
    YLPT1 (JSAND)%ZDATA = 0._JPRB
    YLPT1 (JCOVER+1)%ZDATA = 2._JPRB
    CALL YLFLLONLAT1%FINAL ()
  ENDBLOCK
ENDIF

! Create covers

BLOCK
  TYPE (ATLAS_FIELD) :: YLCOVR2E
  INTEGER (KIND=JPIM), ALLOCATABLE :: IOFF (:), ICNT (:)
  REAL (KIND=JPRB), POINTER :: ZCOVR2E (:)
  INTEGER (KIND=JPIM) :: JLOC2, ICOV, II
  CHARACTER (LEN=16) :: CLNOMA

! Get shuffle metadata : for each point of the target geometry
! we get an offset and a length which allow us to access 
! reshuffled data of source geometry

  IOFF = YLINTEA%GETOFF ()
  ICNT = YLINTEA%GETCNT ()

! Reshuffle covers from source geometry to target geometry

  YLCOVR2E = YLINTEA%SHUFFLE (YLFL1 (JCOVER+1))

  CALL YLCOVR2E%DATA (ZCOVR2E)

! Create cover fields on target geometry

  DO ICOV = 1, INCOVR
    WRITE (CLNOMA, '("SFX.COVER",I3.3)') ICOV
    CALL INS2 (JCOVER+ICOV, NEWFLD (YLFSSC2, TRIM (CLNOMA)))
    YLPT2 (JCOVER+ICOV)%ZDATA = 0._JPRB
  ENDDO

! Compute cover fields on target geometry

  DO JLOC2 = 1, YLFSSC2%SIZE_OWNED ()
    DO II = IOFF (JLOC2)+1, IOFF (JLOC2)+ICNT (JLOC2)
      ICOV = INT (ZCOVR2E (II))
      IF ((ICOV < 1) .OR. (ICOV > INCOVR)) THEN
        CALL ABORT ('ATLAS_PGD: UNEXPECTED COVER VALUE')
      ENDIF
      YLPT2 (JCOVER+ICOV)%ZDATA (JLOC2) = YLPT2 (JCOVER+ICOV)%ZDATA (JLOC2) + 1._JPRB
    ENDDO
    DO ICOV = 1, INCOVR
      YLPT2 (JCOVER+ICOV)%ZDATA (JLOC2) = YLPT2 (JCOVER+ICOV)%ZDATA (JLOC2) / REAL (ICNT (JLOC2), JPRB)
    ENDDO
  ENDDO

! Dispose of reshuffled data

  CALL YLCOVR2E%FINAL ()
ENDBLOCK


! Set missing values of orography

!$OMP WORKSHARE
WHERE (YLPT1 (JCOVER+1)%ZDATA == 1._JPRB) ! Sea 
  YLPT1 (JZS)%ZDATA = ZUNDEF
ENDWHERE
!$OMP END WORKSHARE

! Compute orography gradient

BLOCK
  TYPE (ATLAS_FIELDSET) :: YLFSGR1
  TYPE (ATLAS_FIELD) :: YLOROG1DX, YLOROG1DY
  REAL (KIND=JPRB), POINTER :: ZOROG1DX (:), ZOROG1DY (:)
  INTEGER (KIND=JPIM) :: JLOC1

  YLFSGR1 = GRADIENT (YLFSSC1, YLFL1 (JZS))

  YLOROG1DX = YLFSGR1%FIELD ("SFX.ZS.DX")
  YLOROG1DY = YLFSGR1%FIELD ("SFX.ZS.DY")

  CALL YLOROG1DX%DATA (ZOROG1DX)
  CALL YLOROG1DY%DATA (ZOROG1DY)

! Rotate gradient on target projection

  IF (LLROTATE) &
  CALL ROTATE (YLFSSC1, YDGRID2, YLFSGR1)

  CALL INS1 (JZS2    , NEWFLD (YLFSSC1, "SFX.ZS_2"    , ZUNDEF))
  CALL INS1 (JZS_DXDX, NEWFLD (YLFSSC1, "SFX.ZS.DX_DX", ZUNDEF))
  CALL INS1 (JZS_DYDY, NEWFLD (YLFSSC1, "SFX.ZS.DY_DY", ZUNDEF))
  CALL INS1 (JZS_DXDY, NEWFLD (YLFSSC1, "SFX.ZS.DX_DY", ZUNDEF))

! Gradient wrt meters on Earth

!$OMP WORKSHARE 
  WHERE (ZOROG1DX /= ZUNDEF) ZOROG1DX = ZOROG1DX / RA
!$OMP END WORKSHARE

!$OMP WORKSHARE 
  WHERE (ZOROG1DY /= ZUNDEF) ZOROG1DY = ZOROG1DY / RA
!$OMP END WORKSHARE

! Compute tensor fields

! Does not work with OpenMP yet

!#OMP PARALLEL DO PRIVATE (JLOC1) IF (LLOPENMP)
  DO JLOC1 = 1, SIZE (YLPT1 (JZS)%ZDATA)
    IF (YLPT1 (JZS)%ZDATA (JLOC1) /= ZUNDEF) THEN
      YLPT1 (JZS_DXDX)%ZDATA (JLOC1) = ZOROG1DX (JLOC1) * ZOROG1DX (JLOC1)
      YLPT1 (JZS_DYDY)%ZDATA (JLOC1) = ZOROG1DY (JLOC1) * ZOROG1DY (JLOC1)
      YLPT1 (JZS_DXDY)%ZDATA (JLOC1) = ZOROG1DX (JLOC1) * ZOROG1DY (JLOC1)
      YLPT1 (JZS2    )%ZDATA (JLOC1) = YLPT1 (JZS)%ZDATA (JLOC1) * YLPT1 (JZS)%ZDATA (JLOC1)
    ELSE
      YLPT1 (JZS_DXDX)%ZDATA (JLOC1) = ZUNDEF
      YLPT1 (JZS_DYDY)%ZDATA (JLOC1) = ZUNDEF
      YLPT1 (JZS_DXDY)%ZDATA (JLOC1) = ZUNDEF
      YLPT1 (JZS2    )%ZDATA (JLOC1) = ZUNDEF
    ENDIF
  ENDDO
!#OMP END PARALLEL DO

  CALL YLOROG1DX   %FINAL ()
  CALL YLOROG1DY   %FINAL ()

ENDBLOCK

! Interpolate fields using box averaging

YLFLDS2I = YLINTEA%INTERPOLATE (YLFLDS1)

! Insert interpolated fields in the list of fields of target geometry

CALL INS2 (JZS     , YLFLDS2I%FIELD ("SFX.ZS"      ))
CALL INS2 (JSAND   , YLFLDS2I%FIELD ("SFX.SAND"    ))
CALL INS2 (JCLAY   , YLFLDS2I%FIELD ("SFX.CLAY"    ))
CALL INS2 (JZS2    , YLFLDS2I%FIELD ("SFX.ZS_2"    ))
CALL INS2 (JZS_DXDX, YLFLDS2I%FIELD ("SFX.ZS.DX_DX"))
CALL INS2 (JZS_DYDY, YLFLDS2I%FIELD ("SFX.ZS.DY_DY"))
CALL INS2 (JZS_DXDY, YLFLDS2I%FIELD ("SFX.ZS.DX_DY"))

CALL YLFLDS2I%FINAL ()

! Min, max, avg orography

BLOCK
 
  CALL INS2 (JAVG_ZS, NEWFLD (YLFSSC2, "SFX.AVG_ZS", ZUNDEF))
  CALL INS2 (JSIL_ZS, NEWFLD (YLFSSC2, "SFX.SIL_ZS", ZUNDEF))

  YLPT2 (JAVG_ZS)%ZDATA = YLPT2 (JZS)%ZDATA
  YLPT2 (JSIL_ZS)%ZDATA = YLPT2 (JZS)%ZDATA

! Use min and max reduction of interpolation object; default reduction is +

  CALL INS2 (JMIN_ZS, YLINTEA%INTERPOLATE (YLFL1 (JZS), YLINTEA%OPT_MIN ()))
  CALL INS2 (JMAX_ZS, YLINTEA%INTERPOLATE (YLFL1 (JZS), YLINTEA%OPT_MAX ()))

  CALL YLFL2 (JMIN_ZS)%RENAME ("SFX.MIN_ZS")
  CALL YLFL2 (JMAX_ZS)%RENAME ("SFX.MAX_ZS")

ENDBLOCK

CALL COMPUTE_SSO

CALL COMPUTE_AOS

CALL COMPUTE_FRACTIONS

! Other; insert dummy fields for now

BLOCK

  CALL INS2 (JBATHY  , NEWFLD (YLFSSC2, "SFX.BATHY" , ZUNDEF))
  CALL INS2 (JRUNOFFB, NEWFLD (YLFSSC2, "SFX.RUNOFF", ZUNDEF))
  CALL INS2 (JWDRAIN , NEWFLD (YLFSSC2, "SFX.WDRAIN", ZUNDEF))

!$OMP WORKSHARE 
  WHERE (YLPT2 (JFRAC_SEA)%ZDATA > 0._JPRB)
    YLPT2 (JBATHY)%ZDATA = -300._JPRB
  ELSEWHERE
    YLPT2 (JBATHY)%ZDATA = ZUNDEF
  ENDWHERE
!$OMP END WORKSHARE

!$OMP WORKSHARE 
  WHERE (YLPT2 (JFRAC_NATURE)%ZDATA > 0._JPRB)
    YLPT2 (JRUNOFFB)%ZDATA = 0.5_JPRB
    YLPT2 (JWDRAIN)%ZDATA = 0.0_JPRB
  ELSEWHERE
    YLPT2 (JRUNOFFB)%ZDATA = ZUNDEF
    YLPT2 (JWDRAIN)%ZDATA = ZUNDEF
  ENDWHERE
!$OMP END WORKSHARE

ENDBLOCK

! Fix missing values: orography parameters, set to zero

BLOCK
  INTEGER (KIND=JPIM) :: IZS (17)
  IZS = &
& [ JZS   ,  JSSO_DIR, JSSO_SLOPE, JSSO_ANIS,  JSSO_STDEV, JAOSIP, &
&   JAOSIM,  JAOSJP  , JAOSJM    , JHO2IP   ,  JHO2IM    , JHO2JP, &
&   JHO2JM,  JMIN_ZS , JMAX_ZS   , JAVG_ZS  ,  JSIL_ZS   ]

  DO JFLD = 1, SIZE (IZS)
    IF (YLFL2 (IZS (JFLD))%IS_NULL ()) CYCLE
!$OMP WORKSHARE 
    WHERE (YLPT2 (IZS (JFLD))%ZDATA == ZUNDEF)
      YLPT2 (IZS (JFLD))%ZDATA = 0._JPRB
    ENDWHERE
!$OMP END WORKSHARE
  ENDDO

ENDBLOCK

CALL YDIO2%WRITE ('PGD2', YLFLDS2, YLFSSC2)

DO JFLD = 1, INFLD
  CALL YLFL1 (JFLD)%FINAL ()
  CALL YLFL2 (JFLD)%FINAL ()
ENDDO


CALL YLFLDS2%FINAL ()
CALL YLINTEA%FINAL ()
CALL YLGRID1%FINAL ()
CALL YLDIST1%FINAL ()
CALL YLDIST2%FINAL ()
CALL YLFSSC1%FINAL ()
CALL YLFSSC2%FINAL ()

CONTAINS

SUBROUTINE COMPUTE_SSO

REAL (KIND=JPIM), PARAMETER :: XPI = RPI
TYPE (ATLAS_FIELD) :: YLSSODIR2, YLSSOSLO2, YLSSOANI2, YLSSOSTD2
LOGICAL :: OSSO (YLFSSC2%SIZE ()), OSSO_ANIS (YLFSSC2%SIZE ())
REAL (KIND=JPRB) :: ZK (YLFSSC2%SIZE ()), ZL (YLFSSC2%SIZE ()), ZM (YLFSSC2%SIZE ())

! Create new fields for SSO parameters

CALL INS2 (JSSO_DIR,   NEWFLD (YLFSSC2, "SFX.SSO_DIR"  , ZUNDEF))
CALL INS2 (JSSO_SLOPE, NEWFLD (YLFSSC2, "SFX.SSO_SLOPE", ZUNDEF))
CALL INS2 (JSSO_ANIS , NEWFLD (YLFSSC2, "SFX.SSO_ANIS" , ZUNDEF))
CALL INS2 (JSSO_STDEV, NEWFLD (YLFSSC2, "SFX.SSO_STDEV", ZUNDEF))

OSSO = YLPT2 (JZS)%ZDATA /= ZUNDEF
OSSO_ANIS = OSSO 

! 1D computations; directly taken from SURFEX

!$OMP WORKSHARE 
WHERE (OSSO) 
  ZK=0.5*(YLPT2 (JZS_DXDX)%ZDATA+YLPT2 (JZS_DYDY)%ZDATA)
  ZL=0.5*(YLPT2 (JZS_DXDX)%ZDATA-YLPT2 (JZS_DYDY)%ZDATA)
  ZM=     YLPT2 (JZS_DXDY)%ZDATA 
ELSE WHERE
  ZK = ZUNDEF
  ZL = ZUNDEF
  ZM = ZUNDEF
  YLPT2 (JZS_DXDX  )%ZDATA = ZUNDEF
  YLPT2 (JZS_DYDY  )%ZDATA = ZUNDEF
  YLPT2 (JZS_DXDY  )%ZDATA = ZUNDEF
  YLPT2 (JSSO_DIR  )%ZDATA = ZUNDEF
  YLPT2 (JSSO_SLOPE)%ZDATA = ZUNDEF
  YLPT2 (JSSO_ANIS )%ZDATA = ZUNDEF
END WHERE
!$OMP END WORKSHARE

!
!*    8.     S.S.O. characteristics
!            ----------------------
!
!*    8.1    S.S.O. direction of main axis
!            -----------------------------
!
!$OMP WORKSHARE 
WHERE (OSSO)
  YLPT2 (JSSO_DIR)%ZDATA = 0.5_JPRB * ATAN2 (ZM, ZL) * (180._JPRB / XPI) 
END WHERE
!$OMP END WORKSHARE

!
!*    8.2    S.S.O. slope
!            ------------
!
!$OMP WORKSHARE 
WHERE (OSSO)
  YLPT2 (JSSO_SLOPE)%ZDATA = SQRT (ZK + SQRT (ZL*ZL + ZM*ZM))
END WHERE
!$OMP END WORKSHARE

!
!*    8.3    S.S.O. anisotropy
!            -----------------
!
!$OMP WORKSHARE 
WHERE (OSSO_ANIS .AND. (ZK+SQRT(ZL*ZL+ZM*ZM)) > 0._JPRB)
  YLPT2 (JSSO_ANIS)%ZDATA = SQRT (MAX (ZK-SQRT(ZL*ZL+ZM*ZM), 0._JPRB) / (ZK+SQRT (ZL*ZL+ZM*ZM)))
END WHERE
!$OMP END WORKSHARE
!
!$OMP WORKSHARE 
WHERE (OSSO_ANIS .AND. (ZK+SQRT (ZL*ZL+ZM*ZM)) == 0._JPRB)
  YLPT2 (JSSO_ANIS)%ZDATA = 1._JPRB
END WHERE
!$OMP END WORKSHARE

! Orography standard deviation

!$OMP WORKSHARE 
WHERE (OSSO)
  YLPT2 (JSSO_STDEV)%ZDATA = SQRT (MAX (YLPT2 (JZS2)%ZDATA - YLPT2 (JZS)%ZDATA**2, 0._JPRB))
ELSE WHERE
  YLPT2 (JSSO_STDEV)%ZDATA = ZUNDEF
END WHERE
!$OMP END WORKSHARE

! Add enveloppe

!$OMP WORKSHARE 
WHERE (YLPT2 (JZS)%ZDATA (:) /= ZUNDEF)
  YLPT2 (JZS)%ZDATA (:) = YLPT2 (JZS)%ZDATA (:) + YLPT2 (JSSO_STDEV)%ZDATA
ENDWHERE
!$OMP END WORKSHARE

END SUBROUTINE

SUBROUTINE COMPUTE_AOS

TYPE (INTERPOLATION4) :: YLINTE4
TYPE (ATLAS_FIELD) :: YLOROG1INT4, YLOROG1MINT4
TYPE (ATLAS_FIELD) :: YLOROG1IP, YLOROG1IM, YLOROG1JP, YLOROG1JM
TYPE (ATLAS_FIELD) :: YLIP, YLIM, YLJP, YLJM
REAL (KIND=JPRB), POINTER, DIMENSION (:) :: ZOROG1INT4, ZOROG1MINT4
REAL (KIND=JPRB), POINTER, DIMENSION (:) :: ZOROG1IP, ZOROG1IM, ZOROG1JP, ZOROG1JM
REAL (KIND=JPRB), POINTER, DIMENSION (:) :: ZIP, ZIM, ZJP, ZJM
TYPE (ATLAS_FIELDSET) :: YLFLDSHALF, YLFLDSAOS1, YLFLDSAOS2
INTEGER (KIND=JPIM) :: IAOSHO2 (8)
INTEGER (KIND=JPIM) :: JFLD, JLOC1

IAOSHO2 = [JAOSIP, JAOSIM, JAOSJP, JAOSJM, JHO2IP, JHO2IM, JHO2JP, JHO2JM]

! Interpolate from target geometry to origin geometry (fine lat/lon)

YLINTE4 = INTERPOLATION4 (YLDIST2, YLFSSC2, YLDIST1, YLFSSC1)

YLOROG1MINT4 = NEWFLD (YLFSSC1, "SFX.ZS.MINT4", ZUNDEF)

YLOROG1INT4  = YLINTE4%INTERPOLATE (YLFL2 (JZS))

CALL YLOROG1INT4 %DATA (ZOROG1INT4 )
CALL YLOROG1MINT4%DATA (ZOROG1MINT4)

! Difference of original orography with interpolated orography

!$OMP PARALLEL DO PRIVATE (JLOC1) IF (LLOPENMP)
DO JLOC1 = 1, SIZE (YLPT1 (JZS)%ZDATA)
  IF (YLPT1 (JZS)%ZDATA (JLOC1) /= ZUNDEF) THEN
    ZOROG1MINT4 (JLOC1) = YLPT1 (JZS)%ZDATA (JLOC1) - ZOROG1INT4 (JLOC1)
  ELSE
    ZOROG1MINT4 (JLOC1) = ZUNDEF
  ENDIF
ENDDO
!$OMP END PARALLEL DO

YLFLDSHALF = ATLAS_FIELDSET ()
CALL YLFLDSHALF%ADD (YLOROG1MINT4)


! Compute half gradients

YLFLDSAOS1 = HALFDIFF (YLFSSC1, YLFLDSHALF)

YLOROG1IP = YLFLDSAOS1%FIELD ("SFX.ZS.MINT4.XP"); CALL YLOROG1IP%DATA (ZOROG1IP)
YLOROG1IM = YLFLDSAOS1%FIELD ("SFX.ZS.MINT4.XM"); CALL YLOROG1IM%DATA (ZOROG1IM)
YLOROG1JP = YLFLDSAOS1%FIELD ("SFX.ZS.MINT4.YP"); CALL YLOROG1JP%DATA (ZOROG1JP)
YLOROG1JM = YLFLDSAOS1%FIELD ("SFX.ZS.MINT4.YM"); CALL YLOROG1JM%DATA (ZOROG1JM)

YLIP = YLFLDSAOS1%FIELD ("XP"); CALL YLIP%DATA (ZIP)
YLIM = YLFLDSAOS1%FIELD ("XM"); CALL YLIM%DATA (ZIM)
YLJP = YLFLDSAOS1%FIELD ("YP"); CALL YLJP%DATA (ZJP)
YLJM = YLFLDSAOS1%FIELD ("YM"); CALL YLJM%DATA (ZJM)

CALL YLFLDSAOS1%FINAL ()

CALL INS1 (JAOSIP, NEWFLD (YLFSSC1, "SFX.AOSIP", ZUNDEF))
CALL INS1 (JAOSIM, NEWFLD (YLFSSC1, "SFX.AOSIM", ZUNDEF))
CALL INS1 (JAOSJP, NEWFLD (YLFSSC1, "SFX.AOSJP", ZUNDEF))
CALL INS1 (JAOSJM, NEWFLD (YLFSSC1, "SFX.AOSJM", ZUNDEF))

! Work with data provided by the half gradient operator

!$OMP PARALLEL DO PRIVATE (JLOC1) IF (LLOPENMP)
DO JLOC1 = 1, SIZE (YLPT1 (JZS)%ZDATA)
  IF (YLPT1 (JZS)%ZDATA (JLOC1) /= ZUNDEF) THEN
    YLPT1 (JAOSIP)%ZDATA (JLOC1) = + MAX (0._JPRB, ZOROG1IP (JLOC1) / (RA * ZIP (JLOC1)))
    YLPT1 (JAOSIM)%ZDATA (JLOC1) = - MIN (0._JPRB, ZOROG1IM (JLOC1) / (RA * ZIM (JLOC1)))
    YLPT1 (JAOSJP)%ZDATA (JLOC1) = + MAX (0._JPRB, ZOROG1JP (JLOC1) / (RA * ZJP (JLOC1)))
    YLPT1 (JAOSJM)%ZDATA (JLOC1) = - MIN (0._JPRB, ZOROG1JM (JLOC1) / (RA * ZJM (JLOC1)))
  ELSE
    YLPT1 (JAOSIP)%ZDATA (JLOC1) = ZUNDEF
    YLPT1 (JAOSIM)%ZDATA (JLOC1) = ZUNDEF
    YLPT1 (JAOSJP)%ZDATA (JLOC1) = ZUNDEF
    YLPT1 (JAOSJM)%ZDATA (JLOC1) = ZUNDEF
  ENDIF
ENDDO
!$OMP END PARALLEL DO

CALL INS1 (JHO2IP, NEWFLD (YLFSSC1, "SFX.HO2IP", ZUNDEF))
CALL INS1 (JHO2IM, NEWFLD (YLFSSC1, "SFX.HO2IM", ZUNDEF))
CALL INS1 (JHO2JP, NEWFLD (YLFSSC1, "SFX.HO2JP", ZUNDEF))
CALL INS1 (JHO2JM, NEWFLD (YLFSSC1, "SFX.HO2JM", ZUNDEF))

!$OMP PARALLEL DO PRIVATE (JLOC1) IF (LLOPENMP)
DO JLOC1 = 1, SIZE (YLPT1 (JZS)%ZDATA)
  IF ((YLPT1 (JZS)%ZDATA (JLOC1) /= ZUNDEF) .AND. (ZOROG1IP (JLOC1) > 0._JPRB)) THEN
    YLPT1 (JHO2IP)%ZDATA (JLOC1) = + ZOROG1IP (JLOC1) * 0.5_JPRB      
  ELSE
    YLPT1 (JHO2IP)%ZDATA (JLOC1) = ZUNDEF
  ENDIF
ENDDO
!$OMP END PARALLEL DO

!$OMP PARALLEL DO PRIVATE (JLOC1) IF (LLOPENMP)
DO JLOC1 = 1, SIZE (YLPT1 (JZS)%ZDATA)
  IF ((YLPT1 (JZS)%ZDATA (JLOC1) /= ZUNDEF) .AND. (ZOROG1IM (JLOC1) < 0._JPRB)) THEN
    YLPT1 (JHO2IM)%ZDATA (JLOC1) = - ZOROG1IM (JLOC1) * 0.5_JPRB       
  ELSE
    YLPT1 (JHO2IM)%ZDATA (JLOC1) = ZUNDEF
  ENDIF
ENDDO
!$OMP END PARALLEL DO
  
!$OMP PARALLEL DO PRIVATE (JLOC1) IF (LLOPENMP)
DO JLOC1 = 1, SIZE (YLPT1 (JZS)%ZDATA)
  IF ((YLPT1 (JZS)%ZDATA (JLOC1) /= ZUNDEF) .AND. (ZOROG1JP (JLOC1) > 0._JPRB)) THEN
    YLPT1 (JHO2JP)%ZDATA (JLOC1) = + ZOROG1JP (JLOC1) * 0.5_JPRB       
  ELSE
    YLPT1 (JHO2JP)%ZDATA (JLOC1) = ZUNDEF
  ENDIF
ENDDO
!$OMP END PARALLEL DO
  
!$OMP PARALLEL DO PRIVATE (JLOC1) IF (LLOPENMP)
DO JLOC1 = 1, SIZE (YLPT1 (JZS)%ZDATA)
  IF ((YLPT1 (JZS)%ZDATA (JLOC1) /= ZUNDEF) .AND. (ZOROG1JM (JLOC1) < 0._JPRB)) THEN
    YLPT1 (JHO2JM)%ZDATA (JLOC1) = - ZOROG1JM (JLOC1) * 0.5_JPRB      
  ELSE
    YLPT1 (JHO2JM)%ZDATA (JLOC1) = ZUNDEF
  ENDIF
ENDDO
!$OMP END PARALLEL DO

! Interpolate AOS & HO2 

YLFLDSAOS1 = ATLAS_FIELDSET ()

DO JFLD = 1, SIZE (IAOSHO2)
  CALL YLFLDSAOS1%ADD (YLFL1 (IAOSHO2 (JFLD)))
ENDDO

YLFLDSAOS2 = YLINTEA%INTERPOLATE (YLFLDSAOS1)

DO JFLD = 1, SIZE (IAOSHO2)
  CALL INS2 (IAOSHO2 (JFLD), YLFLDSAOS2%FIELD (JFLD))
!$OMP WORKSHARE 
  WHERE ((YLPT2 (JZS)%ZDATA /= ZUNDEF) .AND. (YLPT2 (IAOSHO2 (JFLD))%ZDATA == ZUNDEF))
    YLPT2 (IAOSHO2 (JFLD))%ZDATA = 0._JPRB
  ENDWHERE
!$OMP END WORKSHARE
ENDDO

CALL YLOROG1IP%FINAL ()
CALL YLOROG1IM%FINAL ()
CALL YLOROG1JP%FINAL ()
CALL YLOROG1JM%FINAL ()

CALL YLIP%FINAL ()
CALL YLIM%FINAL ()
CALL YLJP%FINAL ()
CALL YLJM%FINAL ()

CALL YLINTE4    %FINAL ()
CALL YLOROG1INT4%FINAL ()
CALL YLFLDSHALF %FINAL ()
CALL YLFLDSAOS1 %FINAL ()
CALL YLFLDSAOS2 %FINAL ()

END SUBROUTINE

SUBROUTINE COMPUTE_FRACTIONS

TYPE (COVERS_t) :: YLCOVERS
LOGICAL, ALLOCATABLE :: LCOVER (:)

REAL (KIND=JPRB) :: ZAVGCOVR2 (INCOVR)
REAL (KIND=JPRB) :: ZMINCOVR2 (INCOVR)
REAL (KIND=JPRB) :: ZMAXCOVR2 (INCOVR)

! Create fractions fields

CALL INS2 (JFRAC_SEA   , NEWFLD (YLFSSC2, "SFX.FRAC_SEA"   , ZUNDEF))
CALL INS2 (JFRAC_NATURE, NEWFLD (YLFSSC2, "SFX.FRAC_NATURE", ZUNDEF))
CALL INS2 (JFRAC_TOWN  , NEWFLD (YLFSSC2, "SFX.FRAC_TOWN"  , ZUNDEF))
CALL INS2 (JFRAC_WATER , NEWFLD (YLFSSC2, "SFX.FRAC_WATER" , ZUNDEF))

CALL READCOVERS (YLCOVERS, 1, LGARDEN, LWATER_TO_NATURE, LTOWN_TO_ROCK)
CALL FIELDSTAT (YLFSSC2, YLFL2 (JCOVER+1:JCOVER+INCOVR), PMIN=ZMINCOVR2, PMAX=ZMAXCOVR2, PAVG=ZAVGCOVR2)

ALLOCATE (LCOVER (YLCOVERS%JPCOVER))
LCOVER = .FALSE.

LCOVER = ZAVGCOVR2 > 0._JPRB

CALL MAKEFRAC (YLPT2 (JFRAC_SEA   )%ZDATA, YLFL2 (JCOVER+1:JCOVER+INCOVR), YLCOVERS%XDATA_SEA   , LCOVER)
CALL MAKEFRAC (YLPT2 (JFRAC_NATURE)%ZDATA, YLFL2 (JCOVER+1:JCOVER+INCOVR), YLCOVERS%XDATA_NATURE, LCOVER)
CALL MAKEFRAC (YLPT2 (JFRAC_TOWN  )%ZDATA, YLFL2 (JCOVER+1:JCOVER+INCOVR), YLCOVERS%XDATA_TOWN  , LCOVER)
CALL MAKEFRAC (YLPT2 (JFRAC_WATER )%ZDATA, YLFL2 (JCOVER+1:JCOVER+INCOVR), YLCOVERS%XDATA_WATER , LCOVER)

END SUBROUTINE

FUNCTION NEWFLD (YDFSSC, CDNAME, PUNDEF) RESULT (YLFLD)

TYPE (ATLAS_FIELD) :: YLFLD

TYPE (ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS), INTENT (IN)  :: YDFSSC
CHARACTER (LEN=*),                            INTENT (IN)  :: CDNAME
REAL (KIND=JPRB), OPTIONAL,                   INTENT (IN)  :: PUNDEF

TYPE (ATLAS_METADATA) :: YLMETA

! Create new field; set its undef value in its metadata section

YLFLD = ATLAS_FIELD (NAME=TRIM (CDNAME), KIND=JPRB, SHAPE=[YDFSSC%SIZE ()])

IF (PRESENT (PUNDEF)) THEN
  YLMETA = YLFLD%METADATA ()
  CALL YLMETA%SET ("undef", PUNDEF)
  CALL YLMETA%FINAL ()
ENDIF

CALL YLFLD%RETURN ()

END FUNCTION

SUBROUTINE MAKEFRAC (PFRAC, YDCOVER, PDATA, LDCOVER)

REAL (KIND=JPRB),   INTENT (OUT) :: PFRAC (:)
TYPE (ATLAS_FIELD), INTENT (IN)  :: YDCOVER (:)
REAL (KIND=JPRB),   INTENT (IN)  :: PDATA (:)
LOGICAL,            INTENT (IN)  :: LDCOVER (:)

TYPE (PTR) :: YLPTR (SIZE (YDCOVER))

INTEGER (KIND=JPIM) :: JLOC, JCOV, INCOV
REAL (KIND=JPRB) :: ZSUM

INCOV = SIZE (YDCOVER)

DO JCOV = 1, INCOV
  CALL YDCOVER (JCOV)%DATA (YLPTR (JCOV)%ZDATA)
ENDDO

! 1D computation

!$OMP PARALLEL DO PRIVATE (JLOC, ZSUM, JCOV) IF (LLOPENMP)
DO JLOC = 1, SIZE (PFRAC)
  PFRAC (JLOC) = 0._JPRB
  ZSUM = 0._JPRB
  DO JCOV = 1, INCOV
    IF (LDCOVER (JCOV)) THEN
      PFRAC (JLOC) = PFRAC (JLOC) + YLPTR (JCOV)%ZDATA (JLOC) * PDATA (JCOV)
      ZSUM         = ZSUM + YLPTR (JCOV)%ZDATA (JLOC)
    ENDIF
  ENDDO
  PFRAC (JLOC) = PFRAC (JLOC) / ZSUM
ENDDO
!$OMP END PARALLEL DO

END SUBROUTINE

SUBROUTINE RNS1 (KRANK, CDNAME, PSCALE)

INTEGER (KIND=JPIM), INTENT (IN) :: KRANK
CHARACTER (LEN=*),   INTENT (IN) :: CDNAME
REAL (KIND=JPRB),    INTENT (IN), OPTIONAL :: PSCALE

TYPE (ATLAS_FIELDSET) :: YLFS

! Read a field on source geometry, and insert it in the list #1

YLFS = YDIO1%READ (CDNAME, [CDNAME], YLFSSC1, PUNDEF=ZUNDEF, PSCALE=PSCALE)
CALL INS1 (KRANK, YLFS%FIELD (1))
CALL YLFS%FINAL ()

END SUBROUTINE

SUBROUTINE INS1 (KRANK, YDFL)

INTEGER (KIND=JPIM), INTENT (IN) :: KRANK
TYPE (ATLAS_FIELD),  INTENT (IN) :: YDFL

! Insert a field in list#1 (origin)

IF (.NOT. YLFL1 (KRANK)%IS_NULL ()) CALL ABORT ('FIELD ALREADY EXISTS')
IF (YDFL%SIZE () /= YLFSSC1%SIZE ()) CALL ABORT ('SIZE MISMATCH')
YLFL1 (KRANK) = YDFL
CALL YDFL%DATA (YLPT1 (KRANK)%ZDATA)
CALL YLFLDS1%ADD (YDFL)

END SUBROUTINE

SUBROUTINE INS2 (KRANK, YDFL)

INTEGER (KIND=JPIM), INTENT (IN) :: KRANK
TYPE (ATLAS_FIELD),  INTENT (IN) :: YDFL

! Insert a field in list #2 (target)

IF (.NOT. YLFL2 (KRANK)%IS_NULL ()) CALL ABORT ('FIELD ALREADY EXISTS')
IF (YDFL%SIZE () /= YLFSSC2%SIZE ()) CALL ABORT ('SIZE MISMATCH')
YLFL2 (KRANK) = YDFL
CALL YDFL%DATA (YLPT2 (KRANK)%ZDATA)
CALL YLFLDS2%ADD (YDFL)

END SUBROUTINE

FUNCTION CROSS (P1, P2) RESULT (P)

REAL (KIND=JPRB), INTENT (IN) :: P1 (3), P2 (3)
REAL (KIND=JPRB) :: P (3)


P (1) = P1 (2) * P2 (3) - P2 (2) * P1 (3)
P (2) = P1 (3) * P2 (1) - P2 (3) * P1 (1)
P (3) = P1 (1) * P2 (2) - P2 (1) * P1 (2)

END FUNCTION

REAL (KIND=JPRB) FUNCTION NORM (P) 

REAL (KIND=JPRB), INTENT (IN) :: P (3)

NORM = SQRT (SUM (P * P))

END FUNCTION

ELEMENTAL LOGICAL FUNCTION ISINF (P)

REAL (KIND=JPRB), INTENT (IN) :: P

ISINF = ABS (P) > HUGE (P)

END FUNCTION


END

