SUBROUTINE FACGRM_MT64                                              &
&                     (FA, KREP, KRANG, CDPREF, KNIVAU, CDSUFF,     &
&                      PCHAMP, LDCOSP, KGRIBH, LDUNDF,              &
&                      PUNDF, KLOCSN)
USE FA_MOD, ONLY : FA_COM, JPNIIL, FACADR, FAFICH,                  &
                 & NGRIB2_GLO_SH, NGRIB2_GLO_GP, NGRIB2_LAM_GP,     &
                 & NGRIB2_LAM_BF, NGRIB2_LATLON, NGRIB1_LATLON,     &
                 & LGRIB2_LAM_EX, NUNDEF
USE PARKIND1, ONLY : JPRB
USE YOMHOOK , ONLY : LHOOK, DR_HOOK
USE LFI_PRECISION
USE GRIB_API_INTERFACE
USE GRIB_API
IMPLICIT NONE
!****
!      Sous-programme INTERNE du logiciel de Fichiers ARPEGE:
!      PREPARATION (codage GRIB_API) d'un CHAMP HORIZONTAL
!      destine a etre ecrit sur un fichier ARPEGE/ALADIN.
!**
!    Arguments : KREP   (Sortie) ==> Code-reponse du sous-programme;
!                KRANG  (Entree) ==> Rang de l'unite logique;
!                CDPREF (Entree) ==> Prefixe eventuel du nom d'article;
!                KNIVAU (Entree) ==> Niveau vertical eventuel;
!                CDSUFF (Entree) ==> Suffixe eventuel du nom d'article;
!    ( Tableau ) PCHAMP (Entree) ==> Valeurs REELLES du champ a ecrire;
!                LDCOSP (Entree) ==> Vrai si le champ est represente
!                                    par des coefficients spectraux;
!    ( Tableau ) KGRIBH (Sortie) ==> Message GRIB
!*
!
TYPE(FA_COM)   :: FA
INTEGER (KIND=JPLIKB) KREP, KRANG, KNIVAU, KLOCSN
!
INTEGER (KIND=JPLIKM) KGRIBH
REAL (KIND=JPDBLR), TARGET :: PCHAMP(*)
REAL (KIND=JPDBLR) PUNDF, ZUNDF
!
LOGICAL LDCOSP, LDUNDF, LLCOSP, LLUNDF
!
CHARACTER CDPREF*(*), CDSUFF*(*)
!
REAL (KIND=JPDBLR), PARAMETER :: RPI = 2.0_JPDBLR * ASIN (1.0_JPDBLR)
!
TYPE (FACADR), POINTER :: YLCADR
TYPE (FAFICH), POINTER :: YLFICH
INTEGER (KIND=JPLIKB) :: IRANGC, INIMES, INUMER
INTEGER (KIND=JPLIKB) INGRIB, INBITS
CHARACTER(LEN=FA%JPLSPX)   CLNSPR
CHARACTER(LEN=FA%JPXNOM)   CLACTI 
CHARACTER(LEN=FA%JPLMES)   CLMESS 
CHARACTER(LEN=FA%JPXNOM)   CLNOMA
LOGICAL LLMLAM, LLLTLN, LLFATA, LLMGLO
INTEGER (KIND=JPLIKB) :: ILNOMA
INTEGER (KIND=JPLIKB) :: INGRIB_GP, INGRIB_SP
INTEGER (KIND=JPLIKB) :: IVERSI
REAL (KIND=JPDBLR)    :: ZMULTI  ! Facteur multiplicatif
INTEGER               :: ISTCUM  ! Cumul depuis le debut
INTEGER               :: ILOCAL
INTEGER               :: IOUT
LOGICAL               :: LLGRIB1, LLGRIB2
LOGICAL               :: LLDOUBLE
                         

REAL (KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK('FACGRM_MT',0,ZHOOK_HANDLE)

LLFATA=LLMOER (KREP,KRANG)
LLDOUBLE = JPDBLR == JPDBLD

CALL FAIGRA_MT64 (FA)

KREP = 0

YLFICH => FA%FICHIER(KRANG)
IRANGC = YLFICH%NUCADR
YLCADR => FA%CADRE(IRANGC)
!
LLMLAM = YLCADR%LIMLAM
LLLTLN = YLCADR%SINLAT(2) < 0 .AND. LLMLAM
LLMGLO = (.NOT. LLMLAM) .AND. (.NOT. LLLTLN)
!
LLUNDF = LDUNDF
LLCOSP = LDCOSP
!
INUMER = YLFICH%NULOGI
!

INGRIB    = YLFICH%NFGRIB
INGRIB_GP = FALGRA_GP (INGRIB)
INGRIB_SP = FALGRA_SP (INGRIB)

CALL GRIB_GET_API_VERSION (IVERSI)

IF (LDCOSP .AND. (IVERSI /= 11400) .AND. (INGRIB_SP == 101)) THEN
  LLFATA = .TRUE.
  KREP   = -125
  GOTO 1001
ELSE IF (LDCOSP .AND. (IVERSI == 11400) .AND. (INGRIB_SP /= 101)) THEN
  LLFATA = .TRUE.
  KREP   = -125
  GOTO 1001
ENDIF

IF (LLCOSP) THEN
  INGRIB = INGRIB_SP
ELSE
  INGRIB = INGRIB_GP
ENDIF


LLGRIB1 = FALGRA_ED (INGRIB) == 1
LLGRIB2 = FALGRA_ED (INGRIB) == 2

IF (LLLTLN) THEN
  IF (LLGRIB1) THEN
    CALL IGRIB_CLONE (NGRIB1_LATLON, KGRIBH)
  ELSE
    CALL IGRIB_CLONE (NGRIB2_LATLON, KGRIBH)
  ENDIF
ELSEIF (LLMLAM) THEN
  IF (LLCOSP) THEN
    CALL IGRIB_CLONE (NGRIB2_LAM_BF, KGRIBH)
  ELSE
    CALL IGRIB_CLONE (NGRIB2_LAM_GP, KGRIBH)
  ENDIF
ELSEIF (LLMGLO) THEN
  IF (LLCOSP) THEN
    CALL IGRIB_CLONE (NGRIB2_GLO_SH, KGRIBH)
  ELSE
    CALL IGRIB_CLONE (NGRIB2_GLO_GP, KGRIBH)
  ENDIF
ENDIF

! Set parameter

CALL FAGRIB_API_SET_PARAM 

IF (KREP /= 0) GOTO 1001

! Horizontal geometry

CALL FAGRIB_API_HGEOM 

IF (KREP /= 0) GOTO 1001

! Vertical geometry

CALL FAGRIB_API_VGEOM 

IF (KREP /= 0) GOTO 1001

! Date

CALL FAGRIB_API_DATE 

IF (KREP /= 0) GOTO 1001

! Set values

CALL FAGRIB_API_SET_VALUES 

IF (KREP /= 0) GOTO 1001

! Set local section

!IF (LLGRIB1) THEN
CALL FAGRIB_SET_LOCAL_SECTION 
!END IF

IF (KREP /= 0) GOTO 1001

1001 CONTINUE
!
IF (FA%LFAMOP.OR.LLFATA) THEN
  INIMES=2
  CLNSPR='FACGRM'
  INUMER=JPNIIL
!
  WRITE (UNIT=CLMESS,FMT='(''KREP='',I5,'', KRANG='',I4,  &
&         '', CDPREF='''''',A,'''''', KNIVAU='',I6,       &
&         '', CDSUFF='''''',A,'''''', LLCOSP= '',L1)')    &
&     KREP, KRANG, CDPREF(1:LEN_TRIM(CDPREF)), KNIVAU,    &
&     CDSUFF(1:LEN_TRIM(CDSUFF)), LLCOSP

  CALL FAIPAR_MT64                                        &
&                 (FA, INUMER,INIMES,KREP,.FALSE.,CLMESS, &
&                  CLNSPR,CLACTI,.FALSE.)
ENDIF

IF (LHOOK) CALL DR_HOOK('FACGRM_MT',1,ZHOOK_HANDLE)
!
CONTAINS

SUBROUTINE STRU (CDS, CDU)
CHARACTER (LEN=*) :: CDS, CDU
INTEGER (KIND=JPLIKB) :: J

DO J = 1, LEN (CDU)
  CDU (J:J) = ' '
ENDDO

DO J = 1, LEN_TRIM (CDS)
  IF (CDS (J:J) == ' ') THEN
    CDU (J:J) = '_'
  ELSE
    CDU (J:J) = CDS (J:J)
  ENDIF
ENDDO

END SUBROUTINE STRU

#include "facom2.llmoer.h"
#include "falgra.h"

SUBROUTINE FAGRIB_API_SET_PARAM 

CHARACTER(LEN=FA%JPXNOM)  CLPREF, CLSUFF, CLNOMU
INTEGER(KIND=JPLIKB)      INIVAU, IPARAM, IDPROC, ILEVEL
INTEGER(KIND=JPLIKB)      IMULTM, IMULTE
INTEGER(KIND=JPLIKB)      ILPREF, ILSUFF
REAL (KIND=JPDBLR)        ZLBASE, ZLMULT, ZLEVEL
LOGICAL                   LLENSEMB
INTEGER (KIND=JPLIKB)     INBFCENS, IPERTNUM, ITYPEENS, IPRDEFNB

INTEGER (KIND=JPLIKB), PARAMETER :: ILENK = 15
CHARACTER (LEN=64), PARAMETER :: CLKEYS (0:ILENK) = (/         &
    '0123456789012345678901234567890123456789012345678901234', & !    0
    'discipline                                             ', & !    1
    'indicatorOfUnitForTimeRange                            ', & !    2
    'lengthOfTimeRange                                      ', & !    3
!    'level                                                  ', & !    4
    'NB                                                     ', & !    5
    'parameterCategory                                      ', & !    6
    'parameterNumber                                        ', & !    7
    'scaledValueOfCentralWaveNumber                         ', & !    8
    'scaledValueOfFirstFixedSurface                         ', & !    9
    'scaledValueOfSecondFixedSurface                        ', & !   10
    'scaleFactorOfCentralWaveNumber                         ', & !   11
    'scaleFactorOfFirstFixedSurface                         ', & !   12
    'statisticalProcess                                     ', & !   13
    'typeOfFirstFixedSurface                                ', & !   14
!    'typeOfGeneratingProcess                                ', & !   15
    'typeOfSecondFixedSurface                               ', & !   16
    'typeOfStatisticalProcessing                            ' /) !   17
INTEGER (KIND=JPLIKB) :: IIVALS (ILENK), IVIDX
LOGICAL LLEXIST


CALL IGRIB_SET_VALUE (KGRIBH, 'centre', YLFICH%NIDCEN)

IF (LLGRIB1) THEN
  CALL IGRIB_SET_VALUE (KGRIBH, 'setLocalDefinition', 1)
ELSE
  CALL IGRIB_SET_VALUE (KGRIBH, 'grib2LocalSectionPresent', 1)
  CALL IGRIB_SET_VALUE (KGRIBH, 'grib2LocalSectionNumber', KLOCSN)
ENDIF

IF (YLFICH%CMODEL /= '') THEN
  CALL IGRIB_SET_VALUE (KGRIBH, 'faModelName', TRIM (YLFICH%CMODEL))
  CALL IGRIB_GET_VALUE (KGRIBH, 'generatingProcessIdentifier', IDPROC)
  IF (IDPROC == 255) THEN
    WRITE (FA%NULOUT, '(" FACGRM: Model `",A,"'' is not &
         &declared in `faModelName.def''")') TRIM (YLFICH%CMODEL)
  ENDIF
ENDIF


IF (LLGRIB2) THEN
  ! See if we are dealing with ensemble data
  CALL IGRIB_IS_DEFINED (KGRIBH, 'numberOfForecastsInEnsemble', LLENSEMB)
  IF (LLENSEMB) THEN
    CALL IGRIB_GET_VALUE (KGRIBH, 'numberOfForecastsInEnsemble',     INBFCENS)
    CALL IGRIB_GET_VALUE (KGRIBH, 'perturbationNumber',              IPERTNUM)
    CALL IGRIB_GET_VALUE (KGRIBH, 'typeOfEnsembleForecast',          ITYPEENS)
    CALL IGRIB_SET_VALUE (KGRIBH, 'productDefinitionTemplateNumber', 0_JPLIKB)
    CALL IGRIB_SET_VALUE (KGRIBH, 'typeOfGeneratingProcess',         4_JPLIKB)
    CALL IGRIB_SET_VALUE (KGRIBH, 'typeOfProcessedData',             5_JPLIKB)
  ELSE
    CALL IGRIB_SET_VALUE (KGRIBH, 'typeOfGeneratingProcess',         2_JPLIKB)
    CALL IGRIB_SET_VALUE (KGRIBH, 'typeOfProcessedData', 1_JPLIKB)
  ENDIF
ENDIF

CALL FANFAN_MT64 (FA, KREP, INUMER, CDPREF, KNIVAU, CDSUFF, CLNOMA, ILNOMA)
CALL FAQUIN_MT64 (FA, KREP, INUMER, CLPREF, INIVAU, CLSUFF, CLNOMA, ILNOMA)

ILPREF = LEN (CLPREF)
ILSUFF = LEN (CLSUFF)

IF ((INIVAU == KNIVAU) &
.AND. (CLPREF (1:ILPREF) == CDPREF (1:ILPREF)) &
.AND. (CLSUFF (1:ILSUFF) == CDSUFF (1:ILSUFF))) THEN
  CLPREF = CDPREF
  CLSUFF = CDSUFF
ENDIF

IF (KNIVAU > 0) THEN
  CALL STRU (CLPREF, CLNOMU)
  CALL IGRIB_SET_VALUE (KGRIBH, 'faLevelName', TRIM (CLNOMU))
  CALL STRU (CLSUFF, CLNOMU)
  CALL IGRIB_SET_VALUE (KGRIBH, 'faFieldName', TRIM (CLNOMU))
  CALL IGRIB_GET_VALUE (KGRIBH, 'ZLMULT', ZLMULT)
  CALL IGRIB_GET_VALUE (KGRIBH, 'ZLBASE', ZLBASE)
  ZLEVEL = ZLMULT * INIVAU + ZLBASE
  IF ((TRIM(CLPREF).EQ.'V').AND.(.NOT. LLGRIB1)) THEN
       ! this is a dirty workaround to bypass issues with the 'level' key in grib2
       CALL IGRIB_SET_VALUE (KGRIBH, 'scaleFactorOfFirstFixedSurface', 9)
       CALL IGRIB_SET_VALUE (KGRIBH, 'scaledValueOfFirstFixedSurface', INIVAU*100)
  ELSEIF ((TRIM(CLPREF).EQ.'P').AND.(.NOT. LLGRIB1)) THEN
       ! this is a dirty workaround to bypass issues with the 'level' key in
       ! grib2
       ILEVEL=INT(ZLEVEL)
       CALL IGRIB_SET_VALUE (KGRIBH, 'scaleFactorOfFirstFixedSurface', 0)
       CALL IGRIB_SET_VALUE (KGRIBH, 'scaledValueOfFirstFixedSurface', ILEVEL)
  ELSEIF ((TRIM(CLPREF).EQ.'H').AND.(.NOT. LLGRIB1)) THEN
       ! this is a dirty workaround to bypass issues with the 'level' key in
       ! grib2
       ILEVEL=INT(ZLEVEL)
       CALL IGRIB_SET_VALUE (KGRIBH, 'scaleFactorOfFirstFixedSurface', 0)
       CALL IGRIB_SET_VALUE (KGRIBH, 'scaledValueOfFirstFixedSurface', ILEVEL)
  ELSE
        CALL IGRIB_SET_VALUE (KGRIBH, 'level', ZLEVEL)
  END IF
ELSE
  CALL STRU (CLNOMA, CLNOMU)
  CALL IGRIB_SET_VALUE (KGRIBH, 'faFieldName', CLNOMU (1:ILNOMA))
ENDIF

IF (LLGRIB1) THEN
  CALL IGRIB_GET_VALUE (KGRIBH, 'indicatorOfParameter', IPARAM)
ELSE
  CALL IGRIB_GET_VALUE (KGRIBH, 'parameterNumber', IPARAM)
ENDIF

IF (LLGRIB2) THEN
  IF (LLENSEMB) THEN

    ! Save parameter defintion before switching to a new
    ! productDefinitionTemplateNumber; apparently, grib_api does not manage to
    ! keep them

    DO IVIDX = 1, ILENK
      CALL IGRIB_IS_DEFINED (KGRIBH, TRIM (CLKEYS (IVIDX)), LLEXIST)
      IF (LLEXIST) THEN
        CALL IGRIB_GET_VALUE (KGRIBH, TRIM (CLKEYS (IVIDX)), IIVALS (IVIDX))
      ELSE
        IIVALS (IVIDX) = -1_JPLIKB
      ENDIF
    ENDDO

    CALL IGRIB_GET_VALUE (KGRIBH, 'productDefinitionTemplateNumber', IPRDEFNB)
    SELECT CASE (IPRDEFNB)
      CASE ( 0_JPLIKB); IPRDEFNB =  1_JPLIKB
      CASE ( 8_JPLIKB); IPRDEFNB = 11_JPLIKB
      CASE (32_JPLIKB); IPRDEFNB = 33_JPLIKB
      CASE (1_JPLIKB); IPRDEFNB = 1_JPLIKB
      CASE DEFAULT
        KREP = -129
        RETURN
    END SELECT 
    CALL IGRIB_SET_VALUE (KGRIBH, 'productDefinitionTemplateNumber', IPRDEFNB)

    ! Restore parameter defintion
    DO IVIDX = 1, ILENK
      IF (IIVALS (IVIDX) /= -1_JPLIKB) THEN
        CALL IGRIB_SET_VALUE (KGRIBH, TRIM (CLKEYS (IVIDX)), IIVALS (IVIDX))
      ENDIF
    ENDDO

    CALL IGRIB_SET_VALUE (KGRIBH, 'numberOfForecastsInEnsemble',     INBFCENS)
    CALL IGRIB_SET_VALUE (KGRIBH, 'perturbationNumber',              IPERTNUM)
    CALL IGRIB_SET_VALUE (KGRIBH, 'typeOfEnsembleForecast',          ITYPEENS)
    CALL IGRIB_SET_VALUE (KGRIBH, 'typeOfGeneratingProcess',         4_JPLIKB)
    CALL IGRIB_SET_VALUE (KGRIBH, 'typeOfProcessedData',             5_JPLIKB)


  ELSE
    CALL IGRIB_SET_VALUE (KGRIBH, 'typeOfGeneratingProcess',         2_JPLIKB)
  ENDIF

ENDIF

IF (IPARAM == 255) THEN
  WRITE (FA%NULOUT, '(" FACGRM: Field `",A,"'' is not &
       &declared in `faFieldName.def''")') TRIM (CLNOMA)
ENDIF

CALL IGRIB_GET_VALUE (KGRIBH, 'FMULTM', IMULTM)
CALL IGRIB_GET_VALUE (KGRIBH, 'FMULTE', IMULTE)
ZMULTI = REAL (IMULTM, JPDBLR) * 10._JPDBLR ** IMULTE

END SUBROUTINE FAGRIB_API_SET_PARAM

SUBROUTINE FAGRIB_API_HGEOM 

IF (LLLTLN) THEN
  CALL FAGRIB_API_HGEOM_LATLON 
ELSEIF (LLMLAM) THEN
  IF (LLCOSP) THEN
    CALL FAGRIB_API_HGEOM_LAM_BF 
  ELSE
    CALL FAGRIB_API_HGEOM_LAM_GP 
  ENDIF
ELSEIF (LLMGLO) THEN
  IF (LLCOSP) THEN
    CALL FAGRIB_API_HGEOM_GLO_SH 
  ELSE
    CALL FAGRIB_API_HGEOM_GLO_GP 
  ENDIF
ENDIF

END SUBROUTINE FAGRIB_API_HGEOM

SUBROUTINE FAGRIB_API_HGEOM_LAM_BF 

REAL (KIND=JPDBLR) :: ZDELX, ZDELY, ZRPK
INTEGER (KIND=JPLIKB) :: ILONS, ILATS

ILATS = YLCADR%NLATIT
ILONS = YLCADR%NXLOPA
ZDELX = YLCADR%SINLAT (7)
ZDELY = YLCADR%SINLAT (8)
ZRPK  = YLCADR%SINLAT (2)

IF (0._JPDBLR < ZRPK .AND. ZRPK < 1._JPDBLR) THEN

! Lambert

  CALL IGRIB_SET_VALUE (KGRIBH, 'gridType', 'lambert_bf')

ELSEIF (ZRPK == 0._JPDBLR) THEN

! Mercator

  CALL IGRIB_SET_VALUE (KGRIBH, 'gridType', 'mercator_bf')

ELSEIF (ZRPK == 1._JPDBLR) THEN

! Polar stereographic

  CALL IGRIB_SET_VALUE (KGRIBH, 'gridType', 'polar_stereographic_bf')

ENDIF

CALL IGRIB_SET_VALUE (KGRIBH, "biFourierResolutionParameterN", YLCADR%NSMAX)
CALL IGRIB_SET_VALUE (KGRIBH, "biFourierResolutionParameterM", YLCADR%NMSMAX)

CALL IGRIB_SET_VALUE (KGRIBH, 'LxInMetres', ZDELX * (ILONS-1))
CALL IGRIB_SET_VALUE (KGRIBH, 'LyInMetres', ZDELY * (ILATS-1))

CALL IGRIB_SET_VALUE (KGRIBH, 'LuxInMetres', ZDELX * (YLCADR%NLOPAR (4)-1))
CALL IGRIB_SET_VALUE (KGRIBH, 'LuyInMetres', ZDELY * (YLCADR%NLOPAR (6)-1))

CALL IGRIB_SET_VALUE (KGRIBH, 'LcxInMetres', ZDELX * MAX (1, YLCADR%NLOPAR (7)-1))
CALL IGRIB_SET_VALUE (KGRIBH, 'LcyInMetres', ZDELY * MAX (1, YLCADR%NLOPAR (8)-1))

CALL IGRIB_SET_VALUE (KGRIBH, "biFourierTruncationType", 99) 

CALL FAGRIB_API_HGEOM_LAM_PR

END SUBROUTINE FAGRIB_API_HGEOM_LAM_BF

SUBROUTINE FAGRIB_API_HGEOM_LATLON 

INTEGER (KIND=JPLIKB) :: ILONS, ILATS
REAL (KIND=JPDBLR)    :: ZLONW, ZLATS, ZLONE, ZLATN, ZLOND, ZLATD

ILATS = YLCADR%NLATIT
ILONS = YLCADR%NXLOPA

ZLONW = LONRAD2DEG (YLCADR%SINLAT(13))
ZLATS = LATRAD2DEG (YLCADR%SINLAT(14))
ZLONE = LONRAD2DEG (YLCADR%SINLAT(15))
ZLATN = LATRAD2DEG (YLCADR%SINLAT(16))

ZLOND = MODULO (ZLONE-ZLONW, 360._JPDBLR) / (ILONS-1)
ZLATD = (ZLATN-ZLATS)/(ILATS-1)

ZLONW = RROUND16(ZLONW)
ZLATS = RROUND16(ZLATS)
ZLONE = RROUND16(ZLONE)
ZLATN = RROUND16(ZLATN)
ZLOND = RROUND16(ZLOND)
ZLATD = RROUND16(ZLATD)


CALL IGRIB_SET_VALUE (KGRIBH, 'Ni', ILONS)
CALL IGRIB_SET_VALUE (KGRIBH, 'Nj', ILATS)
CALL IGRIB_SET_VALUE (KGRIBH, 'longitudeOfFirstGridPointInDegrees', ZLONW)
CALL IGRIB_SET_VALUE (KGRIBH, 'latitudeOfLastGridPointInDegrees',   ZLATS)
CALL IGRIB_SET_VALUE (KGRIBH, 'longitudeOfLastGridPointInDegrees',  ZLONE)
CALL IGRIB_SET_VALUE (KGRIBH, 'latitudeOfFirstGridPointInDegrees',  ZLATN)
CALL IGRIB_SET_VALUE (KGRIBH, 'iScansNegatively', 0)
CALL IGRIB_SET_VALUE (KGRIBH, 'jScansPositively', 0)
CALL IGRIB_SET_VALUE (KGRIBH, 'iDirectionIncrementInDegrees', ZLOND)
CALL IGRIB_SET_VALUE (KGRIBH, 'jDirectionIncrementInDegrees', ZLATD)

END SUBROUTINE FAGRIB_API_HGEOM_LATLON

SUBROUTINE FAGRIB_API_HGEOM_LAM_GP 

REAL (KIND=JPDBLR) :: ZRPK, ZDELX, ZDELY
INTEGER (KIND=JPLIKB) :: ILONS, ILATS
INTEGER               :: IRET
CHARACTER (LEN=4)     :: CLEXT

ILATS = YLCADR%NLATIT
ILONS = YLCADR%NXLOPA
ZRPK  = YLCADR%SINLAT (2)
ZDELX = YLCADR%SINLAT (7)
ZDELY = YLCADR%SINLAT (8)

IF (LGRIB2_LAM_EX) THEN
  CLEXT = '_lam'
ELSE
  CLEXT = ''
ENDIF

IF (0._JPDBLR < ZRPK .AND. ZRPK < 1._JPDBLR) THEN

! Lambert

  CALL IGRIB_SET_VALUE (KGRIBH, 'gridType', TRIM ('lambert'//CLEXT))

  CALL IGRIB_SET_VALUE (KGRIBH, 'Nx', ILONS)
  CALL IGRIB_SET_VALUE (KGRIBH, 'Ny', ILATS)
  CALL IGRIB_SET_VALUE (KGRIBH, 'DxInMetres', ZDELX)
  CALL IGRIB_SET_VALUE (KGRIBH, 'DyInMetres', ZDELY)

  CALL IGRIB_SET_VALUE (KGRIBH, 'iScansNegatively', 0)
  CALL IGRIB_SET_VALUE (KGRIBH, 'jScansPositively', 1)
  CALL IGRIB_SET_VALUE (KGRIBH, 'jPointsAreConsecutive', 0)
  CALL IGRIB_SET_VALUE (KGRIBH, 'uvRelativeToGrid', 1)

ELSEIF (ZRPK == 0._JPDBLR) THEN

! Mercator

  CALL IGRIB_SET_VALUE (KGRIBH, 'gridType', TRIM ('mercator'//CLEXT))

  CALL IGRIB_SET_VALUE (KGRIBH, 'Nx', ILONS)
  CALL IGRIB_SET_VALUE (KGRIBH, 'Ny', ILATS)
  CALL IGRIB_SET_VALUE (KGRIBH, 'DiInMetres', ZDELX)
  CALL IGRIB_SET_VALUE (KGRIBH, 'DjInMetres', ZDELY)

  CALL IGRIB_SET_VALUE (KGRIBH, 'iScansNegatively', 0)
  CALL IGRIB_SET_VALUE (KGRIBH, 'jScansPositively', 1)
  CALL IGRIB_SET_VALUE (KGRIBH, 'jPointsAreConsecutive', 0)
  CALL IGRIB_SET_VALUE (KGRIBH, 'uvRelativeToGrid', 1)

ELSEIF (ZRPK == 1._JPDBLR) THEN

! Polar stereographic

  CALL IGRIB_SET_VALUE (KGRIBH, 'gridType', TRIM ('polar_stereographic'//CLEXT))

  CALL IGRIB_SET_VALUE (KGRIBH, 'Nx', ILONS)
  CALL IGRIB_SET_VALUE (KGRIBH, 'Ny', ILATS)
  CALL IGRIB_SET_VALUE (KGRIBH, 'DxInMetres', ZDELX)
  CALL IGRIB_SET_VALUE (KGRIBH, 'DyInMetres', ZDELY)

  CALL IGRIB_SET_VALUE (KGRIBH, 'iScansNegatively', 0)
  CALL IGRIB_SET_VALUE (KGRIBH, 'jScansPositively', 1)
  CALL IGRIB_SET_VALUE (KGRIBH, 'jPointsAreConsecutive', 0)

ENDIF

IF (LGRIB2_LAM_EX) THEN
  CALL IGRIB_SET_VALUE (KGRIBH, 'Nux', YLCADR%NLOPAR (4))
  CALL IGRIB_SET_VALUE (KGRIBH, 'Nuy', YLCADR%NLOPAR (6))
  CALL IGRIB_SET_VALUE (KGRIBH, 'Ncx', YLCADR%NLOPAR (7))
  CALL IGRIB_SET_VALUE (KGRIBH, 'Ncy', YLCADR%NLOPAR (8))
ENDIF

CALL FAGRIB_API_HGEOM_LAM_PR 

END SUBROUTINE FAGRIB_API_HGEOM_LAM_GP

SUBROUTINE FAGRIB_API_HGEOM_LAM_PR 

REAL (KIND=JPDBLR) :: ZRPK

ZRPK  = YLCADR%SINLAT (2)

IF (0._JPDBLR < ZRPK .AND. ZRPK < 1._JPDBLR) THEN

! Lambert

  CALL IGRIB_SET_VALUE (KGRIBH, 'latitudeOfFirstGridPointInDegrees',  LATRAD2DEG (YLCADR%SINLAT(14)))
  CALL IGRIB_SET_VALUE (KGRIBH, 'longitudeOfFirstGridPointInDegrees', LONRAD2DEG (YLCADR%SINLAT(13)))
  CALL IGRIB_SET_VALUE (KGRIBH, 'latitudeOfSouthernPoleInDegrees',                         0._JPDBLR)
  CALL IGRIB_SET_VALUE (KGRIBH, 'longitudeOfSouthernPoleInDegrees',                        0._JPDBLR)
  CALL IGRIB_SET_VALUE (KGRIBH, 'LaDInDegrees',                       LATRAD2DEG (YLCADR%SINLAT (4)))
  CALL IGRIB_SET_VALUE (KGRIBH, 'LoVInDegrees',                       LONRAD2DEG (YLCADR%SINLAT (3)))
  CALL IGRIB_SET_VALUE (KGRIBH, 'Latin1InDegrees',                    LATRAD2DEG (YLCADR%SINLAT (4)))
  CALL IGRIB_SET_VALUE (KGRIBH, 'Latin2InDegrees',                    LATRAD2DEG (YLCADR%SINLAT (4)))

  IF (YLCADR%SINLAT (4) > 0) THEN
  CALL IGRIB_SET_VALUE (KGRIBH, 'projectionCentreFlag',                                            0)
  ELSE
  CALL IGRIB_SET_VALUE (KGRIBH, 'projectionCentreFlag',                                          128)
  ENDIF

ELSEIF (ZRPK == 0._JPDBLR) THEN

! Mercator

  CALL IGRIB_SET_VALUE (KGRIBH, 'latitudeOfFirstGridPointInDegrees',  LATRAD2DEG (YLCADR%SINLAT(14)))
  CALL IGRIB_SET_VALUE (KGRIBH, 'longitudeOfFirstGridPointInDegrees', LONRAD2DEG (YLCADR%SINLAT(13)))
  CALL IGRIB_SET_VALUE (KGRIBH, 'LaDInDegrees',                       LATRAD2DEG (YLCADR%SINLAT (4)))
  CALL IGRIB_SET_VALUE (KGRIBH, 'latitudeOfLastGridPointInDegrees',   LATRAD2DEG (YLCADR%SINLAT(16)))
  CALL IGRIB_SET_VALUE (KGRIBH, 'longitudeOfLastGridPointInDegrees',  LONRAD2DEG (YLCADR%SINLAT(15)))
  CALL IGRIB_SET_VALUE (KGRIBH, 'orientationOfTheGridInDegrees',                           0._JPDBLR)

ELSEIF (ZRPK == 1._JPDBLR) THEN

! Polar stereographic

  CALL IGRIB_SET_VALUE (KGRIBH, 'latitudeOfFirstGridPointInDegrees',  LATRAD2DEG (YLCADR%SINLAT(14)))
  CALL IGRIB_SET_VALUE (KGRIBH, 'longitudeOfFirstGridPointInDegrees', LONRAD2DEG (YLCADR%SINLAT(13)))

  CALL IGRIB_SET_VALUE (KGRIBH, 'LaDInDegrees',                       LATRAD2DEG (YLCADR%SINLAT (4)))
  CALL IGRIB_SET_VALUE (KGRIBH, 'orientationOfTheGridInDegrees',      LONRAD2DEG (YLCADR%SINLAT (3)))

  IF (YLCADR%SINLAT (4) > 0) THEN
  CALL IGRIB_SET_VALUE (KGRIBH, 'projectionCentreFlag',                                            0)
  ELSE
  CALL IGRIB_SET_VALUE (KGRIBH, 'projectionCentreFlag',                                          128)
  ENDIF

ENDIF

END SUBROUTINE FAGRIB_API_HGEOM_LAM_PR


REAL (KIND=JPDBLR) FUNCTION LONRAD2DEG (PLON)
REAL (KIND=JPDBLR), INTENT (IN) :: PLON
LONRAD2DEG = MODULO (180._JPDBLR/RPI * PLON, 360._JPDBLR)
END FUNCTION LONRAD2DEG

REAL (KIND=JPDBLR) FUNCTION LATRAD2DEG (PLAT)
REAL (KIND=JPDBLR), INTENT (IN) :: PLAT
LATRAD2DEG = 180._JPDBLR/RPI * PLAT
END FUNCTION LATRAD2DEG

SUBROUTINE FAGRIB_API_HGEOM_GLO_GP 

INTEGER (KIND=JPLIKB) :: ILATS, IDGNH, ILONS
INTEGER (KIND=JPLIKB), ALLOCATABLE :: ILOENG (:)
REAL (KIND=JPDBLR) :: ZNLAT, ZSLAT, ZVAL, ZLOCEN, ZMUCEN, ZSTRET
CHARACTER (LEN=32), PARAMETER :: CLGGGRIDTYPES (0:1,0:1,0:1) =                &
  & RESHAPE (                                                                 & 
  & (/ 'regular_gg                    ', 'reduced_gg                    ',    &
  &    'regular_stretched_gg          ', 'reduced_stretched_gg          ',    &
  &    'regular_rotated_gg            ', 'reduced_rotated_gg            ',    &
  &    'regular_stretched_rotated_gg  ', 'reduced_stretched_rotated_gg  ' /), &
  & (/ 2, 2, 2 /))
INTEGER (KIND=JPLIKB) :: ISTR, IROT, IRED, I

ISTR = 1_JPLIKB
IROT = 1_JPLIKB

ZMUCEN = YLCADR%SSLAPO
IF (ABS (ZMUCEN - 1._JPDBLR) < 1E-5_JPDBLR) IROT = 0
ZLOCEN = SIGN (ACOS (YLCADR%SCLOPO), YLCADR%SSLOPO) 
ZSTRET = YLCADR%SCODIL
IF (ABS (ZSTRET - 1._JPDBLR) < 1E-5_JPDBLR) ISTR = 0

CALL IGRIB_SET_VALUE (KGRIBH, 'interpretationOfNumberOfPoints', 1)
CALL IGRIB_SET_VALUE (KGRIBH, 'global',                         1)

ILATS = YLCADR%NLATIT
ILONS = YLCADR%NXLOPA
IDGNH = (ILATS+1) / 2
ZNLAT = ASIN (YLCADR%SINLAT (1))
ZSLAT = - ZNLAT

ALLOCATE (ILOENG (ILATS))

DO I = 1, ILATS
  IF (I <= IDGNH) THEN
    ILOENG (I) = YLCADR%NLOPAR (I)
  ELSE
    ILOENG (I) = YLCADR%NLOPAR (ILATS-I+1)
  ENDIF
ENDDO

IF (ANY (ILOENG /= ILOENG (1))) THEN
  IRED = 1
ELSE
  IRED = 0
ENDIF

CALL IGRIB_SET_VALUE (KGRIBH, 'gridType', TRIM (CLGGGRIDTYPES (IRED, ISTR, IROT)))

IF (IRED == 0) THEN
  CALL IGRIB_SET_VALUE(KGRIBH,'numberOfPointsAlongAParallel',ILONS)
  ZVAL = 360.0_JPDBLR/REAL (ILONS, JPDBLR)
  CALL IGRIB_SET_VALUE(KGRIBH,'iDirectionIncrementInDegrees',ZVAL)
ELSE
  CALL IGRIB_SET_VALUE(KGRIBH,'pl',ILOENG(1:ILATS))
ENDIF

DEALLOCATE (ILOENG)

CALL IGRIB_SET_VALUE(KGRIBH,'truncateDegrees',1)
CALL IGRIB_SET_VALUE(KGRIBH,'numberOfPointsAlongAMeridian',ILATS)
ZVAL = LATRAD2DEG (ZNLAT)
CALL IGRIB_SET_VALUE(KGRIBH,'latitudeOfFirstGridPointInDegrees',ZVAL)
CALL IGRIB_SET_VALUE(KGRIBH,'longitudeOfFirstGridPointInDegrees',0)
ZVAL = LATRAD2DEG (ZSLAT)
CALL IGRIB_SET_VALUE(KGRIBH,'latitudeOfLastGridPointInDegrees',ZVAL)
ZVAL=360._JPDBLR-360._JPDBLR/REAL(ILONS,JPDBLR)
CALL IGRIB_SET_VALUE(KGRIBH,'longitudeOfLastGridPointInDegrees',ZVAL)
CALL IGRIB_SET_VALUE(KGRIBH,'numberOfParallelsBetweenAPoleAndTheEquator',IDGNH)


IF (ISTR > 0) THEN
  CALL IGRIB_SET_VALUE(KGRIBH,'stretchingFactor',ZSTRET)
ENDIF

IF (IROT > 0) THEN
  CALL IGRIB_SET_VALUE(KGRIBH,'latitudeOfStretchingPoleInDegrees', LATRAD2DEG (ASIN(ZMUCEN)))
  CALL IGRIB_SET_VALUE(KGRIBH,'longitudeOfStretchingPoleInDegrees', LONRAD2DEG (ZLOCEN))
ENDIF

END SUBROUTINE FAGRIB_API_HGEOM_GLO_GP

SUBROUTINE FAGRIB_API_HGEOM_GLO_SH 

REAL (KIND=JPDBLR) :: ZLOCEN, ZMUCEN, ZSTRET
CHARACTER (LEN=32), PARAMETER :: CLSHGRIDTYPES (0:1,0:1) =                    &
  & RESHAPE (                                                                 &
  & (/ 'sh                            ', 'stretched_sh                  ',    &
  &    'rotated_sh                    ', 'stretched_rotated_sh          ' /), &
  & (/ 2, 2 /))
INTEGER (KIND=JPLIKB) :: ISTR, IROT, IRED, ISMAX

ISTR = MIN (YLCADR%NTYPTR, 1)
IROT = MAX (YLCADR%NTYPTR-1, 0)

ZMUCEN = YLCADR%SSLAPO
ZLOCEN = SIGN (ACOS (YLCADR%SCLOPO), YLCADR%SSLOPO) 
ZSTRET = YLCADR%SCODIL

CALL IGRIB_SET_VALUE (KGRIBH, 'gridType', TRIM (CLSHGRIDTYPES (ISTR, IROT)))

ISMAX = YLCADR%MTRONC
CALL IGRIB_SET_VALUE (KGRIBH, 'pentagonalResolutionParameterJ', ISMAX)
CALL IGRIB_SET_VALUE (KGRIBH, 'pentagonalResolutionParameterK', ISMAX)
CALL IGRIB_SET_VALUE (KGRIBH, 'pentagonalResolutionParameterM', ISMAX)

IF (ISTR > 0) THEN
  CALL IGRIB_SET_VALUE(KGRIBH,'stretchingFactor',ZSTRET)
ENDIF

IF (IROT > 0) THEN
  CALL IGRIB_SET_VALUE(KGRIBH,'latitudeOfStretchingPoleInDegrees', LATRAD2DEG (ASIN(ZMUCEN)))
  CALL IGRIB_SET_VALUE(KGRIBH,'longitudeOfStretchingPoleInDegrees', LONRAD2DEG (ZLOCEN))
ENDIF

END SUBROUTINE FAGRIB_API_HGEOM_GLO_SH

SUBROUTINE FAGRIB_API_VGEOM 

REAL (KIND=JPDBLR), ALLOCATABLE :: ZVERT (:)
INTEGER (KIND=JPLIKB) :: IFLEVG

IF (CDPREF == 'S') THEN
  IFLEVG = YLCADR%NNIVER
  ALLOCATE (ZVERT (2*(IFLEVG+1)))
  ZVERT (1:IFLEVG+1)            = YLCADR%SFOHYB (1,0:IFLEVG) * YLCADR%SPREFE
  ZVERT (IFLEVG+2:2*(IFLEVG+1)) = YLCADR%SFOHYB (2,0:IFLEVG)
  CALL IGRIB_SET_VALUE (KGRIBH, 'pv', ZVERT)                        
  DEALLOCATE (ZVERT)
ELSE
  CALL IGRIB_SET_VALUE (KGRIBH, 'deletePV', 1)
ENDIF

END SUBROUTINE FAGRIB_API_VGEOM

SUBROUTINE FAGRIB_API_DATE 

INTEGER (KIND=JPLIKB) :: IDATEF (22)
INTEGER (KIND=JPLIKB) :: ITRI, IRANGE,IUNITRANGE, ITYPGP
LOGICAL :: LTEST
CHARACTER (LEN=16) :: CTERMU


IDATEF(1:FA%JPLDAT)             = YLFICH%MADATE(:)
IDATEF(FA%JPLDAT+1:FA%JPLDAT*2) = YLFICH%MADATX(:)

IF (LLGRIB1) THEN
  CALL IGRIB_SET_VALUE (KGRIBH, 'yearOfCentury',  IDATEF ( 1)-2000)
ELSE
  CALL IGRIB_SET_VALUE (KGRIBH, 'year',  IDATEF ( 1))
ENDIF

CALL IGRIB_SET_VALUE (KGRIBH, 'month', IDATEF ( 2))
CALL IGRIB_SET_VALUE (KGRIBH, 'day',   IDATEF ( 3))
CALL IGRIB_SET_VALUE (KGRIBH, 'hour',  IDATEF ( 4))
CALL IGRIB_SET_VALUE (KGRIBH, 'minute',IDATEF ( 5))
CALL IGRIB_SET_VALUE (KGRIBH, 'second',IDATEF (14)-60*(IDATEF (5)+60*IDATEF (4)))

CALL IGRIB_GET_VALUE (KGRIBH, 'indicatorOfUnitOfTimeRange', CTERMU)
CALL IGRIB_SET_VALUE (KGRIBH, 'stepUnits', CTERMU)
CALL IGRIB_GET_VALUE (KGRIBH, 'LSTCUM', ISTCUM)

IF (LLGRIB1) THEN

  CALL IGRIB_GET_VALUE (KGRIBH, 'timeRangeIndicator', ITRI)

  IF (ITRI /= 0 .AND. ISTCUM == 0) THEN
    CALL FAGRIB_SETTIME ('P1', IDATEF (16), CTERMU)
    CALL FAGRIB_SETTIME ('P2', IDATEF (15), CTERMU)
  ELSEIF (ITRI /= 0 .AND. ISTCUM == 1) THEN
    CALL FAGRIB_SETTIME ('P1',           0_JPLIKB, CTERMU)
    CALL FAGRIB_SETTIME ('P2', IDATEF (15), CTERMU)
  ELSEIF (ITRI == 0 .AND. IDATEF (15) == 0) THEN
    CALL IGRIB_SET_VALUE (KGRIBH, 'timeRangeIndicator', 1_JPIM)
  ELSEIF (ITRI == 0) THEN
    CALL FAGRIB_SETTIME ('P1', IDATEF (15), CTERMU)
  ELSE
    KREP = -82
    RETURN
  ENDIF
ELSE
  CALL IGRIB_GET_VALUE (KGRIBH, 'productDefinitionTemplateNumber', ITRI)
  CALL IGRIB_GET_VALUE (KGRIBH, 'typeOfGeneratingProcess', ITYPGP)
    !IF (ITYPGP==2) THEN
    !  IF (IDATEF(15)==0) THEN
    !   CALL IGRIB_SET_VALUE (KGRIBH, 'typeOfGeneratingProcess', 2)
    !   CALL IGRIB_SET_VALUE (KGRIBH, 'typeOfProcessedData', 1)
    !  ELSE 
    !   CALL IGRIB_SET_VALUE (KGRIBH, 'typeOfGeneratingProcess', 2)
    !   CALL IGRIB_SET_VALUE (KGRIBH, 'typeOfProcessedData', 1)
    !  END IF
    !END IF

  IF (ITRI /= 0 .AND. ISTCUM == 0) THEN
    CALL FAGRIB_SETTIME ('startStep', IDATEF (16), CTERMU)
    CALL FAGRIB_SETTIME ('endStep',   IDATEF (15), CTERMU)
  ELSEIF (ITRI /= 0 .AND. ISTCUM == 1) THEN
    CALL FAGRIB_SETTIME ('startStep',           0_JPLIKB, CTERMU)
    CALL FAGRIB_SETTIME ('endStep',   IDATEF (15), CTERMU)
    !CALL IGRIB_SET_VALUE (KGRIBH, 'typeOfProcessedData', 1)
    CALL IGRIB_GET_VALUE (KGRIBH, 'indicatorOfUnitOfTimeRange', IUNITRANGE)
    IF (IUNITRANGE==1) THEN
    ELSEIF (IUNITRANGE==0) THEN
      CALL IGRIB_SET_VALUE (KGRIBH, 'lengthOfTimeRange', 15)
      CALL IGRIB_SET_VALUE (KGRIBH, 'numberOfTimeRange', IDATEF(15)/(15*60))
    END IF
  ELSEIF (ITRI /= 0 .AND. ISTCUM == 2) THEN
    CALL IGRIB_GET_VALUE (KGRIBH, 'indicatorOfUnitOfTimeRange', IUNITRANGE)
    IF (IUNITRANGE==1) THEN
      CALL IGRIB_GET_VALUE (KGRIBH, 'lengthOfTimeRange', IRANGE)
    !again dirty fix, need to suppose that IDATEF(15) is in seconds and IRANGE in
    !hours
      CALL FAGRIB_SETTIME ('startStep', IDATEF(15)-IRANGE*3600 , CTERMU)
      CALL FAGRIB_SETTIME ('endStep',   IDATEF (15), CTERMU)
    ELSEIF (IUNITRANGE==0) THEN
      CALL IGRIB_GET_VALUE (KGRIBH, 'lengthOfTimeRange', IRANGE)
    !again dirty fix, need to suppose that IDATEF(15) is in seconds and IRANGE in
    !hours
      CALL FAGRIB_SETTIME ('startStep', IDATEF(15)-IRANGE*60 , CTERMU)
      CALL FAGRIB_SETTIME ('endStep',   IDATEF (15), CTERMU)
    END IF
  ELSEIF (ITRI == 0 .AND. IDATEF (15) == 0) THEN
    CALL FAGRIB_SETTIME ('endStep',   IDATEF (15), CTERMU)
  ELSEIF (ITRI == 0) THEN
    CALL FAGRIB_SETTIME ('endStep',   IDATEF (15), CTERMU)
  ELSE
    KREP = -82
    RETURN
  ENDIF
ENDIF

END SUBROUTINE FAGRIB_API_DATE

SUBROUTINE FAGRIB_SETTIME (CDKEY, KSECS, CDUNIT)

CHARACTER (LEN=*)     :: CDKEY, CDUNIT
INTEGER (KIND=JPLIKB) :: KSECS
INTEGER (KIND=JPLIKB) :: IVALUE

IVALUE = 0

SELECT CASE (CDUNIT)
  CASE ('s')
    IVALUE = KSECS 
  CASE ('D')
    IVALUE = KSECS / (  1 *   1 * 24 * 60 * 60)
  CASE ('M')
    IVALUE = KSECS / (  1 *  30 * 24 * 60 * 60)
  CASE ('Y')
    IVALUE = KSECS / (  1 * 365 * 24 * 60 * 60)
  CASE ('10Y')
    IVALUE = KSECS / ( 10 * 365 * 24 * 60 * 60)
  CASE ('30Y')
    IVALUE = KSECS / ( 30 * 365 * 24 * 60 * 60)
  CASE ('C')
    IVALUE = KSECS / (100 * 365 * 24 * 60 * 60)
  CASE ('h')
    IVALUE = KSECS / (  1 *   1 *  1 * 60 * 60)
  CASE ('3h')
    IVALUE = KSECS / (  1 *   1 *  3 * 60 * 60)
  CASE ('6h')
    IVALUE = KSECS / (  1 *   1 *  6 * 60 * 60)
  CASE ('12h')
    IVALUE = KSECS / (  1 *   1 * 12 * 60 * 60)
  CASE ('m')
    IVALUE = KSECS / (  1 *   1 *  1 *  1 * 60)
  CASE ('15m')
    IVALUE = KSECS / (  1 *   1 *  1 * 15 * 60)
  CASE ('30m')
    IVALUE = KSECS / (  1 *   1 *  1 * 30 * 60)
  CASE DEFAULT
    KREP = -82
    RETURN
END SELECT

CALL IGRIB_SET_VALUE (KGRIBH, CDKEY, IVALUE)

END SUBROUTINE FAGRIB_SETTIME

SUBROUTINE FAGRIB_API_SET_VALUES 

REAL (KIND=JPDBLR), TARGET, ALLOCATABLE :: ZCHAMT (:) ! Temporary array for swapping directions of lat/lon fields
REAL (KIND=JPDBLR), TARGET, ALLOCATABLE :: ZCHAMS (:) ! PCHAMP * FMULTI
REAL (KIND=JPDBLR), POINTER             :: ZCHAMP (:) ! Point either to PCHAMP or ZCHAMS


INTEGER (KIND=JPLIKB) :: ISMAX, IISMAX
INTEGER (KIND=JPLIKB) :: JN, IDX, JLON, JLAT, ILCHAM, ISTRF, ICUNDF
INTEGER (KIND=JPLIKB) :: IDECOPT
INTEGER (KIND=JPLIKB) :: INBITSMAX, IMAXIPREC
REAL (KIND=JPDBLR) :: ZUNDF, ZRNG, ZMIN, ZMAX
LOGICAL :: LLHSDF

IF (LLDOUBLE) THEN
  INBITSMAX = 64
  IMAXIPREC =  2
ELSE
  INBITSMAX = 32
  IMAXIPREC =  1
ENDIF

IF (LLCOSP) THEN
  IF (LLMLAM) THEN
    ILCHAM = YLCADR%NSFLAM
  ELSE    
    ILCHAM=(1+YLCADR%MTRONC)*(2+YLCADR%MTRONC)
  ENDIF   
ELSE
  ILCHAM = YLCADR%NVAPDG
ENDIF

! Changement d'echelle pour certains champs

ZUNDF = PUNDF
IF (ZMULTI /= REAL (1._4, JPDBLR)) THEN
  ALLOCATE (ZCHAMS (ILCHAM))
  ZCHAMS =  PCHAMP (1:ILCHAM) * ZMULTI
  ZUNDF  =  ZUNDF             * ZMULTI
  ZCHAMP => ZCHAMS (1:ILCHAM)
ELSE
  ZCHAMP => PCHAMP (1:ILCHAM)
ENDIF

!
! Traitement des valeurs indefinies; on verifie d'abord que le champ
! contient de telles valeurs afin d'eviter de polluer le resultat
! final avec un bitmap inutile
!
LLHSDF = .TRUE.
IF (LLUNDF) THEN
  ICUNDF = COUNT (ZCHAMP == ZUNDF)
  LLUNDF = ICUNDF > 0
  LLHSDF = ICUNDF < ILCHAM
ELSE
  ICUNDF = 0
ENDIF


IF (LLCOSP) THEN

  INBITS = MIN (YLFICH%NBFCSP, INBITSMAX)

  IF (LLMGLO) THEN

    IF (INBITS == INBITSMAX) THEN
      ISTRF = YLCADR%MTRONC
    ELSE
      ISTRF = YLFICH%NSTROF
    ENDIF
   
    CALL IGRIB_SET_VALUE (KGRIBH, 'bitsPerValue', INBITS)
    CALL IGRIB_SET_VALUE (KGRIBH, 'packingType', 'spectral_complex')
    CALL IGRIB_SET_VALUE (KGRIBH, 'optimizeScaleFactor', 1)
   
    CALL IGRIB_SET_VALUE (KGRIBH, 'subSetJ', ISTRF)
    CALL IGRIB_SET_VALUE (KGRIBH, 'subSetK', ISTRF)
    CALL IGRIB_SET_VALUE (KGRIBH, 'subSetM', ISTRF)

    CALL IGRIB_SET_VALUE (KGRIBH, 'unpackedSubsetPrecision', IMAXIPREC)
   
    CALL IGRIB_SET_VALUE (KGRIBH, 'values', ZCHAMP (1:ILCHAM))

  ELSEIF (LLMLAM) THEN

    ISTRF = YLFICH%NSTROF

    CALL IGRIB_SET_VALUE (KGRIBH, "bitsPerValue", INBITS)
    CALL IGRIB_SET_VALUE (KGRIBH, "packingType", "bifourier_complex")
    CALL IGRIB_SET_VALUE (KGRIBH, 'optimizeScaleFactor', 1)

    IF (INBITS == INBITSMAX) THEN
      ISMAX  = YLCADR%NSMAX
      IISMAX = YLCADR%MTRONC
      CALL IGRIB_SET_VALUE (KGRIBH, "biFourierResolutionSubSetParameterN", ISMAX)
      CALL IGRIB_SET_VALUE (KGRIBH, "biFourierResolutionSubSetParameterM", IISMAX)
      CALL IGRIB_SET_VALUE (KGRIBH, "biFourierSubTruncationType", 99) 
    ELSE
      CALL IGRIB_SET_VALUE (KGRIBH, "biFourierResolutionSubSetParameterN", ISTRF)
      CALL IGRIB_SET_VALUE (KGRIBH, "biFourierResolutionSubSetParameterM", ISTRF)
      CALL IGRIB_SET_VALUE (KGRIBH, "biFourierSubTruncationType", 77) 
    ENDIF

    CALL IGRIB_SET_VALUE (KGRIBH, "biFourierDoNotPackAxes", 1)
  
    CALL IGRIB_SET_VALUE (KGRIBH, "unpackedSubsetPrecision", IMAXIPREC)

    CALL IGRIB_SET_VALUE (KGRIBH, 'values', ZCHAMP (1:ILCHAM))

  ENDIF

ELSE

  INBITS = MIN (YLFICH%NBFPDG, INBITSMAX)

  IF (INBITS == INBITSMAX) THEN
    IF (LLGRIB1) THEN
      IF (LLDOUBLE) THEN
        INBITS = 63 ! 64bit simple packing does not work with grib_api
      ENDIF
      CALL IGRIB_SET_VALUE (KGRIBH, 'bitsPerValue', INBITS)
      CALL IGRIB_SET_VALUE (KGRIBH, 'packingType', 'grid_simple')
      CALL IGRIB_SET_VALUE (KGRIBH, 'optimizeScaleFactor', 1)
    ELSE
      CALL IGRIB_SET_VALUE (KGRIBH, 'packingType', 'grid_ieee')
      CALL IGRIB_SET_VALUE (KGRIBH, 'precision', IMAXIPREC)
    ENDIF
  ELSE
    CALL IGRIB_SET_VALUE (KGRIBH, 'bitsPerValue', INBITS)
    SELECT CASE (INGRIB)
      CASE (120, 160)
        CALL IGRIB_SET_VALUE (KGRIBH, 'packingType', 'grid_simple')
      CASE (140, 180) 
        IF (INBITS > 30) THEN ! grib_api does appear to support 2nd order packing with more than 30 bits
          CALL IGRIB_SET_VALUE (KGRIBH, 'packingType', 'grid_simple')
        ELSE
          CALL IGRIB_SET_VALUE (KGRIBH, 'packingType', 'grid_second_order')
        ENDIF
      CASE (200)
        CALL IGRIB_SET_VALUE (KGRIBH, 'packingType', 'grid_complex_spatial_differencing')
        CALL IGRIB_SET_VALUE (KGRIBH, 'orderOfSpatialDifferencing', 2)
      CASE DEFAULT
        KREP = -96
        RETURN
    END SELECT
    CALL IGRIB_SET_VALUE (KGRIBH, 'optimizeScaleFactor', 1)
  ENDIF

  IF (LLUNDF) THEN
    CALL IGRIB_SET_VALUE (KGRIBH, 'bitmapPresent', 1)
    CALL IGRIB_SET_VALUE (KGRIBH, 'missingValue', ZUNDF)
  ENDIF

  IF (.NOT. LLGRIB1) THEN
! This line should not be necessary, but sometimes grib_api fails to update numberOfDataPoints
    CALL IGRIB_SET_VALUE (KGRIBH, 'numberOfDataPoints', ILCHAM-ICUNDF) 
  ENDIF

  IF (LLLTLN) THEN

    ALLOCATE (ZCHAMT (ILCHAM))

    DO JLAT = 1, YLCADR%NLATIT
      DO JLON = 1, YLCADR%NXLOPA
        JN  = JLON+YLCADR%NXLOPA*(JLAT-1)
        IDX = JLON+YLCADR%NXLOPA*(YLCADR%NLATIT-JLAT)
        ZCHAMT (IDX) = ZCHAMP (JN)
      ENDDO
    ENDDO


    CALL IGRIB_SET_VALUE (KGRIBH, 'values', ZCHAMT)

    DEALLOCATE (ZCHAMT)

  ELSE
    CALL IGRIB_SET_VALUE (KGRIBH, 'values', ZCHAMP (1:ILCHAM))
  ENDIF

ENDIF

IF (ALLOCATED (ZCHAMS)) DEALLOCATE (ZCHAMS)

END SUBROUTINE FAGRIB_API_SET_VALUES

SUBROUTINE FAGRIB_SET_LOCAL_SECTION 

CALL IGRIB_SET_VALUE (KGRIBH, 'CLNOMA', TRIM (CLNOMA (1:ILNOMA)))
CALL IGRIB_SET_VALUE (KGRIBH, 'INGRIB', INGRIB)
IF (LLCOSP) THEN
  CALL IGRIB_SET_VALUE (KGRIBH, 'LLCOSP', 1)
ELSE
  CALL IGRIB_SET_VALUE (KGRIBH, 'LLCOSP', 0)
ENDIF
CALL IGRIB_SET_VALUE (KGRIBH, 'INBITS', INBITS)

END SUBROUTINE FAGRIB_SET_LOCAL_SECTION

FUNCTION RROUND16(PVA) RESULT(PVAR)
REAL (KIND=JPDBLR)    :: PVA,PVAR
PVAR=NINT(PVA*10000000.,SELECTED_INT_KIND(16))/10000000.
END FUNCTION RROUND16


END SUBROUTINE

