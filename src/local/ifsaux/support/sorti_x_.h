
#ifdef _OPENMP
USE OMP_LIB      
#endif

USE PARKIND1

IMPLICIT NONE

INTEGER (KIND=JPKIND) :: N
INTEGER (KIND=JPKIND) :: ORD (N)
INTEGER (KIND=JPKIND) :: A (W, N) 

INTEGER (KIND=JPKIND) :: NT, IT, I1, I2, IN, NR, JJ
INTEGER (KIND=JPKIND), ALLOCATABLE :: IOFF (:)


NT = OMP_GET_MAX_THREADS ()

NR = NT
ALLOCATE (IOFF (NR+1))
IOFF (NR+1) = N


!$OMP PARALLEL PRIVATE (IT, I1, I2, IN)

IT = OMP_GET_THREAD_NUM ()

I1 = 1 + ((IT + 0) * N) / NT
I2 =     ((IT + 1) * N) / NT
IN = I2 - I1 + 1

CALL QSORT (IN, ORD (I1:I2), A (1:W,I1:I2))

ORD (I1:I2) = I1 - 1 + ORD (I1:I2)

IOFF (IT+1) = I1-1

!$OMP END PARALLEL

CALL DO_MERGE (NR, IOFF)

CONTAINS

SUBROUTINE DO_MERGE (KR, KOFF)

INTEGER (KIND=JPKIND) :: KR, KOFF (KR+1)
INTEGER (KIND=JPKIND) :: IR

DO WHILE (KR > 1)

!$OMP PARALLEL DO PRIVATE (IR)
  DO IR = 1, KR, 2
    IF (IR + 1 <= KR) THEN
      CALL MERGE (KOFF (IR+0), KOFF (IR+1), KOFF (IR+2))
    ENDIF
  ENDDO
!$OMP END PARALLEL DO
  
  DO IR = 1, KR/2+1
    KOFF (IR) = KOFF (1+2*(IR-1))
  ENDDO

  IF (MODULO (KR, 2) == 1) THEN
    KOFF (KR/2+2) = KOFF (KR+1)
    KR = KR/2+1
  ELSE
    KOFF (KR/2+1) = KOFF (KR+1)
    KR = KR/2
  ENDIF

ENDDO

END SUBROUTINE

SUBROUTINE MERGE (K1, K2, K3)

INTEGER (KIND=JPKIND) :: K1, K2, K3
INTEGER (KIND=JPKIND) :: I1, I2, II
INTEGER (KIND=JPKIND) :: J1, J2
INTEGER (KIND=JPKIND) :: IORD1 (K2-K1)
INTEGER (KIND=JPKIND) :: IORD2 (K3-K2)

IORD1 = ORD (K1+1:K2)
IORD2 = ORD (K2+1:K3)

J1 = K2-K1
J2 = K3-K2

I1 = 1
I2 = 1
II = 1

DO WHILE (I1 <= J1 .AND. I2 <= J2)
  IF (LE (A (1:W,IORD1 (I1)), A (1:W,IORD2 (I2)))) THEN
    ORD (K1+II) = IORD1 (I1)
    I1 = I1 + 1
  ELSE
    ORD (K1+II) = IORD2 (I2)
    I2 = I2 + 1
  ENDIF
  II = II + 1
ENDDO

DO WHILE (I1 <= J1)
  ORD (K1+II) = IORD1 (I1)
  II = II + 1
  I1 = I1 + 1
ENDDO

DO WHILE (I2 <= J2)
  ORD (K1+II) = IORD2 (I2)
  II = II + 1
  I2 = I2 + 1
ENDDO

IF (II /= K3-K1+1) STOP 1

END SUBROUTINE 

