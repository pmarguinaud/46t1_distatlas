MODULE MODD_IO_SURF_ARO

USE MODD_SURF_PAR, ONLY : XUNDEF, NUNDEF
USE PARKIND1, ONLY : JPRB, JPRD, JPIB, JPIM
USE YOMHOOK, ONLY : LHOOK, DR_HOOK

USE IOFLDDESC_MOD, ONLY : IOFLDDESC, NSUFFLEN, NPREFLEN
USE IOCPTDESC_MOD, ONLY : IOCPTDESC

IMPLICIT NONE
SAVE
INTEGER (KIND=JPIM) :: NLUOUT      ! output listing logical unit
INTEGER (KIND=JPIM), DIMENSION(3)  :: NDATE_IN = (/ NUNDEF, NUNDEF, NUNDEF /)
REAL (KIND=JPRB)    :: XTIME_IN = XUNDEF

CHARACTER (LEN=6)   :: CMASK

INTEGER (KIND=JPIM), DIMENSION(:), POINTER :: NMASK ! 1D mask to read only interesting
!$OMP THREADPRIVATE(NMASK)

! projection parameters
REAL (KIND=JPRB)    :: XRPK, XLON0, XBETA

CHARACTER (LEN=6)   :: CMODE            ! Configuration in which the surface is used
                                           ! 'RUN' (NCONF=01), 'PRE' (NCONF=927)
INTEGER (KIND=JPIM) :: NGPTOTG !Total number of grid columns on the Globe
! full dimension for 1 proc
INTEGER (KIND=JPIM) :: NGPTOT
INTEGER (KIND=JPIM) :: NGPTOT_CAP
! dimension of arrays in NPROMA loop
INTEGER (KIND=JPIM) :: NPROMA
INTEGER (KIND=JPIM) :: NBLOCKTOT ! total of NPROMA blocks
INTEGER (KIND=JPIM) :: NBLOCK ! NPROMA loop index
!$OMP THREADPRIVATE(NBLOCK)
INTEGER (KIND=JPIM) :: NKPROMA! size of array (=NPROMA except for latest NBLOCK loop index)
!$OMP THREADPRIVATE(NKPROMA)
INTEGER (KIND=JPIM) :: NINDX1 ! start index for current NPROMA loop array
!$OMP THREADPRIVATE(NINDX1)
INTEGER (KIND=JPIM) :: NINDX2 ! end   index for current NPROMA loop array
!$OMP THREADPRIVATE(NINDX2)
!
! number of the procs
INTEGER (KIND=JPIM) :: NPROC = 1
! number of the actual proc
INTEGER (KIND=JPIM) :: MYPROC = 1
!

CHARACTER (LEN=4),    PARAMETER :: CPREFIX_SFX1 = 'SFX.',&
                                 & CPREFIX_SFX2 = 'X'
INTEGER (KIND=JPIM),  PARAMETER :: NBPDG = 16

! Cache of SURFEX fields to avoid reading several times from disk

TYPE SURFEX_FIELD_TIME
  INTEGER (KIND=JPIM) :: KYEAR
  INTEGER (KIND=JPIM) :: KMONTH
  INTEGER (KIND=JPIM) :: KDAY
  REAL (KIND=JPRB)    :: PTIME
END TYPE

TYPE SURFEX_FIELD_X
  REAL (KIND=JPRB), POINTER :: P (:) => NULL ()
  INTEGER (KIND=JPIM)       :: IRANK = 0
END TYPE

TYPE SURFEX_FIELD_BUF

  CHARACTER (LEN=32)  :: NAME = ''
  CHARACTER (LEN=2)   :: TYPE = ''
  CHARACTER (LEN=16)  :: MASK = ''
  INTEGER (KIND=JPIM) :: NDIM(2) = (/ -1, -1 /)
  INTEGER (KIND=JPIM) :: IUNIT = -1
  INTEGER (KIND=JPIM) :: IFILE = -1
  LOGICAL             :: LREAD = .FALSE.

  TYPE (SURFEX_FIELD_TIME)           :: T0
  TYPE (SURFEX_FIELD_TIME), POINTER  :: T1 (:) => NULL ()
  CHARACTER (LEN=40)                 :: C0
  INTEGER (KIND=JPIM)                :: N0
  INTEGER (KIND=JPIM),     POINTER   :: N1(:) => NULL()
  LOGICAL                            :: L0
  LOGICAL,                 POINTER   :: L1(:) => NULL()
  REAL (KIND=JPRB),        POINTER   :: Y1(:) => NULL()
  REAL (KIND=JPRB)                   :: X0
  TYPE (SURFEX_FIELD_X)              :: S_FX1
  TYPE (SURFEX_FIELD_X),   POINTER   :: S_FX2 (:) => NULL ()

END TYPE

INTEGER (KIND=JPIM), PARAMETER :: NFASUFFLEN = 16

TYPE SURFEX_FIELD_BUF_CACHE
! PRIVATE
  LOGICAL :: LDUMMY  = .FALSE.
  LOGICAL :: LRECORD = .TRUE.
! These arrays are used to pack fields into a single 2D array
  REAL (KIND=JPRB),         POINTER :: PBUF_FIELDS (:,:) => NULL ()
  INTEGER (KIND=JPIM),      POINTER :: NBUF_FUNITS (:)   => NULL ()
  INTEGER (KIND=JPIM),      POINTER :: NBUF_FFILES (:)   => NULL ()
  TYPE (IOFLDDESC),         POINTER :: YIOFLDDESC  (:)   => NULL ()
  INTEGER (KIND=JPIM)               :: N      = 0
  INTEGER (KIND=JPIM)               :: NTOT   = 0
  TYPE (SURFEX_FIELD_BUF),  POINTER :: P(:) => NULL()
  LOGICAL :: LALL_METADATA = .FALSE.
END TYPE


TYPE (SURFEX_FIELD_BUF_CACHE), POINTER :: YSURFEX_CACHE_IN => NULL () ! read fields
TYPE (SURFEX_FIELD_BUF_CACHE), TARGET  :: YSURFEX_CACHE_IN_IO_SURF
TYPE (SURFEX_FIELD_BUF_CACHE), TARGET  :: YSURFEX_CACHE_IN_AUX_IO_SURF

TYPE (SURFEX_FIELD_BUF_CACHE) :: YSURFEX_CACHE_OUT           ! write fields

TYPE (SURFEX_FIELD_BUF_CACHE) :: YSURFEX_CACHE_IN_CLIMO_DEP  ! read fields (output clim); should be moved somewhere else

INTERFACE SURFEX_FIELD_BUF_ADD
  MODULE PROCEDURE&
    & SURFEX_FIELD_BUF_ADD_T0,&
    & SURFEX_FIELD_BUF_ADD_T1,&
    & SURFEX_FIELD_BUF_ADD_N0,&
    & SURFEX_FIELD_BUF_ADD_N1,&
    & SURFEX_FIELD_BUF_ADD_C0,&
    & SURFEX_FIELD_BUF_ADD_X0,&
    & SURFEX_FIELD_BUF_ADD_L0,&
    & SURFEX_FIELD_BUF_ADD_L1,&
    & SURFEX_FIELD_BUF_ADD_Y1,&
    & SURFEX_FIELD_BUF_ADD_S_FX1,&
    & SURFEX_FIELD_BUF_ADD_S_FX2
END INTERFACE

INTERFACE SURFEX_FIELD_BUF_SET
  MODULE PROCEDURE &
    & SURFEX_FIELD_BUF_SET_T0,      &
    & SURFEX_FIELD_BUF_SET_T1,      &
    & SURFEX_FIELD_BUF_SET_N0,      &
    & SURFEX_FIELD_BUF_SET_N1,      &
    & SURFEX_FIELD_BUF_SET_C0,      &
    & SURFEX_FIELD_BUF_SET_X0,      &
    & SURFEX_FIELD_BUF_SET_L0,      &
    & SURFEX_FIELD_BUF_SET_L1,      &
    & SURFEX_FIELD_BUF_SET_Y1
END INTERFACE

INTERFACE SURFEX_FIELD_BUF_GET
  MODULE PROCEDURE&
    & SURFEX_FIELD_BUF_GET_T0,      &
    & SURFEX_FIELD_BUF_GET_T1,      &
    & SURFEX_FIELD_BUF_GET_N0,      &
    & SURFEX_FIELD_BUF_GET_N1,      &
    & SURFEX_FIELD_BUF_GET_C0,      &
    & SURFEX_FIELD_BUF_GET_X0,      &
    & SURFEX_FIELD_BUF_GET_L0,      &
    & SURFEX_FIELD_BUF_GET_L1,      &
    & SURFEX_FIELD_BUF_GET_Y1,      &
    & SURFEX_FIELD_BUF_GET_S_FX1,   &
    & SURFEX_FIELD_BUF_GET_S_FX2,   &
    & SURFEX_FIELD_BUF_GET_F
END INTERFACE

INTERFACE SURFEX_MPI_XCHG
  MODULE PROCEDURE&
    & SURFEX_MPI_XCHG_N0,           &
    & SURFEX_MPI_XCHG_N1,           &
    & SURFEX_MPI_XCHG_L0,           &
    & SURFEX_MPI_XCHG_L1,           &
    & SURFEX_MPI_XCHG_X0,           &
    & SURFEX_MPI_XCHG_Y1,           &
    & SURFEX_MPI_XCHG_T0,           &
    & SURFEX_MPI_XCHG_T1,           &
    & SURFEX_MPI_XCHG_C0,           &
    & SURFEX_MPI_XCHG_C1
END INTERFACE

CONTAINS

SUBROUTINE SURFEX_MPI_XCHG_N0(N0)
USE MPL_BROADCAST_MOD, ONLY : MPL_BROADCAST

INTEGER (KIND=JPIM) :: N0
INTEGER (KIND=JPIM) :: ITAG
INTEGER (KIND=JPIM) :: N1(1)

IF (NPROC > 1) THEN
  CALL SURFEX_MPI_TAG (ITAG)

  N1(1) = N0
  CALL MPL_BROADCAST (N1, ITAG)
  N0 = N1(1)

ENDIF

END SUBROUTINE SURFEX_MPI_XCHG_N0

SUBROUTINE SURFEX_MPI_XCHG_N1(N1)
USE MPL_BROADCAST_MOD, ONLY : MPL_BROADCAST

INTEGER (KIND=JPIM) :: N1(:)
INTEGER (KIND=JPIM) :: ITAG

IF (NPROC > 1) THEN
CALL SURFEX_MPI_TAG (ITAG)
CALL MPL_BROADCAST (N1 (1:SIZE(N1)), ITAG)
ENDIF

END SUBROUTINE SURFEX_MPI_XCHG_N1

SUBROUTINE SURFEX_MPI_XCHG_Y1(Y1)
USE MPL_BROADCAST_MOD, ONLY : MPL_BROADCAST

REAL (KIND=JPRB)    :: Y1(:)
INTEGER (KIND=JPIM) :: ITAG

IF (NPROC > 1) THEN
CALL SURFEX_MPI_TAG (ITAG)
CALL MPL_BROADCAST (Y1 (1:SIZE(Y1)), ITAG)
ENDIF

END SUBROUTINE SURFEX_MPI_XCHG_Y1

SUBROUTINE SURFEX_MPI_XCHG_T0(T0)

TYPE (SURFEX_FIELD_TIME) :: T0

CALL SURFEX_MPI_XCHG (T0%KYEAR)
CALL SURFEX_MPI_XCHG (T0%KMONTH)
CALL SURFEX_MPI_XCHG (T0%KDAY)
CALL SURFEX_MPI_XCHG (T0%PTIME)

END SUBROUTINE SURFEX_MPI_XCHG_T0

SUBROUTINE SURFEX_MPI_XCHG_T1(T1)

TYPE (SURFEX_FIELD_TIME) :: T1 (:)

CALL SURFEX_MPI_XCHG (T1%KYEAR)
CALL SURFEX_MPI_XCHG (T1%KMONTH)
CALL SURFEX_MPI_XCHG (T1%KDAY)
CALL SURFEX_MPI_XCHG (T1%PTIME)

END SUBROUTINE SURFEX_MPI_XCHG_T1

SUBROUTINE SURFEX_MPI_XCHG_L0(L0)
USE MPL_BROADCAST_MOD, ONLY : MPL_BROADCAST

LOGICAL             :: L0
INTEGER (KIND=JPIM) :: ITAG
INTEGER (KIND=JPIM) :: N1(1)

IF (NPROC > 1) THEN

  CALL SURFEX_MPI_TAG (ITAG)

  IF (L0) THEN
    N1(1) = 1
  ELSE
    N1(1) = 0
  ENDIF

  CALL MPL_BROADCAST (N1, ITAG)

  L0 = N1(1) .EQ. 1

ENDIF

END SUBROUTINE SURFEX_MPI_XCHG_L0

SUBROUTINE SURFEX_MPI_XCHG_L1(L1)
USE MPL_BROADCAST_MOD, ONLY : MPL_BROADCAST

LOGICAL             :: L1(:)
INTEGER (KIND=JPIM) :: ITAG
INTEGER (KIND=JPIM) :: N1(SIZE(L1))

IF (NPROC > 1) THEN

  CALL SURFEX_MPI_TAG (ITAG)

  WHERE (L1)
    N1 = 1
  ELSEWHERE
    N1 = 0
  END WHERE

  CALL MPL_BROADCAST (N1, ITAG)

  WHERE (N1 .EQ. 1)
    L1 = .TRUE.
  ELSEWHERE
    L1 = .FALSE.
  END WHERE

ENDIF

END SUBROUTINE SURFEX_MPI_XCHG_L1

SUBROUTINE SURFEX_MPI_XCHG_X0(X0)
USE MPL_BROADCAST_MOD, ONLY : MPL_BROADCAST

INTEGER (KIND=JPIM) :: ITAG
REAL (KIND=JPRB)    :: X0
REAL (KIND=JPRB)    :: X1(1)

IF (NPROC > 1) THEN

  CALL SURFEX_MPI_TAG (ITAG)

  X1(1) = X0
  CALL MPL_BROADCAST (X1, ITAG)
  X0 = X1(1)

ENDIF

END SUBROUTINE SURFEX_MPI_XCHG_X0

SUBROUTINE SURFEX_MPI_XCHG_C0(C0)
USE MPL_BROADCAST_MOD, ONLY : MPL_BROADCAST

CHARACTER*(*)       :: C0
INTEGER (KIND=JPIM) :: ITAG

IF (NPROC > 1) THEN

  CALL SURFEX_MPI_TAG (ITAG)

  CALL MPL_BROADCAST (C0, ITAG)

ENDIF

END SUBROUTINE SURFEX_MPI_XCHG_C0

SUBROUTINE SURFEX_MPI_XCHG_C1(C1)
USE MPL_BROADCAST_MOD, ONLY : MPL_BROADCAST

CHARACTER*(*)       :: C1(:)
INTEGER (KIND=JPIM) :: ILEN

ILEN = LEN (C1) * SIZE (C1)

CALL XCHG_C1 (ILEN)

CONTAINS

SUBROUTINE XCHG_C1(KLEN)

INTEGER (KIND=JPIM), INTENT (IN) :: KLEN
CHARACTER (LEN=ILEN) :: CLBUF
INTEGER (KIND=JPIM)  :: ITAG
INTEGER (KIND=JPIM)  :: I, J, K

K = KLEN

IF (NPROC > 1) THEN

  CALL SURFEX_MPI_TAG (ITAG)

  IF (MYPROC == 1) THEN
    K = 1
    DO I = 1, SIZE (C1)
      DO J = 1, LEN (C1)
        CLBUF (K:K) = C1 (I)(J:J)
        K = K + 1
      ENDDO
    ENDDO
  ENDIF

  CALL MPL_BROADCAST (CLBUF, ITAG)

  IF (MYPROC /= 1) THEN
    K = 1
    DO I = 1, SIZE (C1)
      DO J = 1, LEN (C1)
        C1 (I)(J:J) = CLBUF (K:K)
        K = K + 1
      ENDDO
    ENDDO
  ENDIF

ENDIF

END SUBROUTINE XCHG_C1

END SUBROUTINE SURFEX_MPI_XCHG_C1


! Cache

SUBROUTINE SURFEX_FIELD_BUF_SET_RECORD (YDSC,LRECORD)

TYPE (SURFEX_FIELD_BUF_CACHE), INTENT (INOUT) :: YDSC
LOGICAL,                       INTENT (IN)    :: LRECORD

YDSC%LRECORD = LRECORD

END SUBROUTINE SURFEX_FIELD_BUF_SET_RECORD

SUBROUTINE SURFEX_FIELD_BUF_PREALLOC (YDSC, KGPTOT)
USE YOMLUN, ONLY : NULNAM


TYPE (SURFEX_FIELD_BUF_CACHE), INTENT (INOUT) :: YDSC
INTEGER (KIND=JPIM), OPTIONAL, INTENT (IN)    :: KGPTOT

#include "abor1.intfb.h"
#include "posname.intfb.h"

INTEGER (KIND=JPIM) :: I, J, NFLD, IFLD, JFLD, ILEV, IGPTOT

INTEGER (KIND=JPIM), PARAMETER :: NFLDMAX = 100
INTEGER (KIND=JPIM) :: IER
LOGICAL             :: LLNAMSFXCMP = .TRUE.
INTEGER (KIND=JPIM) :: IPFAOVSZ, IREP

CHARACTER (LEN=NFASUFFLEN)       :: CLNOMA
CHARACTER (LEN=NFASUFFLEN), SAVE :: CFLDNAME (NFLDMAX)
INTEGER (KIND=JPIM),        SAVE :: NBBITS (NFLDMAX), NVGRIBSFX

NAMELIST / NAMSFXCMP / CFLDNAME, NBBITS, NVGRIBSFX

IF (LLNAMSFXCMP) THEN
  CALL POSNAME (NULNAM, 'NAMSFXCMP', IER)
  CFLDNAME = ''
  NBBITS = NBPDG
  NVGRIBSFX = 2
  IF (IER == 0) THEN
    READ (NULNAM, NML = NAMSFXCMP)
  ENDIF
  LLNAMSFXCMP = .FALSE.
ENDIF

IPFAOVSZ = 2

IGPTOT = NGPTOT
IF (PRESENT (KGPTOT)) IGPTOT = KGPTOT

NFLD = 0
DO I = 1, YDSC%N
  IF (YDSC%P(I)%TYPE == 'X1') THEN
    NFLD = NFLD + 1
  ELSE IF (YDSC%P(I)%TYPE == 'X2') THEN
    NFLD = NFLD + YDSC%P(I)%NDIM(2)
  ENDIF
ENDDO


ALLOCATE (YDSC%YIOFLDDESC (NFLD))
YDSC%YIOFLDDESC%LUNDF   = .TRUE.
YDSC%YIOFLDDESC%XUNDF   = XUNDEF
YDSC%YIOFLDDESC%JBITS   = NBPDG

YDSC%YIOFLDDESC%NFLSZ   = IGPTOT
YDSC%YIOFLDDESC%NSIZPK  = IGPTOT+IPFAOVSZ
YDSC%YIOFLDDESC%NGRIBL  = NVGRIBSFX
YDSC%YIOFLDDESC%IFPMASK = 1


ALLOCATE (YDSC%NBUF_FUNITS (NFLD),        &
        & YDSC%NBUF_FFILES (NFLD),        &
        & YDSC%PBUF_FIELDS (IGPTOT, NFLD))

YDSC%PBUF_FIELDS = XUNDEF
YDSC%NBUF_FUNITS = 0
YDSC%NBUF_FFILES = 0

IFLD = 1
DO I = 1, YDSC%N

  IF (YDSC%P(I)%TYPE == 'X1') THEN

    CLNOMA = TRIM (CPREFIX_SFX1) // TRIM(YDSC%P(I)%NAME)

    YDSC%P(I)%S_FX1%P => YDSC%PBUF_FIELDS (:,IFLD)
    YDSC%P(I)%S_FX1%IRANK = IFLD

    YDSC%YIOFLDDESC(IFLD)%CPREF = CPREFIX_SFX1
    YDSC%YIOFLDDESC(IFLD)%ILEVG = 0

    IF (LEN (TRIM (YDSC%P(I)%NAME)) > NFASUFFLEN)&
      & CALL ABOR1 ('SURFEX_FIELD_BUF_PREALLOC: NAME TOO LONG: '//TRIM(YDSC%P(I)%NAME))

    YDSC%YIOFLDDESC(IFLD)%CSUFF    = YDSC%P(I)%NAME (1:LEN(YDSC%YIOFLDDESC(IFLD)%CSUFF))
    YDSC%NBUF_FUNITS (IFLD)   = YDSC%P(I)%IUNIT
    YDSC%NBUF_FFILES (IFLD)   = YDSC%P(I)%IFILE

    CALL SETNBITS (YDSC%YIOFLDDESC(IFLD)%JBITS, CLNOMA)

    IFLD = IFLD + 1

  ELSE IF (YDSC%P(I)%TYPE == 'X2') THEN

    JFLD = YDSC%P(I)%NDIM(2)

    ALLOCATE (YDSC%P(I)%S_FX2(JFLD))

    DO ILEV = 1, JFLD

      WRITE (CLNOMA, '(I3.3)') ILEV
      CLNOMA = TRIM (CPREFIX_SFX2) // TRIM (CLNOMA) // TRIM(YDSC%P(I)%NAME)

      YDSC%P(I)%S_FX2(ILEV)%P => YDSC%PBUF_FIELDS (:,IFLD+ILEV-1)
      YDSC%P(I)%S_FX2(ILEV)%IRANK = IFLD+ILEV-1

      CALL SETNBITS (YDSC%YIOFLDDESC(IFLD)%JBITS, CLNOMA)

    ENDDO

    YDSC%YIOFLDDESC(IFLD:IFLD+JFLD-1)%CPREF  = CPREFIX_SFX2
    YDSC%YIOFLDDESC(IFLD:IFLD+JFLD-1)%ILEVG  = (/ ( J, J = 1, JFLD ) /)

    IF (LEN (TRIM (YDSC%P(I)%NAME)) > NFASUFFLEN)&
      & CALL ABOR1 ('SURFEX_FIELD_BUF_PREALLOC: NAME TOO LONG')

    YDSC%YIOFLDDESC(IFLD:IFLD+JFLD-1)%CSUFF  = YDSC%P(I)%NAME(1:NFASUFFLEN)
    YDSC%NBUF_FUNITS (IFLD:IFLD+JFLD-1) = YDSC%P(I)%IUNIT
    YDSC%NBUF_FFILES (IFLD:IFLD+JFLD-1) = YDSC%P(I)%IFILE

    IFLD = IFLD + JFLD

  ENDIF

ENDDO

CONTAINS

SUBROUTINE SETNBITS (KNBITS, CDNOMA)

INTEGER (KIND=JPIM), INTENT (OUT) :: KNBITS
CHARACTER (LEN=*),   INTENT (IN)  :: CDNOMA

INTEGER (KIND=JPIM) :: I, J 

KNBITS = NBPDG

FLDLOOP : DO I = 1, NFLDMAX
  DO J = 1, LEN (CDNOMA)
    IF (CFLDNAME (I) (J:J) == '?') CYCLE
    IF (CDNOMA (J:J) /= CFLDNAME (I) (J:J)) CYCLE FLDLOOP
  ENDDO
  KNBITS = NBBITS (I)
  EXIT FLDLOOP
ENDDO FLDLOOP

END SUBROUTINE

END SUBROUTINE SURFEX_FIELD_BUF_PREALLOC

SUBROUTINE SURFEX_FIELD_BUF_GET2DF (YDSC, PFIELDS, KFUNITS, KFFILES, YDFLDSC)

TYPE (SURFEX_FIELD_BUF_CACHE), INTENT (INOUT) :: YDSC

REAL (KIND=JPRB),          POINTER, OPTIONAL :: PFIELDS (:,:)
INTEGER (KIND=JPIM),       POINTER, OPTIONAL :: KFUNITS (:)
INTEGER (KIND=JPIM),       POINTER, OPTIONAL :: KFFILES (:)
TYPE (IOFLDDESC),          POINTER, OPTIONAL :: YDFLDSC (:)


IF (PRESENT (PFIELDS))  PFIELDS  => YDSC%PBUF_FIELDS
IF (PRESENT (KFUNITS))  KFUNITS  => YDSC%NBUF_FUNITS
IF (PRESENT (KFFILES))  KFFILES  => YDSC%NBUF_FFILES
IF (PRESENT (YDFLDSC))  YDFLDSC  => YDSC%YIOFLDDESC

END SUBROUTINE SURFEX_FIELD_BUF_GET2DF

SUBROUTINE SURFEX_FIELD_BUF_FIX2DF (YDSC, YDGEOMETRY, PFIELDS, YDFLDSC)

USE GEOMETRY_MOD , ONLY : GEOMETRY
USE MPL_MODULE,    ONLY : MPL_SEND, MPL_RECV, MPL_BROADCAST
USE IOFLDDESC_MOD, ONLY : IOFLDDESC

TYPE (SURFEX_FIELD_BUF_CACHE), INTENT (INOUT) :: YDSC
TYPE(GEOMETRY),    INTENT (IN) :: YDGEOMETRY
REAL (KIND=JPRB),  POINTER     :: PFIELDS (:,:)
TYPE (IOFLDDESC),  POINTER     :: YDFLDSC (:)

REAL (KIND=JPRB),    ALLOCATABLE :: ZBUF(:)
INTEGER (KIND=JPIM), ALLOCATABLE :: IBUF(:,:)
INTEGER(KIND=JPIM) :: IFNUM0, IEXTZ(NPROC), JROC, JFLDG

IF (.NOT.ASSOCIATED(PFIELDS)) THEN
  ! we are likely to cope with a task 100% inside the extension zone => use a dummy array
  IEXTZ(MYPROC)=1
ELSE
  IEXTZ(MYPROC)=0
ENDIF

DO JROC=1,NPROC
  CALL MPL_BROADCAST(IEXTZ(JROC),KROOT=JROC,KTAG=JROC,CDSTRING='SURFEX_FIELD_BUF_FIX2DF:')
ENDDO

IF (MYPROC == 1 .AND. ANY(IEXTZ(:)==1)) THEN
  ALLOCATE(IBUF(SIZE(PFIELDS,2),5))
  IBUF(:,1)=YDFLDSC(:)%NGRIBL
  IBUF(:,2)=YDFLDSC(:)%JBITS
  IBUF(:,3)=YDFLDSC(:)%ICPLB
  IBUF(:,4)=YDFLDSC(:)%IGRIB
  IBUF(:,5)=YDFLDSC(:)%ILEVG
  ALLOCATE(ZBUF(SIZE(PFIELDS,2)))
  ZBUF(:)=YDFLDSC(:)%XUNDF
  DO JROC=1,NPROC
    IF (IEXTZ(JROC)==1) THEN
      CALL MPL_SEND(SIZE(PFIELDS,2),KTAG=1,KDEST=JROC,CDSTRING='SURFEX_FIELD_BUF_FIX2DF:')
      CALL MPL_SEND(IBUF,KTAG=2,KDEST=JROC,CDSTRING='SURFEX_FIELD_BUF_FIX2DF:')
      CALL MPL_SEND(ZBUF,KTAG=3,KDEST=JROC,CDSTRING='SURFEX_FIELD_BUF_FIX2DF:')
      CALL MPL_SEND(YDFLDSC(:)%CMAGIC,KTAG=4,KDEST=JROC,CDSTRING='SURFEX_FIELD_BUF_FIX2DF:')
      CALL MPL_SEND(YDFLDSC(:)%CPREF,KTAG=5,KDEST=JROC,CDSTRING='SURFEX_FIELD_BUF_FIX2DF:')
      CALL MPL_SEND(YDFLDSC(:)%CSUFF,KTAG=6,KDEST=JROC,CDSTRING='SURFEX_FIELD_BUF_FIX2DF:')
    ENDIF
  ENDDO
ENDIF
IF (IEXTZ(MYPROC)==1) THEN
  CALL MPL_RECV(IFNUM0,KTAG=1,KSOURCE=1,CDSTRING='SURFEX_FIELD_BUF_FIX2DF:')
  ALLOCATE(YDSC%YIOFLDDESC(IFNUM0))
  YDFLDSC => YDSC%YIOFLDDESC(:)
  ALLOCATE(YDSC%PBUF_FIELDS(YDGEOMETRY%YRGEM%NGPTOT,IFNUM0))
  PFIELDS => YDSC%PBUF_FIELDS(:,:)
  ALLOCATE(IBUF(IFNUM0,5))
  YDSC%YIOFLDDESC(:)%LUNDF=.TRUE.
  CALL MPL_RECV(IBUF,KTAG=2,KSOURCE=1,CDSTRING='SURFEX_FIELD_BUF_FIX2DF:')
  YDFLDSC(:)%NGRIBL=IBUF(:,1)
  YDFLDSC(:)%JBITS=IBUF(:,2)
  YDFLDSC(:)%ICPLB=IBUF(:,3)
  YDFLDSC(:)%IGRIB=IBUF(:,4)
  YDFLDSC(:)%ILEVG=IBUF(:,5)
  ALLOCATE(ZBUF(IFNUM0))
  CALL MPL_RECV(ZBUF,KTAG=3,KSOURCE=1,CDSTRING='SURFEX_FIELD_BUF_FIX2DF:')
  YDFLDSC(:)%XUNDF=ZBUF(:)
  CALL MPL_RECV(YDSC%YIOFLDDESC(:)%CMAGIC,KTAG=4,KSOURCE=1,CDSTRING='SURFEX_FIELD_BUF_FIX2DF:')
  CALL MPL_RECV(YDSC%YIOFLDDESC(:)%CPREF,KTAG=5,KSOURCE=1,CDSTRING='SURFEX_FIELD_BUF_FIX2DF:')
  CALL MPL_RECV(YDSC%YIOFLDDESC(:)%CSUFF,KTAG=6,KSOURCE=1,CDSTRING='SURFEX_FIELD_BUF_FIX2DF:')
  DO JFLDG=1,IFNUM0
    YDSC%PBUF_FIELDS(:,JFLDG)=YDFLDSC(JFLDG)%XUNDF
  ENDDO
ENDIF

END SUBROUTINE SURFEX_FIELD_BUF_FIX2DF 

SUBROUTINE SURFEX_FIELD_BUF_REMOVE_UNDEF (PFIELDS)

USE MODD_SURF_PAR, ONLY : XUNDEF

REAL (KIND=JPRB), INTENT (INOUT) :: PFIELDS (:,:)

INTEGER (KIND=JPIM)  :: I, NNDEF
REAL (KIND=JPRB)     :: ZAVG
LOGICAL, ALLOCATABLE :: LLMASKDEF (:)

ALLOCATE (LLMASKDEF (SIZE (PFIELDS, 1)))

DO I = 1, SIZE (PFIELDS, 2)
  LLMASKDEF = PFIELDS (:, I) /= XUNDEF
  NNDEF = COUNT (LLMASKDEF)

  IF (NNDEF > 0) THEN
    ZAVG = SUM (PFIELDS (:, I), MASK = LLMASKDEF) / NNDEF
  ELSE
    ZAVG = 0
  ENDIF

  WHERE (.NOT. LLMASKDEF)
!   PFIELDS (:, I) = ZAVG
    PFIELDS (:, I) = 0.
  END WHERE

ENDDO

DEALLOCATE (LLMASKDEF)

END SUBROUTINE SURFEX_FIELD_BUF_REMOVE_UNDEF

SUBROUTINE SURFEX_MPI_TAG (KTAG)

INTEGER (KIND=JPIM), INTENT (OUT) :: KTAG
INTEGER (KIND=JPIM), SAVE         :: ITAG = 0

ITAG = ITAG + 1

KTAG = ITAG

END SUBROUTINE SURFEX_MPI_TAG


SUBROUTINE SURFEX_FIELD_BUF_DUMP (YDSC, LDVAL, KUNIT, LDREADONLY)

TYPE (SURFEX_FIELD_BUF_CACHE), INTENT (INOUT) :: YDSC
LOGICAL, OPTIONAL,             INTENT (IN)    :: LDVAL
INTEGER (KIND=JPIM), OPTIONAL, INTENT (IN)    :: KUNIT
LOGICAL, OPTIONAL,             INTENT (IN)    :: LDREADONLY

INTEGER (KIND=JPIM) :: I, J, ILEV
INTEGER (KIND=JPIM) :: IND(YDSC%N)
LOGICAL             :: LLVAL
INTEGER (KIND=JPIM) :: IUNIT
LOGICAL             :: LLREADONLY

#include "abor1.intfb.h"

IUNIT = 0
IF (PRESENT (KUNIT)) IUNIT = KUNIT

WRITE (IUNIT, *) "--- START DUMP OF SURFEX CACHE --- [ "

IF (.NOT. ASSOCIATED (YDSC%P)) GOTO 999
  
IND = (/ (I, I = 1, YDSC%N) /)

CALL QSORTC (YDSC%N, IND, YDSC%P(:)%NAME)

LLVAL = .FALSE.
IF (PRESENT (LDVAL)) LLVAL = LDVAL
LLREADONLY = .FALSE.
IF (PRESENT (LDREADONLY)) LLREADONLY = LDREADONLY


DO J = 1, YDSC%N

  I = IND (J)

  IF (LLREADONLY) THEN
    IF (.NOT. YDSC%P(I)%LREAD) CYCLE
  ENDIF

  WRITE (IUNIT, *) "'"//TRIM (YDSC%P(I)%NAME)//"',",&
                 & "'"//TRIM (YDSC%P(I)%TYPE)//"',",&
                 & "'"//TRIM (YDSC%P(I)%MASK)//"',", " [ "

  SELECT CASE (YDSC%P(I)%TYPE)
    CASE ('L0')
      IF (LLVAL) WRITE (IUNIT, '(L6,",")') YDSC%P(I)%L0
    CASE ('L1')
      IF (ASSOCIATED(YDSC%P(I)%L1)) THEN
        WRITE (IUNIT, '(10(I8,","))') UBOUND (YDSC%P(I)%L1)
        IF (LLVAL) WRITE (IUNIT, '(10(L6,","))') YDSC%P(I)%L1
      ENDIF
    CASE ('X0')
      IF (LLVAL) WRITE (IUNIT, '(E14.6,",")') YDSC%P(I)%X0
    CASE ('X1')
      IF (ASSOCIATED(YDSC%P(I)%S_FX1%P)) THEN
        WRITE (IUNIT, '(10(I8,","))') UBOUND (YDSC%P(I)%S_FX1%P)
        IF (LLVAL) WRITE (IUNIT, '(10(E14.6,","))') YDSC%P(I)%S_FX1%P
      ENDIF
    CASE ('X2')
      IF (ASSOCIATED(YDSC%P(I)%S_FX2)) THEN
        WRITE (IUNIT, '(10(I8,","))') UBOUND (YDSC%P(I)%S_FX2)
        IF (LLVAL) THEN
          DO ILEV = 1, SIZE (YDSC%P(I)%S_FX2)
            WRITE (IUNIT, '(10(E14.6,","))') YDSC%P(I)%S_FX2(ILEV)%P
          ENDDO
        ENDIF
      ENDIF
    CASE ('C0')
      IF (LLVAL) WRITE (IUNIT, *) "'"//TRIM (YDSC%P(I)%C0)//"',"
    CASE ('T0')
      IF (LLVAL) WRITE (IUNIT, '(3(I8,","),E14.6,",")') YDSC%P(I)%T0
    CASE ('T1')
      IF (ASSOCIATED(YDSC%P(I)%T1)) THEN
        WRITE (IUNIT, '(10(I8,","))') UBOUND (YDSC%P(I)%T1)
        IF (LLVAL) WRITE (IUNIT, '(3(I8,","),E14.6,",")') YDSC%P(I)%T1
      ENDIF
    CASE ('N0')
      IF (LLVAL) WRITE (IUNIT, '(I8,",")') YDSC%P(I)%N0
    CASE ('N1')
      IF (ASSOCIATED(YDSC%P(I)%N1)) THEN
        WRITE (IUNIT, '(10(I8,","))') UBOUND (YDSC%P(I)%N1)
        IF (LLVAL) WRITE (IUNIT, '(10(I8,","))') YDSC%P(I)%N1
      ENDIF
    CASE ('Y1')
      IF (ASSOCIATED(YDSC%P(I)%Y1)) THEN
        WRITE (IUNIT, '(10(I8,","))') UBOUND (YDSC%P(I)%Y1)
        IF (LLVAL) WRITE (IUNIT, '(10(E14.68,","))') YDSC%P(I)%Y1
      ENDIF
    CASE DEFAULT
      CALL ABOR1 ('SURFEX_FIELD_BUF_DUMP:UNKNOWN FIELD TYPE:'//YDSC%P(I)%TYPE)
  END SELECT
  WRITE (IUNIT, *) " ], "
ENDDO

999 CONTINUE

WRITE (IUNIT, *) "] --- END DUMP OF SURFEX CACHE ---"
CALL FLUSH (IUNIT)

END SUBROUTINE SURFEX_FIELD_BUF_DUMP


SUBROUTINE SURFEX_FIELD_BUF_SIZE (YDSC, KSIZE)

TYPE (SURFEX_FIELD_BUF_CACHE), INTENT (INOUT) :: YDSC
INTEGER (KIND=JPIM),           INTENT (OUT)   :: KSIZE

KSIZE = YDSC%N

END SUBROUTINE SURFEX_FIELD_BUF_SIZE

SUBROUTINE SURFEX_FIELD_BUF_SELECT (YDSC, CDONLY, CDREMV)

TYPE (SURFEX_FIELD_BUF_CACHE), INTENT (INOUT) :: YDSC
CHARACTER (LEN=*), OPTIONAL,   INTENT (IN)    :: CDONLY (:)
CHARACTER (LEN=*), OPTIONAL,   INTENT (IN)    :: CDREMV (:)

TYPE (SURFEX_FIELD_BUF), POINTER :: YLSCL (:)
LOGICAL                          :: LLKEEP (YDSC%N)
INTEGER (KIND=JPIM)              :: I, N


DO I = 1, YDSC%N
  LLKEEP (I) = .TRUE.
  IF (PRESENT (CDONLY)) THEN
    LLKEEP (I) = LLKEEP (I) .AND. ANY (CDONLY == YDSC%P (I)%NAME)
  ENDIF
  IF (PRESENT (CDREMV)) THEN
    LLKEEP (I) = LLKEEP (I) .AND. ALL (CDREMV /= YDSC%P (I)%NAME)
  ENDIF
  IF (.NOT. LLKEEP (I)) THEN
    CALL SURFEX_FIELD_BUF_DEALLOC1 (YDSC%P (I), .FALSE.)
  ENDIF
ENDDO

N = COUNT (LLKEEP)

ALLOCATE (YLSCL (N))

YLSCL = PACK (YDSC%P, MASK = LLKEEP)

IF (ASSOCIATED(YDSC%P)) DEALLOCATE (YDSC%P)

YDSC%N = N
YDSC%NTOT = N

YDSC%P => YLSCL

END SUBROUTINE SURFEX_FIELD_BUF_SELECT

SUBROUTINE SURFEX_FIELD_BUF_READ_MISC(YDSC, KUNIT, KFILE, LDMPI, KMERGE, LDFATAL, YDGEOMETRY, YDRIP)

USE GEOMETRY_MOD , ONLY : GEOMETRY
USE YOMRIP , ONLY : TRIP

TYPE (SURFEX_FIELD_BUF_CACHE), INTENT (INOUT)           :: YDSC
INTEGER (KIND=JPIM),           INTENT (IN),    OPTIONAL :: KFILE
INTEGER (KIND=JPIM),           INTENT (IN),    OPTIONAL :: KUNIT
LOGICAL,                       INTENT (IN),    OPTIONAL :: LDMPI
INTEGER (KIND=JPIM),           INTENT (IN),    OPTIONAL :: KMERGE
LOGICAL,                       INTENT (IN),    OPTIONAL :: LDFATAL
TYPE (GEOMETRY),               INTENT (IN),    OPTIONAL :: YDGEOMETRY
TYPE (TRIP),                   INTENT (IN),    OPTIONAL :: YDRIP

INTEGER (KIND=JPIM) :: I
LOGICAL             :: LLNDFD

LLNDFD = ASSOCIATED (YDSC%PBUF_FIELDS)

CALL SURFEX_FIELD_BUF_READ_MISC1(YDSC%P, LLNDFD, KUNIT, KFILE, LDMPI, KMERGE, LDFATAL, YDGEOMETRY, YDRIP)

IF (ASSOCIATED (YDSC%P)) THEN
  YDSC%NTOT = SIZE (YDSC%P)
  YDSC%N    = SIZE (YDSC%P)
  DO I = 1, SIZE (YDSC%P)
    IF (YDSC%P (I)%NAME == '') THEN
      YDSC%N = I - 1
      EXIT
    ENDIF
  ENDDO
ELSE
  YDSC%N    = 0
  YDSC%NTOT = 0
ENDIF

END SUBROUTINE SURFEX_FIELD_BUF_READ_MISC

SUBROUTINE SURFEX_FIELD_BUF_READ_MISC1 (YDSCL, LDNDFD, KUNIT, KFILE, LDMPI, KMERGE, LDFATAL, &
                                      & YDGEOMETRY, YDRIP)

USE GEOMETRY_MOD , ONLY : GEOMETRY
USE YOMRIP, ONLY : TRIP

TYPE (SURFEX_FIELD_BUF),        POINTER     :: YDSCL (:)
LOGICAL,                        INTENT (IN) :: LDNDFD
INTEGER (KIND=JPIM),  OPTIONAL, INTENT (IN) :: KUNIT
INTEGER (KIND=JPIM),  OPTIONAL, INTENT (IN) :: KFILE
LOGICAL,              OPTIONAL, INTENT (IN) :: LDMPI
INTEGER (KIND=JPIM),  OPTIONAL, INTENT (IN) :: KMERGE
LOGICAL,              OPTIONAL, INTENT (IN) :: LDFATAL
TYPE (GEOMETRY),      OPTIONAL, INTENT (IN) :: YDGEOMETRY
TYPE (TRIP),          OPTIONAL, INTENT (IN) :: YDRIP

#include "abor1.intfb.h"
#include "openfa.intfb.h"

INTEGER (KIND=JPIM) :: I, J, N, N1, ND
INTEGER (KIND=JPIM) :: I1, I2
INTEGER (KIND=JPIM) :: IRET, JRET
INTEGER (KIND=JPIM), ALLOCATABLE :: IBUF (:)
TYPE (SURFEX_FIELD_BUF), POINTER :: YLSCL (:)
TYPE (SURFEX_FIELD_BUF), POINTER :: YLSCL1 (:)
LOGICAL :: LLMPI
LOGICAL :: LLRDB
LOGICAL :: LLERFA
LOGICAL :: LLFATAL
INTEGER (KIND=JPIM) :: IMERGE
INTEGER (KIND=JPIM) :: IUNIT
INTEGER (KIND=JPIM) :: IFILE

LLMPI = .TRUE.
IF (PRESENT (LDMPI)) LLMPI = LDMPI
LLRDB = (MYPROC == 1) .OR. (.NOT. LLMPI)

IF (PRESENT (KUNIT)) THEN
  IFILE = -1
  IUNIT = KUNIT
ELSEIF (PRESENT (KFILE)) THEN
  IFILE = KFILE
  IF (LLRDB) THEN
    CALL OPENFA(YDGEOMETRY,YDRIP,IFILE, IUNIT)
  ELSE
    IUNIT = -1
  ENDIF
ELSE
  CALL ABOR1 ('SURFEX_FIELD_BUF_READ_MISC1: MISSING ARGUMENT')
ENDIF

IMERGE = 0
IF (PRESENT (KMERGE)) IMERGE = KMERGE

LLFATAL = .TRUE.
IF (PRESENT (LDFATAL)) LLFATAL = LDFATAL

IRET = 0
IF (LLRDB) THEN
  CALL LFIOEF (JRET, IUNIT, LLERFA)
  CALL LFIERF (JRET, IUNIT, .FALSE.)
  CALL RN0_ (N, '_FBUF_SIZE')
  CALL LFIERF (JRET, IUNIT, LLERFA)
ENDIF

IF (LLMPI) CALL SURFEX_MPI_XCHG (JRET)

IF (IRET .NE. 0) THEN
  IF (LLFATAL) THEN
    CALL ABOR1 ("SURFEX_FIELD_BUF_READ_MISC1: NO INDEX WAS FOUND")
  ELSE
    RETURN
  ENDIF
ENDIF

IF (LLMPI) CALL SURFEX_MPI_XCHG (N)

ALLOCATE (YLSCL (N))

IF (LLRDB) THEN
  CALL RN1_ (YLSCL(:)%NDIM(1), '_FBUF_DIM1')
  CALL RN1_ (YLSCL(:)%NDIM(2), '_FBUF_DIM2')
  CALL RC1_ (YLSCL(:)%NAME, '_FBUF_NAME')
  CALL RC1_ (YLSCL(:)%TYPE, '_FBUF_TYPE')
  CALL RC1_ (YLSCL(:)%MASK, '_FBUF_MASK', LDFATAL=.FALSE.)
ENDIF

IF (LLMPI) THEN
! xlf cannot cope with CALL SURFEX_MPI_XCHG (YLSCL%NDIM(1))
! hence we need to use temporary buffers

  ALLOCATE (IBUF (N))
  IBUF = YLSCL(:)%NDIM(1)
  CALL SURFEX_MPI_XCHG (IBUF)
  YLSCL(:)%NDIM(1) = IBUF

  IBUF = YLSCL(:)%NDIM(2)
  CALL SURFEX_MPI_XCHG (IBUF)
  YLSCL(:)%NDIM(2) = IBUF

  DEALLOCATE (IBUF)

  CALL SURFEX_MPI_XCHG (YLSCL(:)%NAME)
  CALL SURFEX_MPI_XCHG (YLSCL(:)%TYPE)
  CALL SURFEX_MPI_XCHG (YLSCL(:)%MASK)

ENDIF

DO I = 1, N

  I1 = YLSCL(I)%NDIM(1)
  I2 = YLSCL(I)%NDIM(2)

  SELECT CASE (YLSCL(I)%TYPE)
    CASE ('X1') ;
    CASE ('X2') ;
    CASE ('X0') ;                               IF (LLRDB) CALL RX0 ; IF (LLMPI) CALL SURFEX_MPI_XCHG (YLSCL(I)%X0)
    CASE ('L0') ;                               IF (LLRDB) CALL RL0 ; IF (LLMPI) CALL SURFEX_MPI_XCHG (YLSCL(I)%L0)
    CASE ('L1') ; ALLOCATE (YLSCL(I)%L1 (I1)) ; IF (LLRDB) CALL RL1 ; IF (LLMPI) CALL SURFEX_MPI_XCHG (YLSCL(I)%L1)
    CASE ('N0') ;                               IF (LLRDB) CALL RN0 ; IF (LLMPI) CALL SURFEX_MPI_XCHG (YLSCL(I)%N0)
    CASE ('N1') ; ALLOCATE (YLSCL(I)%N1 (I1)) ; IF (LLRDB) CALL RN1 ; IF (LLMPI) CALL SURFEX_MPI_XCHG (YLSCL(I)%N1)
    CASE ('T0') ;                               IF (LLRDB) CALL RT0 ; IF (LLMPI) CALL SURFEX_MPI_XCHG (YLSCL(I)%T0)
    CASE ('T1') ; ALLOCATE (YLSCL(I)%T1 (I1)) ; IF (LLRDB) CALL RT1 ; IF (LLMPI) CALL SURFEX_MPI_XCHG (YLSCL(I)%T1)
    CASE ('Y1') ; ALLOCATE (YLSCL(I)%Y1 (I1)) ; IF (LLRDB) CALL RY1 ; IF (LLMPI) CALL SURFEX_MPI_XCHG (YLSCL(I)%Y1)
    CASE ('C0') ;                               IF (LLRDB) CALL RC0 ; IF (LLMPI) CALL SURFEX_MPI_XCHG (YLSCL(I)%C0)
    CASE DEFAULT
      CALL ABOR1 ('SURFEX_FIELD_BUF_READ_MISC1: UNKNOWN FIELD KIND:'//TRIM (YLSCL(I)%TYPE))
  END SELECT

ENDDO

YLSCL(:)%IUNIT = IUNIT
YLSCL(:)%IFILE = IFILE

IF (.NOT. ASSOCIATED (YDSCL)) THEN

  YDSCL => YLSCL

ELSE

! Check that we did not read the same field twice

  ND = SIZE (YDSCL)
  DO J = 1, SIZE (YDSCL)
    IF (YDSCL (J)%NAME == '') THEN
      ND = J - 1
      EXIT
    ENDIF
  ENDDO

  I = 1

  LOOP_I : DO WHILE (I <= N)

    LOOP_J : DO J = 1, ND

      IF (YDSCL(J)%NAME == YLSCL(I)%NAME) THEN

        SELECT CASE (IMERGE)
          CASE (1) ! Take fields from YDSCL
            CALL SURFEX_FIELD_BUF_DEALLOC1 (YLSCL (I), LDNDFD)
            YLSCL (I) = YLSCL (N)
            N = N - 1
            I = I - 1
          CASE (2) ! Take fields from YLSCL
            CALL SURFEX_FIELD_BUF_DEALLOC1 (YDSCL (J), LDNDFD)
            YDSCL (J) = YDSCL (ND)
            ND = ND - 1
          CASE (0)
            CALL ABOR1 ("SURFEX_FIELD_BUF_READ_MISC1: DUPLICATE FIELD: "//TRIM (YLSCL(I)%NAME))
          CASE DEFAULT ! Default : abort
            CALL ABOR1 ("SURFEX_FIELD_BUF_READ_MISC1: UNKNOWN IMERGE VALUE")
        END SELECT

        EXIT LOOP_J

      ENDIF

    ENDDO LOOP_J

    I = I + 1

  ENDDO LOOP_I

! Reallocate data

  YLSCL1    => YDSCL
  N1        = ND
  ND        = ND + N

  ALLOCATE (YDSCL (ND))
  YDSCL (1:N1)      = YLSCL1 (1:N1)
  YDSCL (N1+1:N1+N) = YLSCL (1:N)
  DEALLOCATE (YLSCL1, YLSCL)

ENDIF

IF (PRESENT (KUNIT)) THEN
ELSEIF (PRESENT (KFILE)) THEN
  IF (LLRDB) THEN
    CALL FAIRME (IRET, IUNIT, 'UNKNOWN')
  ENDIF
ENDIF

CONTAINS

SUBROUTINE RY1_ (Y1, CDNAME)

REAL (KIND=JPRB),    INTENT (OUT) :: Y1(:)
CHARACTER (LEN=*),   INTENT (IN)  :: CDNAME
INTEGER (KIND=JPIB), ALLOCATABLE  :: IWORK(:)
REAL (KIND=JPRD),    ALLOCATABLE  :: ZWORK(:)
INTEGER (KIND=JPIM) :: N

N = SIZE (Y1)

ALLOCATE (IWORK (N), ZWORK (N))
CALL LFILEC (IRET, IUNIT, TRIM(CPREFIX_SFX1)//CDNAME, IWORK, SIZE (IWORK))
ZWORK = TRANSFER (IWORK, ZWORK)
Y1 = REAL (ZWORK, JPRB)
DEALLOCATE (IWORK, ZWORK)

END SUBROUTINE RY1_

SUBROUTINE RY1

CALL RY1_ (YLSCL(I)%Y1, YLSCL(I)%NAME)

END SUBROUTINE RY1

SUBROUTINE RX0

INTEGER (KIND=JPIB) :: IWORK(1)
REAL (KIND=JPRD)    :: ZWORK(1)

CALL LFILEC (IRET, IUNIT, TRIM(CPREFIX_SFX1)//YLSCL(I)%NAME, IWORK, SIZE (IWORK))

ZWORK(1) = TRANSFER (IWORK(1), ZWORK(1))
YLSCL(I)%X0 = ZWORK (1)

END SUBROUTINE RX0

SUBROUTINE RL0

INTEGER (KIND=JPIB) :: IWORK(1)

CALL LFILEC (IRET, IUNIT, TRIM(CPREFIX_SFX1)//YLSCL(I)%NAME, IWORK, SIZE (IWORK))

YLSCL(I)%L0 = IWORK(1) /= 0

END SUBROUTINE RL0

SUBROUTINE RL1

INTEGER (KIND=JPIB), ALLOCATABLE :: IWORK(:)
INTEGER (KIND=JPIM) :: N

N = SIZE (YLSCL(I)%L1)

ALLOCATE (IWORK (N))
CALL LFILEC (IRET, IUNIT, TRIM(CPREFIX_SFX1)//YLSCL(I)%NAME, IWORK, SIZE (IWORK))

YLSCL(I)%L1 = IWORK /= 0

DEALLOCATE (IWORK)

END SUBROUTINE RL1

SUBROUTINE RN0_ (N0, CDNAME)

INTEGER (KIND=JPIM), INTENT (OUT) :: N0
CHARACTER (LEN=*),   INTENT (IN) :: CDNAME
INTEGER (KIND=JPIB) :: IWORK(1)

CALL LFILEC (IRET, IUNIT, TRIM(CPREFIX_SFX1)//CDNAME, IWORK, SIZE (IWORK))
N0 = INT (IWORK(1))

END SUBROUTINE RN0_

SUBROUTINE RN0

CALL RN0_ (YLSCL(I)%N0, YLSCL(I)%NAME)

END SUBROUTINE RN0

SUBROUTINE RN1_ (N1, CDNAME)

INTEGER (KIND=JPIM), INTENT (OUT) :: N1(:)
CHARACTER (LEN=*),   INTENT (IN)  :: CDNAME
INTEGER (KIND=JPIB), ALLOCATABLE  :: IWORK(:)
INTEGER (KIND=JPIM) :: N

N = SIZE (N1)

ALLOCATE (IWORK (N))
CALL LFILEC (IRET, IUNIT, TRIM(CPREFIX_SFX1)//CDNAME, IWORK, SIZE (IWORK))
N1 = INT (IWORK)
DEALLOCATE (IWORK)

END SUBROUTINE RN1_

SUBROUTINE RN1

CALL RN1_ (YLSCL(I)%N1, YLSCL(I)%NAME)

END SUBROUTINE RN1

SUBROUTINE RT0

INTEGER (KIND=JPIB) :: IWORK (4)
REAL (KIND=JPRD)    :: ZTIME

CALL LFILEC (IRET, IUNIT, TRIM(CPREFIX_SFX1)//YLSCL(I)%NAME, IWORK, SIZE (IWORK))

YLSCL(I)%T0%KYEAR  = INT (IWORK (1))
YLSCL(I)%T0%KMONTH = INT (IWORK (2))
YLSCL(I)%T0%KDAY   = INT (IWORK (3))
ZTIME              = TRANSFER (IWORK (4), ZTIME)
YLSCL(I)%T0%PTIME  = REAL (ZTIME, JPRB)

END SUBROUTINE RT0

SUBROUTINE RT1

INTEGER (KIND=JPIB), ALLOCATABLE :: IWORK(:)
REAL (KIND=JPRD)    :: ZTIME
INTEGER (KIND=JPIM) :: N
INTEGER (KIND=JPIM) :: JJ

N = SIZE (YLSCL(I)%T1) * 4

ALLOCATE (IWORK (N))

CALL LFILEC (IRET, IUNIT, TRIM(CPREFIX_SFX1)//YLSCL(I)%NAME, IWORK, SIZE (IWORK))

DO JJ = 1, SIZE (YLSCL(I)%T1)
  YLSCL(I)%T1(JJ)%KYEAR  = INT (IWORK (1+(JJ-1)*4))
  YLSCL(I)%T1(JJ)%KMONTH = INT (IWORK (2+(JJ-1)*4))
  YLSCL(I)%T1(JJ)%KDAY   = INT (IWORK (3+(JJ-1)*4))
  ZTIME                  = TRANSFER (IWORK (4+(JJ-1)*4), ZTIME)
  YLSCL(I)%T1(JJ)%PTIME  = REAL (ZTIME, JPRB)
ENDDO

DEALLOCATE (IWORK)

END SUBROUTINE RT1

SUBROUTINE RC0

INTEGER (KIND=JPIM) :: N, J
INTEGER (KIND=JPIB), ALLOCATABLE :: IWORK(:)

N = LEN (YLSCL(I)%C0)

ALLOCATE (IWORK (N))

CALL LFILEC (IRET, IUNIT, TRIM(CPREFIX_SFX1)//YLSCL(I)%NAME, IWORK, SIZE (IWORK))

DO J = 1, N
  YLSCL(I)%C0(J:J) = CHAR (IWORK(J))
ENDDO

DEALLOCATE (IWORK)

END SUBROUTINE RC0

SUBROUTINE RC1_ (C1, CDNAME, LDFATAL)

CHARACTER (LEN=*), INTENT (OUT) :: C1(:)
CHARACTER (LEN=*), INTENT (IN)  :: CDNAME
LOGICAL, OPTIONAL,INTENT (IN)   :: LDFATAL

INTEGER (KIND=JPIM) :: I, J, K
INTEGER (KIND=JPIM) :: ISC1, ILC1
INTEGER (KIND=JPIM) :: JRET
INTEGER (KIND=JPIB), ALLOCATABLE :: IWORK(:)
LOGICAL :: LLFATAL

LLFATAL = .TRUE.
IF (PRESENT (LDFATAL)) LLFATAL = LDFATAL

ISC1 = SIZE (C1)
ILC1 = LEN (C1 (1))

ALLOCATE (IWORK (ISC1 * ILC1))
IWORK = ICHAR (' ')

IF (.NOT. LLFATAL) THEN
  CALL LFIOEF (JRET, IUNIT, LLERFA)
  CALL LFIERF (JRET, IUNIT, .FALSE.)
ENDIF

CALL LFILEC (IRET, IUNIT, TRIM(CPREFIX_SFX1)//CDNAME, IWORK, SIZE (IWORK))

IF (.NOT. LLFATAL) THEN
  CALL LFIERF (JRET, IUNIT, LLERFA)
  IRET = 0
ENDIF

I = 1
DO J = 1, ISC1
  DO K = 1, ILC1
    C1 (J)(K:K) = CHAR (IWORK (I))
    I = I + 1
  ENDDO
ENDDO

DEALLOCATE (IWORK)

END SUBROUTINE RC1_


END SUBROUTINE SURFEX_FIELD_BUF_READ_MISC1

SUBROUTINE SURFEX_FIELD_BUF_WRITE_MISC(YDSC, KUNIT, YDGEOMETRY, YDRIP)

USE GEOMETRY_MOD , ONLY : GEOMETRY
USE YOMRIP , ONLY : TRIP

TYPE (SURFEX_FIELD_BUF_CACHE), INTENT (INOUT)        :: YDSC
INTEGER (KIND=JPIM),           INTENT (IN)           :: KUNIT
TYPE (GEOMETRY),               INTENT (IN), OPTIONAL :: YDGEOMETRY
TYPE (TRIP),                   INTENT (IN), OPTIONAL :: YDRIP

#include "abor1.intfb.h"

INTEGER (KIND=JPIM) :: I
INTEGER (KIND=JPIM) :: N
INTEGER (KIND=JPIM) :: IRET
INTEGER (KIND=JPIB), POINTER     :: IWORK (:)
INTEGER (KIND=JPIM), ALLOCATABLE :: IND (:)
INTEGER (KIND=JPIM), ALLOCATABLE :: IDIM1 (:)
! read index again; we may already have SURFEX fields in this file

CALL SURFEX_FIELD_BUF_READ_MISC (YDSC, KUNIT=KUNIT, LDMPI=.FALSE.,&
                               & KMERGE=1, LDFATAL=.FALSE., &
                               & YDGEOMETRY=YDGEOMETRY, YDRIP=YDRIP)

N = YDSC%N

ALLOCATE (IND (N))
IND = (/ (I, I = 1, YDSC%N) /)
CALL QSORTC (YDSC%N, IND, YDSC%P(:)%NAME)

DO I = 1, N

  IWORK => NULL ()

  SELECT CASE (YDSC%P(I)%TYPE)
    CASE ('X1')
    CASE ('X2')
    CASE ('X0') ; CALL WX0
    CASE ('L0') ; CALL WL0
    CASE ('L1') ; CALL WL1
    CASE ('N0') ; CALL WN0
    CASE ('N1') ; CALL WN1
    CASE ('T0') ; CALL WT0
    CASE ('T1') ; CALL WT1
    CASE ('Y1') ; CALL WY1
    CASE ('C0') ; CALL WC0
    CASE DEFAULT
      CALL ABOR1 ('SURFEX_FIELD_BUF_WRITE_MISC: UNKNOWN FIELD KIND:'//TRIM (YDSC%P(I)%TYPE))
  END SELECT

  IF (ASSOCIATED (IWORK)) THEN
    CALL LFIECR (IRET, KUNIT, TRIM(CPREFIX_SFX1)//YDSC%P(I)%NAME, IWORK, SIZE (IWORK))
    DEALLOCATE (IWORK)
  ENDIF

ENDDO

CALL WN0_ (N)
CALL LFIECR (IRET, KUNIT, TRIM(CPREFIX_SFX1)//'_FBUF_SIZE', IWORK, SIZE (IWORK))
DEALLOCATE (IWORK)

ALLOCATE (IDIM1 (N))
IDIM1 = YDSC%P(1:N)%NDIM(1)
WHERE ((YDSC%P(1:N)%TYPE == 'X1') .OR. (YDSC%P(1:N)%TYPE == 'X2'))
  IDIM1 = NGPTOTG
END WHERE
IDIM1 = IDIM1 (IND)

CALL WN1_ (IDIM1)
CALL LFIECR (IRET, KUNIT, TRIM(CPREFIX_SFX1)//'_FBUF_DIM1', IWORK, SIZE (IWORK))
DEALLOCATE (IWORK)

CALL WN1_ (YDSC%P(IND)%NDIM(2))
CALL LFIECR (IRET, KUNIT, TRIM(CPREFIX_SFX1)//'_FBUF_DIM2', IWORK, SIZE (IWORK))
DEALLOCATE (IWORK)

CALL WC1_ (YDSC%P(IND)%NAME)
CALL LFIECR (IRET, KUNIT, TRIM(CPREFIX_SFX1)//'_FBUF_NAME', IWORK, SIZE (IWORK))
DEALLOCATE (IWORK)

CALL WC1_ (YDSC%P(IND)%TYPE)
CALL LFIECR (IRET, KUNIT, TRIM(CPREFIX_SFX1)//'_FBUF_TYPE', IWORK, SIZE (IWORK))
DEALLOCATE (IWORK)

CALL WC1_ (YDSC%P(IND)%MASK)
CALL LFIECR (IRET, KUNIT, TRIM(CPREFIX_SFX1)//'_FBUF_MASK', IWORK, SIZE (IWORK))
DEALLOCATE (IWORK)

DEALLOCATE (IDIM1)
DEALLOCATE (IND)

CONTAINS

SUBROUTINE WY1_ (Y1)

REAL (KIND=JPRB), INTENT (IN) :: Y1(:)
REAL (KIND=JPRD), ALLOCATABLE :: ZWORK (:)
INTEGER (KIND=JPIM) :: N

N = SIZE (Y1)

ALLOCATE (IWORK (N), ZWORK (N))
ZWORK = REAL (Y1, JPRD)
IWORK = TRANSFER (ZWORK, IWORK)

DEALLOCATE (ZWORK)

END SUBROUTINE WY1_

SUBROUTINE WY1


CALL WY1_ (YDSC%P(I)%Y1)

END SUBROUTINE WY1

SUBROUTINE WX0

REAL (KIND=JPRD) :: ZWORK

ALLOCATE (IWORK (1))
ZWORK    = REAL (YDSC%P(I)%X0, JPRD)
IWORK(1) = TRANSFER (ZWORK, IWORK(1))

END SUBROUTINE WX0

SUBROUTINE WL0

ALLOCATE (IWORK (1))

IF (YDSC%P(I)%L0) THEN
  IWORK(1) = 1
ELSE
  IWORK(1) = 0
ENDIF

END SUBROUTINE WL0

SUBROUTINE WL1

INTEGER (KIND=JPIM) :: N

N = SIZE (YDSC%P(I)%L1)

ALLOCATE (IWORK (N))
WHERE (YDSC%P(I)%L1)
  IWORK = 1
ELSEWHERE
  IWORK = 0
END WHERE

END SUBROUTINE WL1

SUBROUTINE WN0_ (N0)

INTEGER (KIND=JPIM), INTENT (IN) :: N0

ALLOCATE (IWORK (1))

IWORK(1) = N0

END SUBROUTINE WN0_

SUBROUTINE WN0

CALL WN0_ (YDSC%P(I)%N0)

END SUBROUTINE WN0

SUBROUTINE WN1_ (N1)

INTEGER (KIND=JPIM), INTENT (IN) :: N1(:)
INTEGER (KIND=JPIM) :: N

N = SIZE (N1)

ALLOCATE (IWORK (N))
IWORK = N1

END SUBROUTINE WN1_

SUBROUTINE WN1

CALL WN1_ (YDSC%P(I)%N1)

END SUBROUTINE WN1

SUBROUTINE WT0

REAL (KIND=JPRD) :: ZTIME

ALLOCATE (IWORK (4))

IWORK(1) = YDSC%P(I)%T0%KYEAR
IWORK(2) = YDSC%P(I)%T0%KMONTH
IWORK(3) = YDSC%P(I)%T0%KDAY
ZTIME    = REAL (YDSC%P(I)%T0%PTIME, JPRD)
IWORK(4) = TRANSFER (ZTIME, IWORK(4))

END SUBROUTINE WT0

SUBROUTINE WT1

INTEGER (KIND=JPIM) :: JJ
REAL (KIND=JPRD)    :: ZTIME

ALLOCATE (IWORK (4*SIZE(YDSC%P(I)%T1)))

DO JJ = 1, SIZE(YDSC%P(I)%T1)
  IWORK(1+(JJ-1)*4) = YDSC%P(I)%T1(JJ)%KYEAR
  IWORK(2+(JJ-1)*4) = YDSC%P(I)%T1(JJ)%KMONTH
  IWORK(3+(JJ-1)*4) = YDSC%P(I)%T1(JJ)%KDAY
  ZTIME             = REAL (YDSC%P(I)%T1(JJ)%PTIME, JPRD)
  IWORK(4+(JJ-1)*4) = TRANSFER (ZTIME, IWORK(4))
ENDDO

END SUBROUTINE WT1

SUBROUTINE WC0

INTEGER (KIND=JPIM) :: N, J

N = LEN (YDSC%P(I)%C0)

ALLOCATE (IWORK (N))

DO J = 1, N
  IWORK(J) = ICHAR (YDSC%P(I)%C0(J:J))
ENDDO

END SUBROUTINE WC0

SUBROUTINE WC1_ (C1)

CHARACTER (LEN=*), INTENT (IN) :: C1(:)
INTEGER (KIND=JPIM) :: I, J, K
INTEGER (KIND=JPIM) :: ISC1, ILC1

ISC1 = SIZE (C1)
ILC1 = LEN (C1 (1))

ALLOCATE (IWORK (ISC1 * ILC1))

I = 1
DO J = 1, ISC1
  DO K = 1, ILC1
    IWORK(I) = ICHAR (C1 (J)(K:K))
    I = I + 1
  ENDDO
ENDDO

END SUBROUTINE WC1_

END SUBROUTINE SURFEX_FIELD_BUF_WRITE_MISC

SUBROUTINE SURFEX_FIELD_BUF_DEALLOC1 (YDS, LDNDFD)

TYPE (SURFEX_FIELD_BUF), INTENT (INOUT) :: YDS
LOGICAL,                 INTENT (IN)    :: LDNDFD

INTEGER (KIND=JPIM) :: ILEV

IF (ASSOCIATED(YDS%L1)) THEN
  DEALLOCATE (YDS%L1)
  NULLIFY (YDS%L1)
ENDIF

IF (.NOT. LDNDFD) THEN

  IF (ASSOCIATED(YDS%S_FX1%P)) THEN
    DEALLOCATE (YDS%S_FX1%P)
    NULLIFY (YDS%S_FX1%P)
  ENDIF
  
  IF (ASSOCIATED(YDS%S_FX2)) THEN
    DO ILEV = 1, SIZE (YDS%S_FX2)
      IF (ASSOCIATED (YDS%S_FX2 (ILEV)%P))&
        & DEALLOCATE (YDS%S_FX2 (ILEV)%P)
    ENDDO
    DEALLOCATE (YDS%S_FX2)
    NULLIFY (YDS%S_FX2)
  ENDIF

ENDIF

IF (ASSOCIATED(YDS%N1)) THEN
  DEALLOCATE (YDS%N1)
  NULLIFY (YDS%N1)
ENDIF

IF (ASSOCIATED(YDS%T1)) THEN
  DEALLOCATE (YDS%T1)
  NULLIFY (YDS%T1)
ENDIF

END SUBROUTINE SURFEX_FIELD_BUF_DEALLOC1

SUBROUTINE SURFEX_FIELD_BUF_NULLIFY (YDSC)

TYPE (SURFEX_FIELD_BUF_CACHE), INTENT (INOUT) :: YDSC

NULLIFY (YDSC%YIOFLDDESC)
NULLIFY (YDSC%NBUF_FUNITS)
NULLIFY (YDSC%NBUF_FFILES)
NULLIFY (YDSC%PBUF_FIELDS)

NULLIFY (YDSC%P)

YDSC%NTOT = 0
YDSC%N = 0

END SUBROUTINE SURFEX_FIELD_BUF_NULLIFY

SUBROUTINE SURFEX_FIELD_BUF_DEALLOC (YDSC)

TYPE (SURFEX_FIELD_BUF_CACHE), INTENT (INOUT) :: YDSC

INTEGER (KIND=JPIM) :: I, ILEV

YDSC%LDUMMY = .FALSE.

IF (ASSOCIATED (YDSC%YIOFLDDESC))&
  & DEALLOCATE (YDSC%YIOFLDDESC)

IF (ASSOCIATED (YDSC%NBUF_FUNITS))&
  & DEALLOCATE (YDSC%NBUF_FUNITS)

IF (ASSOCIATED (YDSC%NBUF_FFILES))&
  & DEALLOCATE (YDSC%NBUF_FFILES)

IF (ASSOCIATED (YDSC%PBUF_FIELDS)) THEN

  DO I = 1, YDSC%N
    IF (ASSOCIATED(YDSC%P(I)%S_FX1%P)) THEN
      YDSC%P(I)%S_FX1%P => NULL ()
    ENDIF
    IF (ASSOCIATED(YDSC%P(I)%S_FX2)) THEN
      DO ILEV = 1, SIZE (YDSC%P(I)%S_FX2)
        YDSC%P(I)%S_FX2(ILEV)%P => NULL ()
      ENDDO
    ENDIF
  ENDDO

  DEALLOCATE (YDSC%PBUF_FIELDS)

ENDIF

DO I = 1, YDSC%N
  CALL SURFEX_FIELD_BUF_DEALLOC1 (YDSC%P(I), .FALSE.)
ENDDO

CALL SURFEX_FIELD_BUF_NULLIFY (YDSC)

YDSC%LALL_METADATA = .FALSE.

END SUBROUTINE SURFEX_FIELD_BUF_DEALLOC

SUBROUTINE ABOR1_MIS (YDSC,HREC)

TYPE (SURFEX_FIELD_BUF_CACHE), INTENT (INOUT) :: YDSC
CHARACTER (LEN=*), INTENT(IN) :: HREC

CALL SURFEX_FIELD_BUF_DUMP (YDSC)

WRITE (0, *) 'SURFEX FIELD CACHE:' // TRIM (HREC) // ' WAS NOT FOUND'
CALL FLUSH (0)
CALL ABOR1 ('SURFEX FIELD CACHE:' // TRIM (HREC) // ' WAS NOT FOUND')

END SUBROUTINE ABOR1_MIS

SUBROUTINE SURFEX_FIELD_BUF_GROW (YDSC)

TYPE (SURFEX_FIELD_BUF_CACHE), INTENT (INOUT) :: YDSC
TYPE (SURFEX_FIELD_BUF),       POINTER        :: P(:)

  IF (YDSC%N+1 > YDSC%NTOT) THEN
    P => YDSC%P
    YDSC%NTOT = 2 * YDSC%NTOT + 1
    ALLOCATE (YDSC%P(YDSC%NTOT))
    IF (ASSOCIATED (P)) THEN
      YDSC%P(1:YDSC%N) = P(1:YDSC%N)
      DEALLOCATE (P)
    ENDIF
  ENDIF

  YDSC%N = YDSC%N+1

END SUBROUTINE SURFEX_FIELD_BUF_GROW

! ADD

SUBROUTINE SURFEX_FIELD_BUF_ADD_T0 (YDSC,KYEAR,KMONTH,KDAY,PTIME,HREC)

TYPE (SURFEX_FIELD_BUF_CACHE), INTENT (INOUT) :: YDSC
INTEGER (KIND=JPIM),           INTENT(IN)     :: KYEAR
INTEGER (KIND=JPIM),           INTENT(IN)     :: KMONTH
INTEGER (KIND=JPIM),           INTENT(IN)     :: KDAY
REAL (KIND=JPRB),              INTENT(IN)     :: PTIME
CHARACTER (LEN=*),             INTENT(IN)     :: HREC

IF (MYPROC == 1 .OR. YDSC%LALL_METADATA) THEN

  CALL SURFEX_FIELD_BUF_GROW (YDSC)

  YDSC%P(YDSC%N)%T0%KYEAR  = KYEAR
  YDSC%P(YDSC%N)%T0%KMONTH = KMONTH
  YDSC%P(YDSC%N)%T0%KDAY   = KDAY
  YDSC%P(YDSC%N)%T0%PTIME  = PTIME

  YDSC%P(YDSC%N)%NAME = HREC
  YDSC%P(YDSC%N)%TYPE = 'T0'

ENDIF

END SUBROUTINE SURFEX_FIELD_BUF_ADD_T0

SUBROUTINE SURFEX_FIELD_BUF_ADD_T1 (YDSC,KYEAR,KMONTH,KDAY,PTIME,HREC)

TYPE (SURFEX_FIELD_BUF_CACHE), INTENT (INOUT) :: YDSC
INTEGER (KIND=JPIM),           INTENT(IN)     :: KYEAR  (:)
INTEGER (KIND=JPIM),           INTENT(IN)     :: KMONTH (:)
INTEGER (KIND=JPIM),           INTENT(IN)     :: KDAY   (:)
REAL (KIND=JPRB),              INTENT(IN)     :: PTIME  (:)
CHARACTER (LEN=*),             INTENT(IN)     :: HREC

IF (MYPROC == 1 .OR. YDSC%LALL_METADATA) THEN

  CALL SURFEX_FIELD_BUF_GROW (YDSC)

  ALLOCATE (YDSC%P(YDSC%N)%T1 (SIZE (KYEAR)))

  YDSC%P(YDSC%N)%NDIM(1) = SIZE (KYEAR)

  YDSC%P(YDSC%N)%T1%KYEAR  = KYEAR
  YDSC%P(YDSC%N)%T1%KMONTH = KMONTH
  YDSC%P(YDSC%N)%T1%KDAY   = KDAY
  YDSC%P(YDSC%N)%T1%PTIME  = PTIME

  YDSC%P(YDSC%N)%NAME = HREC
  YDSC%P(YDSC%N)%TYPE = 'T1'

ENDIF

END SUBROUTINE SURFEX_FIELD_BUF_ADD_T1

SUBROUTINE SURFEX_FIELD_BUF_ADD_N0 (YDSC,N0,HREC)

TYPE (SURFEX_FIELD_BUF_CACHE), INTENT (INOUT) :: YDSC
INTEGER (KIND=JPIM),           INTENT(IN)     :: N0
CHARACTER (LEN=*),             INTENT(IN)     :: HREC

IF (MYPROC == 1 .OR. YDSC%LALL_METADATA) THEN

  CALL SURFEX_FIELD_BUF_GROW (YDSC)

  YDSC%P(YDSC%N)%N0   = N0
  YDSC%P(YDSC%N)%NAME = HREC
  YDSC%P(YDSC%N)%TYPE = 'N0'

ENDIF

END SUBROUTINE SURFEX_FIELD_BUF_ADD_N0

SUBROUTINE SURFEX_FIELD_BUF_ADD_N1 (YDSC,N1,HREC)

TYPE (SURFEX_FIELD_BUF_CACHE), INTENT (INOUT) :: YDSC
INTEGER (KIND=JPIM),           INTENT (IN)    :: N1(:)
CHARACTER (LEN=*),             INTENT (IN)    :: HREC

IF (MYPROC == 1 .OR. YDSC%LALL_METADATA) THEN

  CALL SURFEX_FIELD_BUF_GROW (YDSC)

  ALLOCATE (YDSC%P(YDSC%N)%N1(SIZE(N1)))

  YDSC%P(YDSC%N)%NDIM(1) = SIZE (N1)

  YDSC%P(YDSC%N)%N1   = N1
  YDSC%P(YDSC%N)%NAME = HREC
  YDSC%P(YDSC%N)%TYPE = 'N1'

ENDIF

END SUBROUTINE SURFEX_FIELD_BUF_ADD_N1

SUBROUTINE SURFEX_FIELD_BUF_ADD_Y1(YDSC,Y1,HREC)

TYPE (SURFEX_FIELD_BUF_CACHE), INTENT (INOUT) :: YDSC
REAL (KIND=JPRB),              INTENT (IN)    :: Y1(:)
CHARACTER (LEN=*),             INTENT (IN)    :: HREC

IF (MYPROC == 1 .OR. YDSC%LALL_METADATA) THEN

  CALL SURFEX_FIELD_BUF_GROW (YDSC)

  ALLOCATE (YDSC%P(YDSC%N)%Y1(SIZE(Y1)))

  YDSC%P(YDSC%N)%NDIM(1) = SIZE (Y1)

  YDSC%P(YDSC%N)%Y1   = Y1
  YDSC%P(YDSC%N)%NAME = HREC
  YDSC%P(YDSC%N)%TYPE = 'Y1'

ENDIF

END SUBROUTINE SURFEX_FIELD_BUF_ADD_Y1

SUBROUTINE SURFEX_FIELD_BUF_ADD_C0(YDSC,C0,HREC)

TYPE (SURFEX_FIELD_BUF_CACHE), INTENT (INOUT) :: YDSC
CHARACTER (LEN=*),             INTENT (IN)    :: C0
CHARACTER (LEN=*),             INTENT (IN)    :: HREC

IF (MYPROC == 1 .OR. YDSC%LALL_METADATA) THEN

  CALL SURFEX_FIELD_BUF_GROW (YDSC)

  YDSC%P(YDSC%N)%C0   = C0
  YDSC%P(YDSC%N)%NAME = HREC
  YDSC%P(YDSC%N)%TYPE = 'C0'

ENDIF

END SUBROUTINE SURFEX_FIELD_BUF_ADD_C0

SUBROUTINE SURFEX_FIELD_BUF_ADD_X0(YDSC,X0,HREC)

TYPE (SURFEX_FIELD_BUF_CACHE), INTENT (INOUT) :: YDSC
REAL (KIND=JPRB),              INTENT (IN)    :: X0
CHARACTER (LEN=*),             INTENT (IN)    :: HREC

IF (MYPROC == 1 .OR. YDSC%LALL_METADATA) THEN

  CALL SURFEX_FIELD_BUF_GROW (YDSC)

  YDSC%P(YDSC%N)%X0   = X0
  YDSC%P(YDSC%N)%NAME = HREC
  YDSC%P(YDSC%N)%TYPE = 'X0'

ENDIF

END SUBROUTINE SURFEX_FIELD_BUF_ADD_X0

SUBROUTINE SURFEX_FIELD_BUF_ADD_S_FX1(YDSC,X1,HREC,CDMASK,KD1)

TYPE (SURFEX_FIELD_BUF_CACHE), INTENT (INOUT) :: YDSC
REAL (KIND=JPRB),              INTENT (IN)    :: X1 (:)
CHARACTER (LEN=*),             INTENT (IN)    :: HREC
CHARACTER (LEN=*),             INTENT (IN)    :: CDMASK
INTEGER (KIND=JPIM), OPTIONAL, INTENT (IN)    :: KD1

INTEGER (KIND=JPIM) :: I1
LOGICAL             :: LLD

LLD = PRESENT (KD1)

IF (LLD) THEN
  I1 = KD1
ELSE
  I1 = SIZE(X1)
ENDIF

CALL SURFEX_FIELD_BUF_GROW (YDSC)

IF (YDSC%LRECORD) THEN

  ALLOCATE (YDSC%P(YDSC%N)%S_FX1%P(I1))

  IF (LLD) THEN
    YDSC%P(YDSC%N)%S_FX1%P = 0.
  ELSE
    YDSC%P(YDSC%N)%S_FX1%P = X1
  ENDIF

ENDIF

YDSC%P(YDSC%N)%NDIM(1) = I1

YDSC%P(YDSC%N)%NAME = HREC
YDSC%P(YDSC%N)%TYPE = 'X1'
YDSC%P(YDSC%N)%MASK = CDMASK

END SUBROUTINE SURFEX_FIELD_BUF_ADD_S_FX1

SUBROUTINE SURFEX_FIELD_BUF_ADD_S_FX2(YDSC,X2,HREC,CDMASK,KD1,KD2)

TYPE (SURFEX_FIELD_BUF_CACHE), INTENT (INOUT) :: YDSC
REAL (KIND=JPRB),              INTENT (IN)    :: X2 (:,:)
CHARACTER (LEN=*),             INTENT (IN)    :: HREC
CHARACTER (LEN=*),             INTENT (IN)    :: CDMASK
INTEGER (KIND=JPIM), OPTIONAL, INTENT (IN)    :: KD1
INTEGER (KIND=JPIM), OPTIONAL, INTENT (IN)    :: KD2

INTEGER (KIND=JPIM) :: I1
INTEGER (KIND=JPIM) :: I2
INTEGER (KIND=JPIM) :: ILEV
LOGICAL             :: LLD

LLD = PRESENT (KD1) .AND. PRESENT (KD2)

IF (LLD) THEN
  I1 = KD1
  I2 = KD2
ELSE
  I1 = SIZE(X2,1)
  I2 = SIZE(X2,2)
ENDIF

CALL SURFEX_FIELD_BUF_GROW (YDSC)

IF (YDSC%LRECORD) THEN

  ALLOCATE (YDSC%P(YDSC%N)%S_FX2(I2))

  DO ILEV = 1, I2
    ALLOCATE (YDSC%P(YDSC%N)%S_FX2(ILEV)%P(I1))

    IF (LLD) THEN
      YDSC%P(YDSC%N)%S_FX2(ILEV)%P = 0.
    ELSE
      YDSC%P(YDSC%N)%S_FX2(ILEV)%P = X2 (:,ILEV)
    ENDIF

  ENDDO

ENDIF

YDSC%P(YDSC%N)%NDIM(1) = I1
YDSC%P(YDSC%N)%NDIM(2) = I2

YDSC%P(YDSC%N)%NAME = HREC
YDSC%P(YDSC%N)%TYPE = 'X2'
YDSC%P(YDSC%N)%MASK = CDMASK

END SUBROUTINE SURFEX_FIELD_BUF_ADD_S_FX2

SUBROUTINE SURFEX_FIELD_BUF_ADD_L0 (YDSC,L0,HREC)

TYPE (SURFEX_FIELD_BUF_CACHE), INTENT (INOUT) :: YDSC
LOGICAL,                       INTENT (IN)    :: L0
CHARACTER (LEN=*),             INTENT (IN)    :: HREC

IF (MYPROC == 1 .OR. YDSC%LALL_METADATA) THEN

  CALL SURFEX_FIELD_BUF_GROW (YDSC)

  YDSC%P(YDSC%N)%L0   = L0
  YDSC%P(YDSC%N)%NAME = HREC
  YDSC%P(YDSC%N)%TYPE = 'L0'

ENDIF

END SUBROUTINE SURFEX_FIELD_BUF_ADD_L0

SUBROUTINE SURFEX_FIELD_BUF_ADD_L1(YDSC,L1,HREC)

TYPE (SURFEX_FIELD_BUF_CACHE), INTENT (INOUT) :: YDSC
LOGICAL,                       INTENT (IN)    :: L1(:)
CHARACTER (LEN=*),             INTENT (IN)    :: HREC

IF (MYPROC == 1 .OR. YDSC%LALL_METADATA) THEN

  CALL SURFEX_FIELD_BUF_GROW (YDSC)

  ALLOCATE (YDSC%P(YDSC%N)%L1(SIZE(L1)))

  YDSC%P(YDSC%N)%NDIM(1) = SIZE (L1)

  YDSC%P(YDSC%N)%L1   = L1
  YDSC%P(YDSC%N)%NAME = HREC
  YDSC%P(YDSC%N)%TYPE = 'L1'

ENDIF

END SUBROUTINE SURFEX_FIELD_BUF_ADD_L1

! SET

SUBROUTINE SURFEX_FIELD_BUF_SET_T0 (YDSC,KYEAR,KMONTH,KDAY,PTIME,HREC)

TYPE (SURFEX_FIELD_BUF_CACHE), INTENT (INOUT) :: YDSC
INTEGER (KIND=JPIM),           INTENT (IN)    :: KYEAR
INTEGER (KIND=JPIM),           INTENT (IN)    :: KMONTH
INTEGER (KIND=JPIM),           INTENT (IN)    :: KDAY
REAL (KIND=JPRB),              INTENT (IN)    :: PTIME
CHARACTER (LEN=*),             INTENT (IN)    :: HREC

INTEGER :: IIND

CALL SURFEX_FIELD_BUF_SEARCH(YDSC,HREC,IIND)

YDSC%P(IIND)%T0%KYEAR  = KYEAR
YDSC%P(IIND)%T0%KMONTH = KMONTH
YDSC%P(IIND)%T0%KDAY   = KDAY
YDSC%P(IIND)%T0%PTIME  = PTIME

END SUBROUTINE SURFEX_FIELD_BUF_SET_T0

SUBROUTINE SURFEX_FIELD_BUF_SET_T1(YDSC,KYEAR,KMONTH,KDAY,PTIME,HREC)

TYPE (SURFEX_FIELD_BUF_CACHE), INTENT (INOUT) :: YDSC
INTEGER (KIND=JPIM),           INTENT (IN)    :: KYEAR  (:)
INTEGER (KIND=JPIM),           INTENT (IN)    :: KMONTH (:)
INTEGER (KIND=JPIM),           INTENT (IN)    :: KDAY   (:)
REAL (KIND=JPRB),              INTENT (IN)    :: PTIME  (:)
CHARACTER (LEN=*),             INTENT (IN)    :: HREC

INTEGER :: IIND

CALL SURFEX_FIELD_BUF_SEARCH(YDSC,HREC,IIND)

IF (SIZE (YDSC%P(IIND)%T1) /= SIZE (KYEAR)) THEN
  DEALLOCATE (YDSC%P(IIND)%T1)
  ALLOCATE (YDSC%P(IIND)%T1 (SIZE (KYEAR)))
  YDSC%P(IIND)%NDIM(1) = SIZE (KYEAR)
ENDIF


YDSC%P(IIND)%T1%KYEAR  = KYEAR
YDSC%P(IIND)%T1%KMONTH = KMONTH
YDSC%P(IIND)%T1%KDAY   = KDAY
YDSC%P(IIND)%T1%PTIME  = PTIME

END SUBROUTINE SURFEX_FIELD_BUF_SET_T1

SUBROUTINE SURFEX_FIELD_BUF_SET_N0(YDSC,N0,HREC)

TYPE (SURFEX_FIELD_BUF_CACHE), INTENT (INOUT) :: YDSC
INTEGER (KIND=JPIM),           INTENT (IN)    :: N0
CHARACTER (LEN=*),             INTENT (IN)    :: HREC

INTEGER :: IIND

CALL SURFEX_FIELD_BUF_SEARCH(YDSC,HREC,IIND)

YDSC%P(IIND)%N0 = N0

END SUBROUTINE SURFEX_FIELD_BUF_SET_N0

SUBROUTINE SURFEX_FIELD_BUF_SET_N1(YDSC,N1,HREC)

TYPE (SURFEX_FIELD_BUF_CACHE), INTENT (INOUT) :: YDSC
INTEGER (KIND=JPIM),           INTENT (IN)    :: N1(:)
CHARACTER (LEN=*),             INTENT (IN)    :: HREC

INTEGER :: IIND

CALL SURFEX_FIELD_BUF_SEARCH(YDSC,HREC,IIND)

IF (SIZE (YDSC%P(IIND)%N1) /= SIZE (N1)) THEN
  DEALLOCATE (YDSC%P(IIND)%N1)
  ALLOCATE (YDSC%P(IIND)%N1 (SIZE (N1)))
  YDSC%P(IIND)%NDIM(1) = SIZE (N1)
ENDIF

YDSC%P(IIND)%N1 = N1

END SUBROUTINE SURFEX_FIELD_BUF_SET_N1

SUBROUTINE SURFEX_FIELD_BUF_SET_Y1(YDSC,Y1,HREC)

TYPE (SURFEX_FIELD_BUF_CACHE), INTENT (INOUT) :: YDSC
REAL (KIND=JPRB),              INTENT (IN)    :: Y1(:)
CHARACTER (LEN=*),             INTENT (IN)    :: HREC

INTEGER :: IIND

CALL SURFEX_FIELD_BUF_SEARCH(YDSC,HREC,IIND)

IF (SIZE (YDSC%P(IIND)%Y1) /= SIZE (Y1)) THEN
  DEALLOCATE (YDSC%P(IIND)%Y1)
  ALLOCATE (YDSC%P(IIND)%Y1 (SIZE (Y1)))
  YDSC%P(IIND)%NDIM(1) = SIZE (Y1)
ENDIF

YDSC%P(IIND)%Y1 = Y1

END SUBROUTINE SURFEX_FIELD_BUF_SET_Y1

SUBROUTINE SURFEX_FIELD_BUF_SET_C0(YDSC,C0,HREC)

TYPE (SURFEX_FIELD_BUF_CACHE), INTENT (INOUT) :: YDSC
CHARACTER (LEN=*),             INTENT (IN)    :: C0
CHARACTER (LEN=*),             INTENT (IN)    :: HREC

INTEGER :: IIND

CALL SURFEX_FIELD_BUF_SEARCH(YDSC,HREC,IIND)

YDSC%P(IIND)%C0 = C0

END SUBROUTINE SURFEX_FIELD_BUF_SET_C0

SUBROUTINE SURFEX_FIELD_BUF_SET_X0(YDSC,X0,HREC)

TYPE (SURFEX_FIELD_BUF_CACHE), INTENT (INOUT) :: YDSC
REAL (KIND=JPRB),              INTENT (IN) :: X0
CHARACTER (LEN=*), INTENT(IN) :: HREC

INTEGER :: IIND

CALL SURFEX_FIELD_BUF_SEARCH(YDSC,HREC,IIND)

YDSC%P(IIND)%X0 = X0

END SUBROUTINE SURFEX_FIELD_BUF_SET_X0

SUBROUTINE SURFEX_FIELD_BUF_SET_L0(YDSC,L0,HREC)

TYPE (SURFEX_FIELD_BUF_CACHE), INTENT (INOUT) :: YDSC
LOGICAL,                       INTENT (IN)    :: L0
CHARACTER (LEN=*),             INTENT (IN)    :: HREC

INTEGER :: IIND

CALL SURFEX_FIELD_BUF_SEARCH(YDSC,HREC,IIND)

YDSC%P(IIND)%L0 = L0

END SUBROUTINE SURFEX_FIELD_BUF_SET_L0

SUBROUTINE SURFEX_FIELD_BUF_SET_L1(YDSC,L1,HREC)

TYPE (SURFEX_FIELD_BUF_CACHE), INTENT (INOUT) :: YDSC
LOGICAL,                       INTENT (IN)    :: L1(:)
CHARACTER (LEN=*),             INTENT (IN)    :: HREC

INTEGER :: IIND

CALL SURFEX_FIELD_BUF_SEARCH(YDSC,HREC,IIND)

IF (SIZE (YDSC%P(IIND)%L1) /= SIZE (L1)) THEN
  DEALLOCATE (YDSC%P(IIND)%L1)
  ALLOCATE (YDSC%P(IIND)%L1 (SIZE (L1)))
  YDSC%P(IIND)%NDIM(1) = SIZE (L1)
ENDIF

YDSC%P(IIND)%L1 = L1

END SUBROUTINE SURFEX_FIELD_BUF_SET_L1

! GET

FUNCTION SURFEX_FIELD_BUF_EXIST(YDSC,HREC)

LOGICAL                      :: SURFEX_FIELD_BUF_EXIST

TYPE (SURFEX_FIELD_BUF_CACHE), INTENT (INOUT) :: YDSC
CHARACTER (LEN=*),             INTENT (IN)    :: HREC

INTEGER (KIND=JPIM) :: I
REAL (KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK ('MODD_IO_SURF_ARO:SURFEX_FIELD_BUF_EXIST', 0, ZHOOK_HANDLE)

SURFEX_FIELD_BUF_EXIST = .FALSE.

DO I = 1, YDSC%N
  IF (YDSC%P(I)%NAME == HREC) THEN
    SURFEX_FIELD_BUF_EXIST = .TRUE.
    GOTO 999
  ENDIF
ENDDO

999 CONTINUE

IF (LHOOK) CALL DR_HOOK ('MODD_IO_SURF_ARO:SURFEX_FIELD_BUF_EXIST', 1, ZHOOK_HANDLE)

END FUNCTION SURFEX_FIELD_BUF_EXIST

SUBROUTINE SURFEX_FIELD_BUF_SEARCH_SAFE(YDSC,HREC,KRET,KIND)

TYPE (SURFEX_FIELD_BUF_CACHE), INTENT (INOUT) :: YDSC
CHARACTER (LEN=*),             INTENT (IN)    :: HREC
INTEGER (KIND=JPIM),           INTENT (OUT)   :: KRET, KIND
INTEGER (KIND=JPIM) :: I

KRET = 1

DO I = 1, YDSC%N
  IF (YDSC%P(I)%NAME == HREC) THEN
    KRET = 0
    EXIT
  ENDIF
ENDDO
KIND = I

END SUBROUTINE SURFEX_FIELD_BUF_SEARCH_SAFE

SUBROUTINE SURFEX_FIELD_BUF_SEARCH(YDSC,HREC,KIND)

TYPE (SURFEX_FIELD_BUF_CACHE), INTENT (INOUT) :: YDSC
CHARACTER (LEN=*),             INTENT (IN)    :: HREC
INTEGER,                       INTENT (OUT)   :: KIND

INTEGER (KIND=JPIM) :: IRET

CALL SURFEX_FIELD_BUF_SEARCH_SAFE (YDSC, HREC, IRET, KIND)

IF (IRET /= 0) THEN

  CALL ABOR1_MIS(YDSC,HREC)

ENDIF

END SUBROUTINE SURFEX_FIELD_BUF_SEARCH

SUBROUTINE SURFEX_FIELD_BUF_GET_REC (YDSC, KREC, YDREC)

TYPE (SURFEX_FIELD_BUF_CACHE), INTENT (INOUT) :: YDSC
INTEGER (KIND=JPIM),           INTENT (IN)    :: KREC
TYPE (SURFEX_FIELD_BUF),       POINTER        :: YDREC

YDREC => NULL ()

IF (KREC <= YDSC%N) YDREC => YDSC%P (KREC)

END SUBROUTINE SURFEX_FIELD_BUF_GET_REC

SUBROUTINE SURFEX_FIELD_BUF_GET_T0(YDSC,KYEAR,KMONTH,KDAY,PTIME,HREC)

TYPE (SURFEX_FIELD_BUF_CACHE), INTENT (INOUT) :: YDSC
INTEGER (KIND=JPIM),           INTENT (OUT)   :: KYEAR
INTEGER (KIND=JPIM),           INTENT (OUT)   :: KMONTH
INTEGER (KIND=JPIM),           INTENT (OUT)   :: KDAY
REAL (KIND=JPRB),              INTENT (OUT)   :: PTIME
CHARACTER (LEN=*),             INTENT (IN)    :: HREC

INTEGER :: IIND

CALL SURFEX_FIELD_BUF_SEARCH(YDSC,HREC,IIND)

KYEAR  = YDSC%P(IIND)%T0%KYEAR
KMONTH = YDSC%P(IIND)%T0%KMONTH
KDAY   = YDSC%P(IIND)%T0%KDAY
PTIME  = YDSC%P(IIND)%T0%PTIME

YDSC%P(IIND)%LREAD = .TRUE.

END SUBROUTINE SURFEX_FIELD_BUF_GET_T0

SUBROUTINE SURFEX_FIELD_BUF_GET_T1(YDSC,KYEAR,KMONTH,KDAY,PTIME,HREC)

TYPE (SURFEX_FIELD_BUF_CACHE), INTENT (INOUT) :: YDSC
INTEGER (KIND=JPIM),           INTENT (OUT)   :: KYEAR  (:)
INTEGER (KIND=JPIM),           INTENT (OUT)   :: KMONTH (:)
INTEGER (KIND=JPIM),           INTENT (OUT)   :: KDAY   (:)
REAL (KIND=JPRB),              INTENT (OUT) :: PTIME  (:)
CHARACTER (LEN=*),             INTENT (IN) :: HREC

INTEGER :: IIND

CALL SURFEX_FIELD_BUF_SEARCH(YDSC,HREC,IIND)

KYEAR  = YDSC%P(IIND)%T1%KYEAR
KMONTH = YDSC%P(IIND)%T1%KMONTH
KDAY   = YDSC%P(IIND)%T1%KDAY
PTIME  = YDSC%P(IIND)%T1%PTIME

YDSC%P(IIND)%LREAD = .TRUE.

END SUBROUTINE SURFEX_FIELD_BUF_GET_T1

SUBROUTINE SURFEX_FIELD_BUF_GET_N0(YDSC,N0,HREC)

TYPE (SURFEX_FIELD_BUF_CACHE), INTENT (INOUT) :: YDSC
INTEGER (KIND=JPIM),           INTENT (OUT)   :: N0
CHARACTER (LEN=*),             INTENT (IN)    :: HREC

INTEGER :: IIND

CALL SURFEX_FIELD_BUF_SEARCH(YDSC,HREC,IIND)

N0 = YDSC%P(IIND)%N0

YDSC%P(IIND)%LREAD = .TRUE.

END SUBROUTINE SURFEX_FIELD_BUF_GET_N0

SUBROUTINE SURFEX_FIELD_BUF_GET_N1(YDSC,N1,HREC)

TYPE (SURFEX_FIELD_BUF_CACHE), INTENT (INOUT) :: YDSC
INTEGER (KIND=JPIM),           POINTER        :: N1(:)
CHARACTER (LEN=*),             INTENT(IN)     :: HREC

INTEGER :: IIND

N1 => NULL ()

CALL SURFEX_FIELD_BUF_SEARCH(YDSC,HREC,IIND)

N1 => YDSC%P(IIND)%N1

YDSC%P(IIND)%LREAD = .TRUE.

END SUBROUTINE SURFEX_FIELD_BUF_GET_N1

SUBROUTINE SURFEX_FIELD_BUF_GET_Y1(YDSC,Y1,HREC)

TYPE (SURFEX_FIELD_BUF_CACHE), INTENT (INOUT) :: YDSC
REAL (KIND=JPRB),              POINTER        :: Y1(:)
CHARACTER (LEN=*),             INTENT (IN)    :: HREC

INTEGER :: IIND

Y1 => NULL ()

CALL SURFEX_FIELD_BUF_SEARCH(YDSC,HREC,IIND)

Y1 => YDSC%P(IIND)%Y1

YDSC%P(IIND)%LREAD = .TRUE.

END SUBROUTINE SURFEX_FIELD_BUF_GET_Y1

SUBROUTINE SURFEX_FIELD_BUF_GET_C0(YDSC,C0,HREC)

TYPE (SURFEX_FIELD_BUF_CACHE), INTENT (INOUT) :: YDSC
CHARACTER (LEN=*),             INTENT (OUT)   :: C0
CHARACTER (LEN=*),             INTENT (IN)    :: HREC

INTEGER :: IIND

CALL SURFEX_FIELD_BUF_SEARCH(YDSC,HREC,IIND)

C0 = YDSC%P(IIND)%C0

YDSC%P(IIND)%LREAD = .TRUE.

END SUBROUTINE SURFEX_FIELD_BUF_GET_C0

SUBROUTINE SURFEX_FIELD_BUF_GET_X0(YDSC,X0,HREC)

TYPE (SURFEX_FIELD_BUF_CACHE), INTENT (INOUT) :: YDSC
REAL (KIND=JPRB),              INTENT (OUT)   :: X0
CHARACTER (LEN=*),             INTENT (IN)    :: HREC

INTEGER :: IIND

CALL SURFEX_FIELD_BUF_SEARCH(YDSC,HREC,IIND)

X0 = YDSC%P(IIND)%X0

YDSC%P(IIND)%LREAD = .TRUE.

END SUBROUTINE SURFEX_FIELD_BUF_GET_X0

SUBROUTINE SURFEX_FIELD_BUF_GET_S_FX1(YDSC,YDS_FX1,HREC)

TYPE (SURFEX_FIELD_BUF_CACHE), INTENT (INOUT) :: YDSC
TYPE (SURFEX_FIELD_X),         POINTER        :: YDS_FX1
CHARACTER (LEN=*),             INTENT(IN)     :: HREC

INTEGER :: IIND

YDS_FX1 => NULL ()

CALL SURFEX_FIELD_BUF_SEARCH(YDSC,HREC,IIND)

YDS_FX1 => YDSC%P(IIND)%S_FX1

YDSC%P(IIND)%LREAD = .TRUE.

END SUBROUTINE SURFEX_FIELD_BUF_GET_S_FX1

SUBROUTINE SURFEX_FIELD_BUF_GET_S_FX2(YDSC,YDS_FX2,HREC)

TYPE (SURFEX_FIELD_BUF_CACHE), INTENT (INOUT) :: YDSC
TYPE (SURFEX_FIELD_X),         POINTER        :: YDS_FX2 (:)
CHARACTER (LEN=*),             INTENT (IN)    :: HREC

INTEGER :: IIND

YDS_FX2 => NULL ()

CALL SURFEX_FIELD_BUF_SEARCH(YDSC,HREC,IIND)

YDS_FX2 => YDSC%P(IIND)%S_FX2

YDSC%P(IIND)%LREAD = .TRUE.

END SUBROUTINE SURFEX_FIELD_BUF_GET_S_FX2

SUBROUTINE SURFEX_FIELD_BUF_GET_F(YDSC,YDREC,HREC)

TYPE (SURFEX_FIELD_BUF_CACHE), INTENT (INOUT) :: YDSC
TYPE (SURFEX_FIELD_BUF),       POINTER        :: YDREC
CHARACTER (LEN=*),             INTENT (IN)    :: HREC

INTEGER :: IIND

YDREC => NULL ()

CALL SURFEX_FIELD_BUF_SEARCH(YDSC,HREC,IIND)

YDREC => YDSC%P(IIND)

YDREC%LREAD = .TRUE.

END SUBROUTINE SURFEX_FIELD_BUF_GET_F

SUBROUTINE SURFEX_FIELD_BUF_GET_L0(YDSC,L0,HREC)

TYPE (SURFEX_FIELD_BUF_CACHE), INTENT (INOUT) :: YDSC
LOGICAL,                       INTENT (OUT)   :: L0
CHARACTER (LEN=*),             INTENT (IN)    :: HREC

INTEGER :: IIND

CALL SURFEX_FIELD_BUF_SEARCH(YDSC,HREC,IIND)

L0 = YDSC%P(IIND)%L0

YDSC%P(IIND)%LREAD = .TRUE.

END SUBROUTINE SURFEX_FIELD_BUF_GET_L0

SUBROUTINE SURFEX_FIELD_BUF_GET_L1(YDSC,L1,HREC)

TYPE (SURFEX_FIELD_BUF_CACHE), INTENT (INOUT) :: YDSC
LOGICAL,                       POINTER        :: L1(:)
CHARACTER (LEN=*),             INTENT (IN)    :: HREC

INTEGER :: IIND

L1 => NULL ()

CALL SURFEX_FIELD_BUF_SEARCH(YDSC,HREC,IIND)

L1 => YDSC%P(IIND)%L1

YDSC%P(IIND)%LREAD = .TRUE.

END SUBROUTINE SURFEX_FIELD_BUF_GET_L1

! sfxfilter

SUBROUTINE SURFEX_FIELD_BUF_FILTER(CDFI, CDFO, CDFN)
!     O. Marsden: June 2015 CY42 YRGMV, YRGFL, YRSURF, YRGMV5, and YRGFL5 are now passed by argument

USE GEOMETRY_MOD , ONLY : GEOMETRY
USE FA_MOD, ONLY : FA => FA_COM_DEFAULT

CHARACTER (LEN=*), INTENT (IN) :: CDFI            ! file 1
CHARACTER (LEN=*), INTENT (IN) :: CDFO            ! file 2
CHARACTER (LEN=*), INTENT (IN) :: CDFN            ! namelist

#include "wrgp2fa_compress.intfb.h"

INTEGER (KIND=JPIM), PARAMETER :: INUMERI = 77
INTEGER (KIND=JPIM), PARAMETER :: INUMERO = 78
INTEGER (KIND=JPIM), PARAMETER :: INUMERN =  4

INTEGER (KIND=JPIM) :: IA, IB, INS, INR, ILEV, INL

! namelist parameters
INTEGER (KIND=JPIM),  PARAMETER :: INLMAX = 4096
CHARACTER (LEN=32)  :: CLNOMA (INLMAX)
CHARACTER (LEN=2)   :: CLTYPA (INLMAX)
CHARACTER (LEN=16)  :: CLMASK (INLMAX)
INTEGER (KIND=JPIM) :: IDIMSA (2,INLMAX)

LOGICAL, ALLOCATABLE :: LLFILTER (:)
LOGICAL, ALLOCATABLE :: LLINSERT (:)

! lfi & fa arguments, arrays, etc...
REAL (KIND=JPRB),    ALLOCATABLE :: ZBUF (:)
INTEGER (KIND=JPIM) :: IREP, INBARI, ILONG, IPOSEX, IRANGC, IRANG
REAL (KIND=JPRB),    ALLOCATABLE :: ZGPG (:), ZVALCO (:)
INTEGER (KIND=JPIM) :: IDATEF (11)

TYPE (IOFLDDESC) :: YLFLDSC
TYPE (IOCPTDESC) :: YLCPDSC
CHARACTER (LEN=32)  :: CLNOM

INTEGER (KIND=JPIM) :: IGPTOTG

! surfex cache structs
TYPE (SURFEX_FIELD_BUF_CACHE) :: YLSFXC
TYPE (SURFEX_FIELD_BUF), POINTER :: YLSFXF (:)

REAL (KIND=JPRB) :: ZHOOK_HANDLE

#define TESTIREP(M) IF(IREP/=0)THEN;PRINT*,M,'@',__FILE__,':',__LINE__;STOP 1;ENDIF

IF (LHOOK) CALL DR_HOOK ('MODD_IO_SURF_ARO:SURFEX_FIELD_BUF_FILTER', 0, ZHOOK_HANDLE)

YLFLDSC%JBITS  = NBPDG


! open SURFEX files

CALL FAITOU (IREP, INUMERI, .TRUE., CDFI, 'OLD', .TRUE., .FALSE., 2, 0, INBARI, 'CADRE-SFX')
TESTIREP ("CANNOT OPEN "//TRIM(CDFI))

CALL FADIES (IREP, INUMERI, IDATEF)
TESTIREP ("CANNOT FADIES "//TRIM(CDFI))

CALL FAITOU (IREP, INUMERO, .TRUE., CDFO, 'NEW', .TRUE., .FALSE., 2, 0, INBARI, 'CADRE-SFX')
TESTIREP ("CANNOT OPEN "//TRIM(CDFO))

CALL FANDAR (IREP, INUMERO, IDATEF)
TESTIREP ("CANNOT FANDAR "//TRIM(CDFO))

! read index & small parameters

CALL SURFEX_FIELD_BUF_READ_MISC(YLSFXC, KUNIT=INUMERI)

! read namelist

OPEN (INUMERN, FILE = TRIM (CDFN), FORM = 'FORMATTED', STATUS = 'OLD')

CALL RCN (INUMERN, CLNOMA, CLTYPA, CLMASK, IDIMSA)

CLOSE (INUMERN)

INL = COUNT (CLNOMA /= '')

! process namelist; filtered fields

ALLOCATE (LLFILTER (SIZE (YLSFXC%P)))
LLFILTER = .TRUE.

DO IA = 1, SIZE (YLSFXC%P)
  IF (ANY (CLNOMA == '-'//TRIM (YLSFXC%P (IA)%NAME))) THEN
    LLFILTER (IA) = .FALSE.
  ENDIF
ENDDO

! process namelist; fields to be added

ALLOCATE (LLINSERT (INL))
LLINSERT = .FALSE.

DO IA = 1, INL
  IF (CLNOMA (IA)(1:1) == '+') THEN
    IF (.NOT. ANY (YLSFXC%P (:)%NAME == CLNOMA (IA)(2:))) THEN
      LLINSERT (IA) = .TRUE.
    ENDIF
  ENDIF
ENDDO

! grok IGPTOTG

CALL FANUMU (INUMERI, IRANG)
IRANGC = FA%FICHIER (IRANG)%NUCADR
IGPTOTG = FA%CADRE (MAX (1, IRANGC))%NVAPDG

! allocate new field list

INS = COUNT (LLFILTER)
INR = COUNT (LLINSERT)

ALLOCATE (YLSFXF (INS+INR))

IB = 0
DO IA = 1, SIZE (YLSFXC%P)
  IF (LLFILTER (IA)) THEN
    IB = IB + 1
    YLSFXF (IB) = YLSFXC%P(IA)
  ENDIF
ENDDO

! add new fields

DO IA = 1, INL
  IF (LLINSERT (IA)) THEN
    IB = IB + 1
    YLSFXF (IB)%NAME = CLNOMA (IA)(2:)
    YLSFXF (IB)%NDIM = IDIMSA (:,IA)
    YLSFXF (IB)%TYPE = CLTYPA (IA)
    YLSFXF (IB)%MASK = CLMASK (IA)
    IF ((YLSFXF (IB)%TYPE == 'X1') .OR.&
   &    (YLSFXF (IB)%TYPE == 'X2')) THEN
      IF (IGPTOTG == -1) CALL ABOR1 ("CANNOT GUESS IGPTOTG")
      YLSFXF (IB)%NDIM (1) = IGPTOTG
    ENDIF
  ENDIF
ENDDO

! set new field list

DEALLOCATE (YLSFXC%P)
YLSFXC%P    => YLSFXF
YLSFXC%N    = INS+INR
YLSFXC%NTOT = INS+INR

! write index & small parameters

CALL SURFEX_FIELD_BUF_WRITE_MISC(YLSFXC, INUMERO)

! copy fields from file 1 to file 2

DO IB = 1, INS

  IF (YLSFXC%P (IB)%TYPE == 'X1') THEN

    CLNOM = TRIM(CPREFIX_SFX1) // TRIM (YLSFXC%P (IB)%NAME)

    CALL LFINFO (IREP, INUMERI, CLNOM, ILONG, IPOSEX)
    TESTIREP ("CANNOT LFINFO "//TRIM(CDFI))

    ALLOCATE (ZBUF (ILONG))

    CALL LFILEC (IREP, INUMERI, CLNOM, ZBUF, ILONG)
    TESTIREP ("CANNOT LFILEC "//TRIM(CDFI))

    CALL LFIECR (IREP, INUMERO, CLNOM, ZBUF, ILONG)
    TESTIREP ("CANNOT LFIECR "//TRIM(CDFO))

    DEALLOCATE (ZBUF)

  ELSE IF (YLSFXC%P (IB)%TYPE == 'X2') THEN

    DO ILEV = 1, YLSFXC%P (IB)%NDIM (2)

      WRITE (CLNOM, '("X",I3.3)') ILEV
      CLNOM = TRIM (CLNOM) // YLSFXC%P (IB)%NAME

      CALL LFINFO (IREP, INUMERI, CLNOM, ILONG, IPOSEX)
      TESTIREP ("CANNOT LFINFO "//TRIM(CDFI))

      ALLOCATE (ZBUF (ILONG))

      CALL LFILEC (IREP, INUMERI, CLNOM, ZBUF, ILONG)
      TESTIREP ("CANNOT LFILEC "//TRIM(CDFI))

      CALL LFIECR (IREP, INUMERO, CLNOM, ZBUF, ILONG)
      TESTIREP ("CANNOT LFIECR "//TRIM(CDFO))

      DEALLOCATE (ZBUF)

    ENDDO

  ENDIF

ENDDO

! add new fields to file 2

DO IB = INS+1, INS+INR


  IF (YLSFXC%P (IB)%TYPE == 'X1') THEN

    ALLOCATE (ZGPG (YLSFXC%P (IB)%NDIM (1)), ZVALCO (YLSFXC%P (IB)%NDIM (1)+2))
    ZGPG = 0._JPRB

    YLFLDSC%CPREF = CPREFIX_SFX1
    YLFLDSC%CSUFF = TRIM (YLSFXC%P (IB)%NAME)
    YLFLDSC%ILEVG = 0
    CALL WRGP2FA_COMPRESS (INUMERO, YLFLDSC, ZGPG, ZVALCO, YLCPDSC)

    CALL LFIECR (IREP, INUMERO, YLCPDSC%CNOMA, ZVALCO, YLCPDSC%ILONGD)
    TESTIREP ("CANNOT LFIECR "//TRIM(CDFO))

    DEALLOCATE (ZGPG, ZVALCO)

  ELSE IF (YLSFXC%P (IB)%TYPE == 'X2') THEN

    ALLOCATE (ZGPG (YLSFXC%P (IB)%NDIM (1)), ZVALCO (YLSFXC%P (IB)%NDIM (1)+2))
    ZGPG = 0._JPRB

    DO ILEV = 1, YLSFXC%P (IB)%NDIM (2)

      YLFLDSC%CPREF = CPREFIX_SFX2
      YLFLDSC%CSUFF = TRIM (YLSFXC%P (IB)%NAME)
      YLFLDSC%ILEVG = ILEV
      CALL WRGP2FA_COMPRESS (INUMERO, YLFLDSC, ZGPG, ZVALCO, YLCPDSC)

      CALL LFIECR (IREP, INUMERO, YLCPDSC%CNOMA, ZVALCO, YLCPDSC%ILONGD)
      TESTIREP ("CANNOT LFIECR "//TRIM(CDFO))

    ENDDO

    DEALLOCATE (ZGPG, ZVALCO)

  ENDIF

ENDDO


! close files

CALL FAIRME (IREP, INUMERI, 'KEEP')
TESTIREP ("CANNOT CLOSE "//TRIM(CDFI))

CALL FAIRME (IREP, INUMERO, 'KEEP')
TESTIREP ("CANNOT CLOSE "//TRIM(CDFO))

CALL SURFEX_FIELD_BUF_DEALLOC (YLSFXC)

IF (LHOOK) CALL DR_HOOK ('MODD_IO_SURF_ARO:SURFEX_FIELD_BUF_FILTER', 1, ZHOOK_HANDLE)

CONTAINS

SUBROUTINE RCN (KLUN, CDNOMA, CDTYPA, CDMASK, KDIMSA)

INTEGER (KIND=JPIM) :: KLUN
CHARACTER (LEN=32)   :: CDNOMA (INLMAX)
CHARACTER (LEN=2)    :: CDTYPA (INLMAX)
CHARACTER (LEN=16)   :: CDMASK (INLMAX)
INTEGER (KIND=JPIM) :: KDIMSA (2,INLMAX)

NAMELIST / NAMSFXFILTER / CDNOMA, CDTYPA, KDIMSA, CDMASK

CDNOMA = ''
CDTYPA = ''
KDIMSA = 0

READ (KLUN, NML = NAMSFXFILTER)

END SUBROUTINE RCN

#undef TESTIREP

END SUBROUTINE SURFEX_FIELD_BUF_FILTER

END MODULE MODD_IO_SURF_ARO

