MODULE ATLAS_ARPEGE_MODULE

USE FCKIT_MODULE, ONLY : FCKIT_MPI_COMM

USE FA_MOD, ONLY : FA_COM_DEFAULT, NEW_FA_DEFAULT, FACADR

USE PARKIND1, ONLY : JPRB, JPIM
USE ATLAS_MODULE

IMPLICIT NONE

REAL (KIND=JPRB), PARAMETER :: RPI = 2.0_JPRB * ASIN (1.0_JPRB), &
                             & R2PI = 2._JPRB * RPI,             &
                             & RAD2DEG = 180._JPRB / RPI,        &
                             & DEG2RAD = RPI / 180._JPRB

CONTAINS

SUBROUTINE OFA (KLUN, CDFILENAME, YDGRID)

USE XRD_UNIX_ENV, ONLY : XRD_ISDIGIT

INTEGER (KIND=JPIM),           INTENT (IN) :: KLUN
CHARACTER (LEN=*),             INTENT (IN) :: CDFILENAME
CLASS (ATLAS_STRUCTUREDGRID),  INTENT (IN) :: YDGRID

#include "abor1.intfb.h"

TYPE (ATLAS_CONFIG) :: YLCONF
TYPE (ATLAS_CONFIG) :: YLCFPR ! projection
TYPE (ATLAS_CONFIG) :: YLCFDO ! domain

CHARACTER (LEN=*), PARAMETER   :: CLNOMC = 'c'
CHARACTER (LEN=:), ALLOCATABLE :: CLPRTY, CLDOTY
LOGICAL :: LLFOUND
LOGICAL :: LLELAM

YLCONF = YDGRID%SPEC ()

!PRINT *, YLCONF%JSON ()

LLFOUND = YLCONF%GET ("projection", YLCFPR)
LLFOUND = YLCONF%GET ("domain",     YLCFDO)
LLFOUND = YLCFDO%GET ("type",       CLDOTY)
LLFOUND = YLCFPR%GET ("type",       CLPRTY)

! Guess geometry : either global ARPEGE or AROME

IF ((CLPRTY == 'rotated_schmidt') .AND. (CLDOTY == 'global')) THEN
  LLELAM = .FALSE.
  GOTO 100
ENDIF

IF ((CLPRTY == 'lonlat') .AND. (CLDOTY == 'global')) THEN
  LLELAM = .FALSE.
  GOTO 100
ENDIF

IF ((CLPRTY == 'lambert_conformal_conic') .AND. (CLDOTY == 'rectangular')) THEN
  LLELAM = .TRUE.
  GOTO 100
ENDIF

200 CONTINUE

PRINT *, " CLPRTY = ", CLPRTY
PRINT *, " CLDOTY = ", CLDOTY
PRINT *, 'UNKNOWN GEOMETRY : '//YLCONF%JSON ()
CALL ABOR1 ('UNKNOWN GEOMETRY : '//YLCONF%JSON ())

100 CONTINUE

IF (LLELAM) THEN
  CALL OFA_LAM
ELSE
  CALL OFA_GLO
ENDIF

BLOCK
  INTEGER (KIND=JPIM) :: INBARP, INBARI, IREP
  INBARP = 0; INBARI = 0
  CALL FAITOU (IREP, KLUN, .TRUE., TRIM (CDFILENAME), 'NEW', &
             & .TRUE., .TRUE., 2_JPIM, INBARP, INBARI, CLNOMC)
  CALL FACAGE (CLNOMC, .FALSE.)
  IF (LLELAM) THEN
    CALL FAUTIF (IREP, KLUN, 'ALD')
  ELSE
    CALL FAUTIF (IREP, KLUN, 'ARP')
  ENDIF
ENDBLOCK

BLOCK
  INTEGER (KIND=JPIM) :: IDATEF (11), IREP
  IDATEF = [1990,  2, 15, 12,  0,   1,  0, 24,   1, 0, 0]
  CALL FANDAR (IREP, KLUN, IDATEF)
ENDBLOCK

CALL YLCFPR%FINAL ()
CALL YLCFDO%FINAL ()
CALL YLCONF%FINAL ()

CONTAINS

SUBROUTINE OFA_LAM
REAL (KIND=JPRB) :: ZAHYBR (2), ZBHYBR (2), ZSLAPO, ZCLOPO, ZSLOPO, ZCODIL, ZREFER, ZSINLA (18)
INTEGER (KIND=JPIM) :: INIVER, ITYPTR, ITRONC, INLATI, INXLON
INTEGER (KIND=JPIM) :: INLOPA (8), INOZPA (1)
REAL (KIND=JPRB) :: XMIN, XMAX, YMIN, YMAX
REAL (KIND=JPRB) :: DXINMETRES, DYINMETRES
REAL (KIND=JPRB) :: LOVINDEGREES, LADINDEGREES, LATIN1INDEGREES, LATIN2INDEGREES
INTEGER (KIND=JPIM) :: NUX, NUY, NX, NY
REAL (KIND=JPRB) :: ZLONLATSW (2), ZLONLATNE (2)
TYPE (ATLAS_CONFIG) :: YLCFXS ! xspace
TYPE (ATLAS_CONFIG) :: YLCFYS ! yspace

LLFOUND = YLCONF%GET ("xspace",     YLCFXS)
LLFOUND = YLCONF%GET ("yspace",     YLCFYS)

LLFOUND = YLCFPR%GET ("latitude0",  LADINDEGREES   )
LLFOUND = YLCFPR%GET ("longitude0", LOVINDEGREES   )
LLFOUND = YLCFPR%GET ("latitude1",  LATIN1INDEGREES)
LLFOUND = YLCFPR%GET ("latitude2",  LATIN2INDEGREES)
LLFOUND = YLCFDO%GET ("xmin",       XMIN           )
LLFOUND = YLCFDO%GET ("xmax",       XMAX           )
LLFOUND = YLCFDO%GET ("ymin",       YMIN           )
LLFOUND = YLCFDO%GET ("ymax",       YMAX           )
LLFOUND = YLCFXS%GET ("N",          NX             )
LLFOUND = YLCFYS%GET ("N",          NY             )

DXINMETRES = (XMAX - XMIN) / REAL (NX - 1, JPRB)
DYINMETRES = (YMAX - YMIN) / REAL (NY - 1, JPRB)

NUX =  NINT (-2 * XMIN / DXINMETRES)
NUY =  NINT (-2 * YMIN / DYINMETRES)

INLATI = NY
INXLON = NX
ZSLAPO = 0._JPRB
ZCLOPO = 0._JPRB
ZSLOPO = 0._JPRB
ZCODIL = 0._JPRB
ZREFER = 0._JPRB
INIVER = 1_JPIM
ZAHYBR = 0._JPRB
ZBHYBR = 0._JPRB 
INLOPA = [10_JPIM, 1_JPIM, 1_JPIM, NUX+1, 1_JPIM, NUY+1, 8_JPIM, 8_JPIM]
ITRONC = +INLATI / 2 - 1
ITYPTR = -INXLON / 2 + 1

ZLONLATSW = YDGRID%LONLAT (    1,     1)
ZLONLATNE = YDGRID%LONLAT (NUX+1, NUY+1)

ZSINLA = [-1._JPRB, SIN (DEG2RAD * LADINDEGREES), DEG2RAD * LOVINDEGREES, DEG2RAD * LADINDEGREES, &
       &  DEG2RAD * LOVINDEGREES, DEG2RAD * LADINDEGREES, DXINMETRES, DYINMETRES, &
       &  INXLON * DXINMETRES, INLATI * DYINMETRES, 0._JPRB, 0._JPRB, ZLONLATSW (1) * DEG2RAD, &
       &  ZLONLATSW (2) * DEG2RAD, ZLONLATNE (1) * DEG2RAD, ZLONLATNE (2) * DEG2RAD, 0._JPRB, 0._JPRB ]




CALL FACADE (CLNOMC, ITYPTR, ZSLAPO, ZCLOPO, ZSLOPO, &
&            ZCODIL, ITRONC, INLATI, INXLON, INLOPA, &
&            INOZPA, ZSINLA, INIVER, ZREFER, ZAHYBR, &
&            ZBHYBR, .FALSE.)

CALL YLCFXS%FINAL ()
CALL YLCFYS%FINAL ()

END SUBROUTINE

SUBROUTINE OFA_GLO
REAL (KIND=JPRB) :: ZAHYBR (2), ZBHYBR (2), ZSLAPO, ZCLOPO, ZSLOPO, ZCODIL, ZREFER
INTEGER (KIND=JPIM) :: INIVER, ITYPTR, ITRONC, INLATI, INXLON
REAL (KIND=JPRB), ALLOCATABLE :: ZCENTRE (:), RMU (:)
INTEGER (KIND=JPIM), ALLOCATABLE :: NLOENG (:), INOZPA (:)
INTEGER (KIND=JPIM) :: NDGLG, IGLG

IF (CLPRTY == 'rotated_schmidt') THEN
  LLFOUND = YLCFPR%GET ("north_pole",        ZCENTRE)
  LLFOUND = YLCFPR%GET ("stretching_factor", ZCODIL )
ELSE 
  ALLOCATE (ZCENTRE (2))
  ZCENTRE = [0._JPRB, 90._JPRB]
  ZCODIL = 1._JPRB
ENDIF

NDGLG  = YDGRID%NY ()
NLOENG = YDGRID%NX_ARRAY ()

INIVER = 1_JPIM
ZAHYBR = 0._JPRB
ZBHYBR = 0._JPRB
ITYPTR = 2_JPIM
!

ZSLAPO = SIN (ZCENTRE (2) * DEG2RAD)
ZCLOPO = COS (ZCENTRE (1) * DEG2RAD)
ZSLOPO = SIN (ZCENTRE (1) * DEG2RAD)
ITRONC = NDGLG-1
INLATI = NDGLG
INXLON = MAXVAL (NLOENG)
ALLOCATE (INOZPA (NDGLG))
INOZPA = MIN (ITRONC, NLOENG/2_JPIM-1_JPIM)
ZREFER = 1._JPRB

ALLOCATE (RMU (NDGLG))

DO IGLG = 1, NDGLG
  RMU (IGLG) = SIN (YDGRID%Y (IGLG) * DEG2RAD)
ENDDO

CALL FACADE (CLNOMC, ITYPTR, ZSLAPO, ZCLOPO, ZSLOPO, &
&            ZCODIL, ITRONC, INLATI, INXLON, NLOENG, &
&            INOZPA, RMU,    INIVER, ZREFER, ZAHYBR, &
&            ZBHYBR, .FALSE.)

    
END SUBROUTINE

END SUBROUTINE

SUBROUTINE WFA (CDFILENAME, YDGRID, YDSTCO, YDFLSL)

USE FCKIT_MODULE, ONLY : FCKIT_MPI_COMM

CHARACTER (LEN=*),                            INTENT (IN) :: CDFILENAME
CLASS (ATLAS_STRUCTUREDGRID),                 INTENT (IN) :: YDGRID
TYPE (ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS), INTENT (IN) :: YDSTCO
TYPE (ATLAS_FIELDSET),                        INTENT (IN) :: YDFLSL

#include "abor1.intfb.h"
#include "faieno.h"

INTEGER (KIND=JPIM), ALLOCATABLE :: ITO (:)
TYPE (ATLAS_FIELD),  ALLOCATABLE :: YLFLDL (:)
TYPE (ATLAS_FIELD),  ALLOCATABLE :: YLFLDG (:)

TYPE (ATLAS_FIELDSET) :: YLFLSG
INTEGER (KIND=JPIM) :: MYPROC, NPROC, IPROC
INTEGER (KIND=JPIM) :: JFLD1, JFLD2, INFLD, JFLD
TYPE (FCKIT_MPI_COMM) :: YLCOMM
CHARACTER (LEN=128) :: CLFILENAME, CLPROC
INTEGER (KIND=JPIM) :: ILUN, IREP

YLCOMM = FCKIT_MPI_COMM ()
MYPROC = YLCOMM%RANK () + 1
NPROC  = YLCOMM%SIZE ()
INFLD = YDFLSL%SIZE ()

ALLOCATE (ITO (INFLD), YLFLDL (INFLD), YLFLDG (INFLD))

DO IPROC = 1, NPROC
  JFLD1 = 1 + ((IPROC-1) * INFLD) / NPROC
  JFLD2 = 0 + ((IPROC+0) * INFLD) / NPROC
  ITO (JFLD1:JFLD2) = IPROC
ENDDO

WRITE (CLPROC, '(".",I4.4)') MYPROC
CLFILENAME = TRIM (CDFILENAME)//TRIM (CLPROC)

ILUN = 77

IF (ANY (ITO == MYPROC)) THEN
  CALL OFA (ILUN, CLFILENAME, YDGRID)
  BLOCK
    INTEGER (KIND=JPIM) :: INGRIB, INARG1, INARG2, INARG3, INARG4, INARG5
    CALL FAVEUR (IREP, ILUN, INGRIB, INARG1, INARG2, INARG3, INARG4, INARG5)
    INGRIB = 123_JPIM
    CALL FAGOTE (IREP, ILUN, INGRIB, INARG1, INARG2, INARG3, INARG4, INARG5)
  ENDBLOCK
ENDIF

YLFLSG = ATLAS_FIELDSET ()

DO JFLD = 1, INFLD
BLOCK
  CHARACTER (LEN=16)  :: CLNOMA
  INTEGER (KIND=JPIM) :: ISIZEG
  TYPE (ATLAS_METADATA) :: YLMETG

! Distributed field 
  YLFLDL (JFLD) = YDFLSL%FIELD (JFLD)

  CLNOMA = YLFLDL (JFLD)%NAME ()

! Global field; zero size if this proc does not write the field
  ISIZEG = 0
  IF (ITO (JFLD) == MYPROC) ISIZEG = INT (YDGRID%SIZE (), JPIM)
  YLFLDG (JFLD) = ATLAS_FIELD (NAME=CLNOMA, KIND=JPRB, SHAPE=[ISIZEG])
  YLMETG = YLFLDG (JFLD)%METADATA ()
! Set owner
  CALL YLMETG%SET ("owner", ITO (JFLD)-1)
  CALL YLMETG%FINAL ()
  CALL YLFLSG%ADD (YLFLDG (JFLD))

ENDBLOCK
ENDDO

CALL YDSTCO%GATHER (YDFLSL, YLFLSG)

DO JFLD = 1, INFLD
  IF (ITO (JFLD) == MYPROC) THEN 
  BLOCK
    REAL (KIND=JPRB), POINTER :: ZFLDG (:)
    TYPE (ATLAS_METADATA) :: YLMETL
    INTEGER (KIND=JPIM) :: INIVAU
    CHARACTER (LEN=:), ALLOCATABLE :: CLSUFF, CLPREF
    YLMETL = YLFLDL (JFLD)%METADATA ()
    INIVAU = 0_JPIM
    CALL YLMETL%GET ("INIVAU", INIVAU)
    CALL YLMETL%GET ("CLPREF", CLPREF)
    IF (.NOT. ALLOCATED (CLPREF)) THEN
      CLPREF = "SURF"
    ENDIF
    CALL YLMETL%GET ("CLSUFF", CLSUFF) 
    IF (.NOT. ALLOCATED (CLSUFF)) THEN
      CLSUFF = "UNKNOWN"
    ENDIF
    CALL YLFLDG (JFLD)%DATA (ZFLDG)
    CALL FAIENO (IREP, ILUN, CLPREF, INIVAU, CLSUFF, ZFLDG, .FALSE.)
    CALL YLMETL%FINAL ()
  ENDBLOCK
  ENDIF
ENDDO


IF (ANY (ITO == MYPROC)) THEN
  CALL FAIRME (IREP, ILUN, 'KEEP')
ENDIF

DO JFLD = 1, INFLD
  CALL YLFLDG (JFLD)%FINAL ()
  CALL YLFLDL (JFLD)%FINAL ()
ENDDO

CALL YLFLSG%FINAL ()

END SUBROUTINE

SUBROUTINE RFA (CDFILENAME, YDGRID, YDSTCO, CDPREF, KNIVAU, CDSUFF, YDFLSL)

USE FCKIT_MODULE, ONLY : FCKIT_MPI_COMM

CHARACTER (LEN=*),     INTENT (IN) :: CDFILENAME
CLASS (ATLAS_STRUCTUREDGRID),                 INTENT (IN) :: YDGRID
TYPE (ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS), INTENT (IN) :: YDSTCO
CHARACTER (LEN=*),     INTENT (IN) :: CDPREF (:)
INTEGER (KIND=JPIM),   INTENT (IN) :: KNIVAU (:)
CHARACTER (LEN=*),     INTENT (IN) :: CDSUFF (:)
TYPE (ATLAS_FIELDSET), INTENT (INOUT) :: YDFLSL

#include "facilo.h"

CHARACTER (LEN=*), PARAMETER :: CLNOMC = 'c'
INTEGER (KIND=JPIM) :: ILUN, INBARP, INBARI, IREP
INTEGER (KIND=JPIM) :: MYPROC, NPROC, IPROC
INTEGER (KIND=JPIM) :: JFLD1, JFLD2, INFLD, JFLD
INTEGER (KIND=JPIM) :: IFROM (SIZE (CDPREF))
TYPE (ATLAS_FIELD)  :: YLFLDL (SIZE (CDPREF))
TYPE (ATLAS_FIELD)  :: YLFLDG (SIZE (CDPREF))
TYPE (ATLAS_FIELDSET) :: YLFLSG
TYPE (FCKIT_MPI_COMM) :: YLCOMM

YLCOMM = FCKIT_MPI_COMM ()
MYPROC = YLCOMM%RANK () + 1
NPROC  = YLCOMM%SIZE ()
INFLD  = SIZE (CDPREF)

YDFLSL = ATLAS_FIELDSET ()
YLFLSG = ATLAS_FIELDSET ()

DO IPROC = 1, NPROC
  JFLD1 = 1 + ((IPROC-1) * INFLD) / NPROC
  JFLD2 = 0 + ((IPROC+0) * INFLD) / NPROC
  IFROM (JFLD1:JFLD2) = IPROC
ENDDO

ILUN = 77_JPIM
INBARP = 0
INBARI = 0
CALL FAITOU (IREP, ILUN, .TRUE., TRIM (CDFILENAME), 'OLD', &
           & .TRUE., .TRUE., 2_JPIM, INBARP, INBARI, CLNOMC)


DO JFLD = 1, INFLD
BLOCK
  TYPE (ATLAS_METADATA) :: YLMETA
  REAL (KIND=JPRB), POINTER :: ZFLDL (:)
  CHARACTER (LEN=16)  :: CLNOMA
  INTEGER (KIND=JPIM) :: ISIZEG, ILNOMA

  CALL FANFAN (IREP, ILUN, CDPREF (JFLD), KNIVAU (JFLD), CDSUFF (JFLD), CLNOMA, ILNOMA)

! Global field; zero size if this proc does not read the field
  ISIZEG = 0
  IF (IFROM (JFLD) == MYPROC) ISIZEG = INT (YDGRID%SIZE (), JPIM)
  YLFLDG (JFLD) = ATLAS_FIELD (NAME=CLNOMA, KIND=JPRB, SHAPE=[ISIZEG])
  YLMETA = YLFLDG (JFLD)%METADATA ()
! Set owner
  CALL YLMETA%SET ("owner", IFROM (JFLD)-1)
  CALL YLMETA%FINAL ()
  CALL YLFLSG%ADD (YLFLDG (JFLD))

! Distributed field : created by space function
  YLFLDL (JFLD) = YDSTCO%CREATE_FIELD (NAME=CLNOMA, KIND=JPRB)
  CALL YLFLDL (JFLD)%DATA (ZFLDL)
  ZFLDL = 0._JPRB ! Not necessary

  CALL YDFLSL%ADD (YLFLDL (JFLD))
ENDBLOCK
ENDDO

DO JFLD = 1, INFLD
  IF (IFROM (JFLD) == MYPROC) THEN
  BLOCK
    REAL (KIND=JPRB), POINTER :: ZFLDG (:)
    CALL YLFLDG (JFLD)%DATA (ZFLDG)
    CALL FACILO (IREP, ILUN, CDPREF (JFLD), KNIVAU (JFLD), &
               & CDSUFF (JFLD), ZFLDG, .FALSE.)
    WRITE (*, '("GLOBAL",A16,I16,E12.4)') TRIM (CDPREF (JFLD))//TRIM (CDSUFF (JFLD)), SIZE (ZFLDG), SUM (ZFLDG) / SIZE (ZFLDG)
  ENDBLOCK
  ENDIF
ENDDO

CALL YDSTCO%SCATTER (YLFLSG, YDFLSL)

CALL FAIRME (IREP, ILUN, 'KEEP')

DO JFLD = 1, INFLD
  CALL YLFLDG (JFLD)%FINAL ()
  CALL YLFLDL (JFLD)%FINAL ()
ENDDO

CALL YLFLSG%FINAL ()

END SUBROUTINE

SUBROUTINE GFA (CDFILENAME, YDGRID)

CHARACTER (LEN=*), INTENT (IN) :: CDFILENAME
CLASS (ATLAS_STRUCTUREDGRID) :: YDGRID

CHARACTER (LEN=*), PARAMETER :: CLNOMC = 'c'
INTEGER (KIND=JPIM) :: ILUN, IREP, INBARP, INBARI, IRANGC
TYPE (FACADR), POINTER :: YLCADR

ILUN = 77_JPIM
INBARP = 0
INBARI = 0
CALL FAITOU (IREP, ILUN, .TRUE., TRIM (CDFILENAME), 'OLD', &
           & .TRUE., .TRUE., 2_JPIM, INBARP, INBARI, CLNOMC)

CALL FANUCA (CLNOMC, IRANGC, .FALSE.)
YLCADR => FA_COM_DEFAULT%CADRE (IRANGC)

IF (YLCADR%NTYPTR .LE. 0) THEN
BLOCK ! Regional model
  REAL (KIND=JPRB) :: DXINMETRES, DYINMETRES
  REAL (KIND=JPRB) :: LOVINDEGREES, LADINDEGREES, LATIN1INDEGREES, LATIN2INDEGREES
  INTEGER (KIND=JPIM) :: NUX, NUY

  DXINMETRES = YLCADR%SINLAT (7)
  DYINMETRES = YLCADR%SINLAT (8)
  NUX = INT (YLCADR%NLOPAR (4), JPIM)
  NUY = INT (YLCADR%NLOPAR (6), JPIM)

  LADINDEGREES    = YLCADR%SINLAT (4) * RAD2DEG
  LATIN1INDEGREES = YLCADR%SINLAT (4) * RAD2DEG
  LATIN2INDEGREES = YLCADR%SINLAT (4) * RAD2DEG
  LOVINDEGREES    = YLCADR%SINLAT (3) * RAD2DEG

WRITE (*, *) " NUX, NUY = ", NUX, NUY

  YDGRID = ATLAS_LAMBERTREGIONALGRID (YLCADR%NXLOPA, YLCADR%NLATIT, -NUX / 2 * DXINMETRES, -NUY / 2 * DYINMETRES, &
                                    & DXINMETRES, DYINMETRES, LOVINDEGREES, LADINDEGREES, LATIN1INDEGREES, LATIN2INDEGREES)

ENDBLOCK
ELSE 
BLOCK ! Global model
  INTEGER (KIND=JPIM), ALLOCATABLE :: NLOENG (:)
  REAL (KIND=JPRB) :: ZLONC, ZLATC

  ALLOCATE (NLOENG (YLCADR%NLATIT))

  IF (MODULO (YLCADR%NLATIT, 2) == 0) THEN
    NLOENG (1:YLCADR%NLATIT/2) = INT (YLCADR%NLOPAR (1:YLCADR%NLATIT/2), JPIM)
    NLOENG (YLCADR%NLATIT/2+1:YLCADR%NLATIT) = INT (NLOENG (YLCADR%NLATIT/2:1:-1), JPIM)
  ELSE
    CALL ABOR1 ('UNEXPECTED ODD NUMBER OF LATITUDES')
  ENDIF

  ZLATC = RAD2DEG * ASIN (YLCADR%SSLAPO)
  ZLONC = RAD2DEG * ATAN2 (YLCADR%SSLOPO, YLCADR%SCLOPO)

  YDGRID = ATLAS_REDUCEDGAUSSIANGRID (NLOENG, [ZLONC, ZLATC], YLCADR%SCODIL)

ENDBLOCK
ENDIF

CALL FAIRME (IREP, ILUN, 'KEEP')

END SUBROUTINE

END MODULE

