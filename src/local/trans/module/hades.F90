MODULE HADES


USE PARKIND1, ONLY : JPIM, JPRB, JPIB
USE YOMHOOK,  ONLY : LHOOK, DR_HOOK


IMPLICIT NONE

REAL (KIND=JPRB), PARAMETER :: RPI = 2.0_JPRB * ASIN (1.0_JPRB), &
                             & R2PI = 2._JPRB * RPI,             &
                             & RAD2DEG = 180._JPRB / RPI,        &
                             & DEG2RAD = RPI / 180._JPRB,        &
                             & RA = 6371229._JPRB

TYPE GRID_OPTIONS_t
  INTEGER (KIND=JPIM) :: NLOEN (30000) = 0
  INTEGER (KIND=JPIM) :: NDLON = 0, NDGLG = 0, NSMAX = 0
  LOGICAL :: LATLON = .FALSE., LSPLIT = .TRUE., LZONAL = .FALSE. 
  LOGICAL :: LROTATED = .FALSE. 
  LOGICAL :: LSTRETCH = .FALSE.
  REAL (KIND=JPRB) :: RSTRETCH = 1._JPRB
  REAL (KIND=JPRB) :: RLONCENT = 0._JPRB  ! Degrees
  REAL (KIND=JPRB) :: RLATCENT = 90._JPRB ! Degrees
  REAL (KIND=JPRB) :: RLONOFF = 0._JPRB  ! Degrees
  LOGICAL :: LSHIFTLON = .FALSE. ! If true, then shift longitudes so that the
                                 ! first longitude be not zero
  LOGICAL :: LGRIDONLY = .TRUE.
END TYPE GRID_OPTIONS_t

TYPE SHUFFLE_SEND_t
  INTEGER (KIND=JPIM) :: IPROC
  INTEGER (KIND=JPIM) :: ISIZE
  INTEGER (KIND=JPIM), ALLOCATABLE :: ILOCAL (:)   ! Local points to send
END TYPE SHUFFLE_SEND_t

TYPE SHUFFLE_RECV_t
! Here we describe how to use a message from a remote processor
  INTEGER (KIND=JPIM) :: IPROC, ISIZE
  INTEGER (KIND=JPIM), ALLOCATABLE :: ILOCAL (:)         ! Local indices
  INTEGER (KIND=JPIM), ALLOCATABLE :: IREMOTE_CNT (:)    ! Remote count for each local index
  INTEGER (KIND=JPIM), ALLOCATABLE :: IREMOTE_OFF (:)    ! Offset in remote buffer for each local index
END TYPE SHUFFLE_RECV_t

TYPE SHUFFLE_t
  INTEGER (KIND=JPIM), ALLOCATABLE :: ISORT (:), ILOCAL_CNT (:), ILOCAL_OFF (:)
  TYPE (SHUFFLE_SEND_t), ALLOCATABLE :: YL_SEND (:)
  TYPE (SHUFFLE_RECV_t), ALLOCATABLE :: YL_RECV (:)
END TYPE SHUFFLE_t

TYPE SHUFFLE4_RECV_t
  INTEGER (KIND=JPIM) :: IPROC, ICNT, IOFF
END TYPE SHUFFLE4_RECV_t

TYPE SHUFFLE4_SEND_t
  INTEGER (KIND=JPIM) :: IPROC, ICNT, IOFF
  INTEGER (KIND=JPIM), ALLOCATABLE :: ILOCAL (:)
END TYPE SHUFFLE4_SEND_t

TYPE SHUFFLE4_t
  INTEGER (KIND=JPIM) :: ISIZE
  INTEGER (KIND=JPIM), ALLOCATABLE :: ISORT (:)
  TYPE (SHUFFLE4_RECV_t), ALLOCATABLE :: YL_RECV (:)
  TYPE (SHUFFLE4_SEND_t), ALLOCATABLE :: YL_SEND (:)
END TYPE SHUFFLE4_t

TYPE WEIGHTS4_t
  REAL (KIND=JPRB), ALLOCATABLE :: ZVALUES (:)
END TYPE WEIGHTS4_t

TYPE HALO_RECV_t
  INTEGER (KIND=JPIM) :: IPROC = 0
  INTEGER (KIND=JPIM) :: IOFFSET = 0, ILENGTH = 0
END TYPE HALO_RECV_t
  
TYPE HALO_SEND_t
  INTEGER (KIND=JPIM) :: IPROC = 0
  INTEGER (KIND=JPIM), ALLOCATABLE :: IINDEX (:)
END TYPE HALO_SEND_t
  
TYPE HALO_t
  INTEGER (KIND=JPIM) :: ISIZE, IH_SIZE
  INTEGER (KIND=JPIM), ALLOCATABLE :: JNEIGHBOURS (:, :)
  INTEGER (KIND=JPIM), ALLOCATABLE :: JLON (:), JLAT (:)
  TYPE (HALO_SEND_t), ALLOCATABLE :: YL_SEND (:)
  TYPE (HALO_RECV_t), ALLOCATABLE :: YL_RECV (:)
END TYPE HALO_t

TYPE REGION_t
  INTEGER (KIND=JPIM) :: NLAN, NLAS
  INTEGER (KIND=JPIM), ALLOCATABLE :: NLOW (:), NLOE (:)
END TYPE REGION_t

INTEGER (KIND=JPIM), PARAMETER :: &
                     & JIDX__W = 1, JIDX__E = 2,  &
                     & JIDX_NW = 3, JIDX_NE = 4,  &
                     & JIDX_SW = 5, JIDX_SE = 6,  &
                     & JIDX_N_ = 7, JIDX_S_ = 8,  &
                     & JIDX___ = 9

TYPE NEIGHBOURS1_t
  INTEGER (KIND=JPIM) :: JLON (9) = [0, 0, 0, 0, 0, 0, 0, 0, 0]
  INTEGER (KIND=JPIM) :: JLAT (9) = [0, 0, 0, 0, 0, 0, 0, 0, 0]
END TYPE NEIGHBOURS1_t

TYPE GRID_t
  INTEGER (KIND=JPIM) :: NDGLG, NGPTOTG, NSMAX = 1, NSPEC2G = 0
  INTEGER (KIND=JPIM), ALLOCATABLE :: NLOEN (:)
  REAL (KIND=JPRB), ALLOCATABLE :: RMU (:)
  REAL (KIND=JPRB) :: RLONOFF = 0._JPRB ! Radians
  LOGICAL :: LROTATED = .FALSE. 
  LOGICAL :: LSTRETCH = .FALSE.
  REAL (KIND=JPRB) :: RSTRETCH = 1._JPRB
  REAL (KIND=JPRB) :: RLONCENT = 0._JPRB  ! Radians
  REAL (KIND=JPRB) :: RLATCENT = RPI      ! Radians
  REAL (KIND=JPRB) :: ZOMC2 = 0.0_JPRB
  REAL (KIND=JPRB) :: ZOPC2 = 2.0_JPRB
  REAL (KIND=JPRB) :: ZROTD (3, 3) = [[1._JPRB, 0._JPRB, 0._JPRB], &
                                    & [0._JPRB, 1._JPRB, 0._JPRB], &
                                    & [0._JPRB, 0._JPRB, 1._JPRB]]
  REAL (KIND=JPRB) :: ZROTI (3, 3) = [[1._JPRB, 0._JPRB, 0._JPRB], &
                                    & [0._JPRB, 1._JPRB, 0._JPRB], &
                                    & [0._JPRB, 0._JPRB, 1._JPRB]]
END TYPE GRID_t

TYPE DIST_t
  INTEGER (KIND=JPIM) :: NRESOL = 0
  INTEGER (KIND=JPIM) :: N_REGIONS_NS, N_REGIONS_EW, NPROC
  INTEGER (KIND=JPIM), ALLOCATABLE :: NFRSTLAT (:), NLSTLAT (:), NPTRFRSTLAT (:)
  INTEGER (KIND=JPIM), ALLOCATABLE :: NSTA (:,:), NONL (:,:)
  INTEGER(KIND=JPIM),  ALLOCATABLE :: NGPSET2PE (:,:) 
  INTEGER(KIND=JPIM),  ALLOCATABLE :: NGPPE2SET (:,:) 
  INTEGER(KIND=JPIM),  ALLOCATABLE :: N_REGIONS (:) 
  INTEGER(KIND=JPIM),  ALLOCATABLE :: NGPTOTL (:)
  INTEGER(KIND=JPIM),  ALLOCATABLE :: NSPEC2L (:)
  LOGICAL :: LEQ_REGIONS
END TYPE DIST_t

CONTAINS

FUNCTION ROTATE (PANGL, PAXIS)

REAL (KIND=JPRB) :: ROTATE (3, 3)

REAL (KIND=JPRB), INTENT (IN) :: PANGL
REAL (KIND=JPRB), INTENT (IN) :: PAXIS (3)

REAL (KIND=JPRB) :: ZVECT (3), ZAXIS (3), ZROTA (3), ZCOS, ZSIN, ZSCAL

INTEGER (KIND=JPIM) :: I


ZCOS = COS (PANGL)
ZSIN = SIN (PANGL)

ZAXIS = PAXIS / SQRT (SUM (PAXIS * PAXIS))

DO I = 1, 3

  ZVECT = 0._JPRB
  ZVECT (I) = 1._JPRB

  ZSCAL = SUM (ZVECT * ZAXIS)

! On retranche a ZVECT sa composante selon ZAXIS
  ZVECT = ZVECT - ZSCAL * ZAXIS

! Produit vectoriel : on fait tourner ZVECT
  ZROTA (1) = ZAXIS (2) * ZVECT (3) - ZAXIS (3) * ZVECT (2)
  ZROTA (2) = ZAXIS (3) * ZVECT (1) - ZAXIS (1) * ZVECT (3)
  ZROTA (3) = ZAXIS (1) * ZVECT (2) - ZAXIS (2) * ZVECT (1)
  
! On rajoute la composante selon ZAXIS a ce qui a tourne
  ZVECT = ZCOS * ZVECT + ZSIN * ZROTA + ZSCAL * ZAXIS

  ROTATE (:,I) = ZVECT

ENDDO


END FUNCTION

SUBROUTINE FIELDSTAT (YDDIST, YDGRID, PFLD, PMIN, PMAX, PAVG, PUNDEF, LDUNDEF)

USE MPL_MODULE,         ONLY : MPL_MYRANK, MPL_NUMPROC
USE MPL_ALLGATHERV_MOD, ONLY : MPL_ALLGATHERV

TYPE (DIST_t),    INTENT (IN)  :: YDDIST
TYPE (GRID_t),    INTENT (IN)  :: YDGRID
REAL (KIND=JPRB), INTENT (IN)  :: PFLD (:,:)
REAL (KIND=JPRB), INTENT (OUT), OPTIONAL :: PMIN (:), PMAX (:), PAVG (:)
REAL (KIND=JPRB), INTENT (IN),  OPTIONAL :: PUNDEF (:)
LOGICAL,          INTENT (IN),  OPTIONAL :: LDUNDEF (:)

INTEGER (KIND=JPIM) :: NPROC, MYPROC, IGPTOT, INFLD

INFLD = SIZE (PFLD, 2)
MYPROC = MPL_MYRANK ()
NPROC  = MPL_NUMPROC 
IGPTOT = YDDIST%NGPTOTL (MYPROC)

BLOCK
  LOGICAL :: LLUNDEF (INFLD)
  REAL (KIND=JPRB) :: ZMINMAXSUM (3 * INFLD * NPROC)
  REAL (KIND=JPRB) :: ZMMS (3 * INFLD)
  INTEGER (KIND=JPIM) :: ICNTSUM (INFLD * NPROC), JFLD, IOFF, ICNT, IPROC, ICS (INFLD)

  IF (PRESENT (LDUNDEF) .AND. PRESENT (PUNDEF)) THEN
    LLUNDEF = LDUNDEF
  ELSEIF (PRESENT (PUNDEF)) THEN
    LLUNDEF = .TRUE.
  ELSE
    LLUNDEF = .FALSE.
  ENDIF

!$OMP PARALLEL DO PRIVATE (JFLD)
  DO JFLD = 1, INFLD
    IF (LLUNDEF (JFLD)) THEN
      ICS (JFLD) = COUNT  (PFLD (:, JFLD)/=PUNDEF (JFLD))
      IF (ICNTSUM (IOFF+JFLD) > 0) THEN
        ZMMS (3*(JFLD-1)+1) = MINVAL (PFLD (1:IGPTOT, JFLD), MASK=PFLD (1:IGPTOT, JFLD)/=PUNDEF (JFLD))
        ZMMS (3*(JFLD-1)+2) = MAXVAL (PFLD (1:IGPTOT, JFLD), MASK=PFLD (1:IGPTOT, JFLD)/=PUNDEF (JFLD))
        ZMMS (3*(JFLD-1)+3) = SUM    (PFLD (1:IGPTOT, JFLD), MASK=PFLD (1:IGPTOT, JFLD)/=PUNDEF (JFLD))
      ELSE
        ZMMS (3*(JFLD-1)+1) = PUNDEF (JFLD)
        ZMMS (3*(JFLD-1)+2) = PUNDEF (JFLD)
        ZMMS (3*(JFLD-1)+3) = PUNDEF (JFLD)
      ENDIF
    ELSE
      ZMMS (3*(JFLD-1)+1) = MINVAL (PFLD (1:IGPTOT, JFLD))
      ZMMS (3*(JFLD-1)+2) = MAXVAL (PFLD (1:IGPTOT, JFLD))
      ZMMS (3*(JFLD-1)+3) = SUM    (PFLD (1:IGPTOT, JFLD))
      ICS (JFLD) = IGPTOT
    ENDIF
  ENDDO
!$OMP END PARALLEL DO



  CALL MPL_ALLGATHERV (ZMMS, ZMINMAXSUM, [(3*INFLD, IPROC=1, NPROC)], CDSTRING='FIELDSTAT:')
  CALL MPL_ALLGATHERV (ICS, ICNTSUM, [(INFLD, IPROC=1, NPROC)], CDSTRING='FIELDSTAT:')

!$OMP PARALLEL DO PRIVATE (JFLD, IOFF, ICNT)
  DO JFLD = 1, INFLD
    IOFF = 3*(JFLD-1)
    ICNT = 3*INFLD
    IF (LLUNDEF (JFLD)) THEN
      IF (PRESENT (PMIN)) &
      PMIN (JFLD) = MINVAL (ZMINMAXSUM (IOFF+1::ICNT), MASK=ZMINMAXSUM (IOFF+1::ICNT)/=PUNDEF (JFLD))
      IF (PRESENT (PMAX)) &
      PMAX (JFLD) = MAXVAL (ZMINMAXSUM (IOFF+2::ICNT), MASK=ZMINMAXSUM (IOFF+2::ICNT)/=PUNDEF (JFLD))
      IF (PRESENT (PAVG)) &
      PAVG (JFLD) = SUM    (ZMINMAXSUM (IOFF+3::ICNT), MASK=ZMINMAXSUM (IOFF+3::ICNT)/=PUNDEF (JFLD)) 
    ELSE
      IF (PRESENT (PMIN)) &
      PMIN (JFLD) = MINVAL (ZMINMAXSUM (IOFF+1::ICNT))
      IF (PRESENT (PMAX)) &
      PMAX (JFLD) = MAXVAL (ZMINMAXSUM (IOFF+2::ICNT))
      IF (PRESENT (PAVG)) &
      PAVG (JFLD) = SUM    (ZMINMAXSUM (IOFF+3::ICNT))
    ENDIF
    ICNT = SUM (ICNTSUM ((JFLD-1)+1::INFLD))
    IF (PRESENT (PAVG)) &
    PAVG (JFLD) = PAVG (JFLD) / REAL (ICNT, JPRB)
  ENDDO
!$OMP END PARALLEL DO


ENDBLOCK

END SUBROUTINE

SUBROUTINE DEMO_INTERPOLATION (YDDIST1,  YDGRID1,  YDDIST2,  YDGRID2, LDPRINT)

USE MPL_MODULE,        ONLY : MPL_MYRANK, MPL_NUMPROC

TYPE (DIST_t),                INTENT (IN)  :: YDDIST1, YDDIST2
TYPE (GRID_t),                INTENT (IN)  :: YDGRID1, YDGRID2
LOGICAL,                      INTENT (IN)  :: LDPRINT

INTEGER (KIND=JPIM) :: MYPROC, IGPTOT1, IGPTOT2
TYPE (SHUFFLE4_t) :: YLSHFL4
TYPE (WEIGHTS4_t) :: YLWGHT4

MYPROC = MPL_MYRANK ()

IGPTOT1  = YDDIST1%NGPTOTL (MYPROC)
IGPTOT2  = YDDIST2%NGPTOTL (MYPROC)

CALL CREATE_SHUFFLE4 (YDDIST1, YDGRID1, YDDIST2, YDGRID2, YLSHFL4)
CALL CREATE_WEIGHTS4 (YDDIST1, YDGRID1, YDDIST2, YDGRID2, YLSHFL4, YLWGHT4)

BLOCK
  REAL (KIND=JPRB) :: ZXYZ1 (IGPTOT1,3), ZXYZ2 (IGPTOT2,3), ZXYZ2I (IGPTOT2,3)
  CALL GET_MY_XYZ (YDGRID1, YDDIST1, ZXYZ1)
  CALL GET_MY_XYZ (YDGRID2, YDDIST2, ZXYZ2)

  CALL DO_INTERPOLATION4 (YDDIST1, YDGRID1, YDDIST2, YDGRID2, &
                        & ZXYZ1, ZXYZ2I, YLWGHT4, YDSHFL12=YLSHFL4)


  IF (LDPRINT) THEN
  CALL WFA (ZXYZ1, IGPTOT1, 3, "ZXYZ1.fa", ['SURF', 'SURF', 'SURF'], &
          & [0_JPIM, 0_JPIM, 0_JPIM], ['.X', '.Y', '.Z'], YDGRID1, YDDIST1)

  CALL WFA (ZXYZ2, IGPTOT2, 3, "ZXYZ2.fa", ['SURF', 'SURF', 'SURF'], &
          & [0_JPIM, 0_JPIM, 0_JPIM], ['.X', '.Y', '.Z'], YDGRID2, YDDIST2)

  CALL WFA (ZXYZ2I, IGPTOT2, 3, "ZXYZ2I.fa", ['SURF', 'SURF', 'SURF'], &
          & [0_JPIM, 0_JPIM, 0_JPIM], ['.X', '.Y', '.Z'], YDGRID2, YDDIST2)
  ENDIF


ENDBLOCK

END SUBROUTINE

SUBROUTINE DEMO_INTERPOLATIONA (YDDIST1,  YDGRID1,  YDDIST2,  YDGRID2,  &
                              & YDDIST1A, YDGRID1A, YDDIST2A, YDGRID2A, &
                              & LDPRINT)

USE ATLAS_MODULE
USE MPL_MODULE,        ONLY : MPL_MYRANK, MPL_NUMPROC

TYPE (DIST_t),                INTENT (IN)  :: YDDIST1, YDDIST2
TYPE (GRID_t),                INTENT (IN)  :: YDGRID1, YDGRID2
TYPE (ATLAS_GRIDDISTRIBUTION),INTENT (IN)  :: YDDIST1A, YDDIST2A
TYPE (ATLAS_STRUCTUREDGRID),  INTENT (IN)  :: YDGRID1A, YDGRID2A
LOGICAL,                      INTENT (IN)  :: LDPRINT

INTEGER (KIND=JPIM) :: MYPROC, IGPTOT1, IGPTOT2
TYPE (SHUFFLE4_t) :: YLSHFL4
TYPE (SHUFFLE4_t) :: YLSHFL4A
TYPE (WEIGHTS4_t) :: YLWGHT4

MYPROC = MPL_MYRANK ()

IGPTOT1  = YDDIST1%NGPTOTL (MYPROC)
IGPTOT2  = YDDIST2%NGPTOTL (MYPROC)

CALL CREATE_SHUFFLE4A (YDDIST1,  YDGRID1,  YDDIST2,  YDGRID2, &
                       YDDIST1A, YDGRID1A, YDDIST2A, YDGRID2A, &
                     & YLSHFL4, YLSHFL4A)
CALL CREATE_WEIGHTS4 (YDDIST1, YDGRID1, YDDIST2, YDGRID2, YLSHFL4, YLWGHT4)

BLOCK
  REAL (KIND=JPRB) :: ZXYZ1 (IGPTOT1,3), ZXYZ2 (IGPTOT2,3), ZXYZ2I (IGPTOT2,3)
  CALL GET_MY_XYZ (YDGRID1, YDDIST1, ZXYZ1)
  CALL GET_MY_XYZ (YDGRID2, YDDIST2, ZXYZ2)

  CALL DO_INTERPOLATION4 (YDDIST1, YDGRID1, YDDIST2, YDGRID2, &
                        & ZXYZ1, ZXYZ2I, YLWGHT4, YDSHFL12=YLSHFL4)


  IF (LDPRINT) THEN
  CALL WFA (ZXYZ1, IGPTOT1, 3, "ZXYZ1.fa", ['SURF', 'SURF', 'SURF'], &
          & [0_JPIM, 0_JPIM, 0_JPIM], ['.X', '.Y', '.Z'], YDGRID1, YDDIST1)

  CALL WFA (ZXYZ2, IGPTOT2, 3, "ZXYZ2.fa", ['SURF', 'SURF', 'SURF'], &
          & [0_JPIM, 0_JPIM, 0_JPIM], ['.X', '.Y', '.Z'], YDGRID2, YDDIST2)

  CALL WFA (ZXYZ2I, IGPTOT2, 3, "ZXYZ2I.fa", ['SURF', 'SURF', 'SURF'], &
          & [0_JPIM, 0_JPIM, 0_JPIM], ['.X', '.Y', '.Z'], YDGRID2, YDDIST2)
  ENDIF


ENDBLOCK

END SUBROUTINE

SUBROUTINE CREATE_SHUFFLE4 (YDDIST1, YDGRID1, YDDIST2, YDGRID2, YDSHFL4)

USE MPL_MPIF,          ONLY : MPI_REQUEST_NULL, MPI_UNDEFINED
USE MPL_DATA_MODULE,   ONLY : JP_NON_BLOCKING_STANDARD
USE MPL_MODULE,        ONLY : MPL_MYRANK, MPL_NUMPROC
USE MPL_ALLTOALLV_MOD, ONLY : MPL_ALLTOALLV
USE MPL_SEND_MOD,      ONLY : MPL_SEND
USE MPL_RECV_MOD,      ONLY : MPL_RECV
USE MPL_BARRIER_MOD,   ONLY : MPL_BARRIER
USE MPL_WAIT_MOD,      ONLY : MPL_WAIT
USE MPL_MODULE,        ONLY : MPL_COMM_OML

TYPE (DIST_t),     INTENT (IN)  :: YDDIST1, YDDIST2
TYPE (GRID_t),     INTENT (IN)  :: YDGRID1, YDGRID2
TYPE (SHUFFLE4_t), INTENT (OUT) :: YDSHFL4

INTEGER (KIND=JPIM) :: MYPROC, IGPTOT1, IGPTOT2, INPROC, INLAT1, INPT1

INTEGER (KIND=JPIM), POINTER :: IGLO1 (:), IPRC1 (:)
INTEGER (KIND=JPIM), ALLOCATABLE, TARGET :: IPRCGLO1 (:,:)

INTEGER (KIND=JPIM), ALLOCATABLE :: IGLOOFF1 (:)

INTEGER (KIND=JPIM), PARAMETER :: ISW = -3, ISE = -2, INW = -1, INE = -0
INTEGER (KIND=JPIM) :: ICOMM
INTEGER (KIND=JPIM) :: JNEXT, KLO, KLOEN
REAL(KIND=JPRB) :: ZHOOK_HANDLE, ZHOOK_HANDLE_1

JNEXT (KLO, KLOEN) = 1 + MODULO (KLO, KLOEN) ! Next longitude

IF (LHOOK) CALL DR_HOOK ('CREATE_SHUFFLE4',0,ZHOOK_HANDLE)

MYPROC = MPL_MYRANK ()
ICOMM  = MPL_COMM_OML (1)

IGPTOT1  = YDDIST1%NGPTOTL (MYPROC)
IGPTOT2  = YDDIST2%NGPTOTL (MYPROC)
INLAT1   = YDGRID1%NDGLG
INPROC   = YDDIST2%NPROC

ALLOCATE (YDSHFL4%ISORT (4*IGPTOT2))
ALLOCATE (IGLOOFF1 (INLAT1+1))


BLOCK
  REAL (KIND=JPRB) :: ZLATLON2 (IGPTOT2, 2), ZLAT1 (0:INLAT1+1), ZLAT2, ZLON2
  INTEGER (KIND=JPIM) :: II, JJ, JA1, JB1
  INTEGER (KIND=JPIM) :: INLON1, JLOC2, JLAT1A, JLAT1B, JLAT1M, JLON1A, JLON1B, JLAT1, JLON1
  INTEGER (KIND=JPIM) :: IGLO1ALL (4*IGPTOT2)
  INTEGER (KIND=JPIM) :: IORD_BY_GLO1 (4*IGPTOT2), IREV_BY_GLO1 (4*IGPTOT2), IRED_BY_GLO1 (4*IGPTOT2)
  INTEGER (KIND=JPIM), ALLOCATABLE :: IORD_BY_PRC1GLO1 (:), IREV_BY_PRC1GLO1 (:)
  REAL (KIND=JPRB) :: ZCOSLAT2, ZSINLAT2, ZCOSLON2, ZSINLON2, ZXYZ2 (3)



  IF (LHOOK) CALL DR_HOOK ('CREATE_SHUFFLE4:1',0,ZHOOK_HANDLE_1)

! Unrotated/unstretched latitude if YDGRID1 is rotated/stretched; regular
! latitude otherwise
  ZLAT1 = [+RPI/2, (ASIN (YDGRID1%RMU (JLAT1)), JLAT1 = 1, INLAT1), -RPI/2]

  IGLOOFF1 (1) = 0
  DO JLAT1 = 2, INLAT1+1
    IGLOOFF1 (JLAT1) = IGLOOFF1 (JLAT1-1) + YDGRID1%NLOEN (JLAT1-1)
  ENDDO
 
  CALL GET_MY_LATLON (YDGRID2, YDDIST2, ZLATLON2)

!$OMP PARALLEL DO PRIVATE (JLOC2, ZLAT2, ZLON2, JLAT1A, JLAT1B, JLAT1M, INLON1, JLON1A, JLON1B, &
!$OMP                    & ZCOSLAT2, ZSINLAT2, ZCOSLON2, ZSINLON2, ZXYZ2) 
  DO JLOC2 = 1, IGPTOT2

    ZLAT2 = ZLATLON2 (JLOC2, 1)
    ZLON2 = ZLATLON2 (JLOC2, 2)

! Go back to unrotated lat/lon
    IF (YDGRID1%LROTATED .OR. YDGRID1%LSTRETCH) THEN
      ZCOSLAT2 = COS (ZLAT2); ZSINLAT2 = SIN (ZLAT2)
      ZCOSLON2 = COS (ZLON2); ZSINLON2 = SIN (ZLON2)
! Compute XYZ in unrotated frame
      ZXYZ2 (1) = ZCOSLON2 * ZCOSLAT2
      ZXYZ2 (2) = ZSINLON2 * ZCOSLAT2
      ZXYZ2 (3) =            ZSINLAT2
! Rotate back
      ZXYZ2 = MATMUL (YDGRID1%ZROTI, ZXYZ2)
      ZLAT2 = ASIN (ZXYZ2 (3))
      ZLON2 = MODULO (ATAN2 (ZXYZ2 (2), ZXYZ2 (1)), R2PI)
! Unstretch
      ZSINLAT2 = SIN (ZLAT2)
      ZLAT2 = ASIN ((-YDGRID1%ZOMC2 + ZSINLAT2 * YDGRID1%ZOPC2) &
            &     / (+YDGRID1%ZOPC2 - ZSINLAT2 * YDGRID1%ZOMC2))
    ENDIF

! Find nearest latitude just below

    JLAT1A = 0; JLAT1B = INLAT1+1
   
    DO 
      JLAT1M = (JLAT1A + JLAT1B) / 2
      IF (ZLAT1 (JLAT1A) >= ZLAT2 .AND. ZLAT2 >= ZLAT1 (JLAT1M)) THEN
        JLAT1B = JLAT1M
      ELSE
        JLAT1A = JLAT1M
      ENDIF
      IF (ABS (JLAT1B - JLAT1A) <= 1) EXIT
    ENDDO
   
! Point above

    JLAT1B = JLAT1A + 1

    IF (JLAT1B > INLAT1+1) STOP
   
! Find nearest longitude just below

    IF (JLAT1A > 0) THEN
      INLON1 = YDGRID1%NLOEN (JLAT1A)
      JLON1A = 1 + MODULO (INT ((REAL (INLON1, JPRB) &
           & * (ZLON2 - YDGRID1%RLONOFF)) / (R2PI)), INLON1)
      IGLO1ALL (4*JLOC2+ISW) = IGLOOFF1 (JLAT1A) + JLON1A
      IGLO1ALL (4*JLOC2+ISE) = IGLOOFF1 (JLAT1A) + JNEXT (JLON1A, INLON1)
    ELSE
      JLON1A = 0
      IGLO1ALL (4*JLOC2+ISW) = 0
      IGLO1ALL (4*JLOC2+ISE) = 0
    ENDIF

    IF (JLAT1B < INLAT1+1) THEN
      INLON1 = YDGRID1%NLOEN (JLAT1B)
      JLON1B = 1 + MODULO (INT ((REAL (INLON1, JPRB) &
           & * (ZLON2 - YDGRID1%RLONOFF)) / (R2PI)), INLON1)
      IGLO1ALL (4*JLOC2+INW) = IGLOOFF1 (JLAT1B) + JLON1B
      IGLO1ALL (4*JLOC2+INE) = IGLOOFF1 (JLAT1B) + JNEXT (JLON1B, INLON1)
    ELSE
      JLON1B = 0
      IGLO1ALL (4*JLOC2+INW) = 0
      IGLO1ALL (4*JLOC2+INE) = 0
    ENDIF

  ENDDO
!$OMP END PARALLEL DO
  IF (LHOOK) CALL DR_HOOK ('CREATE_SHUFFLE4:1',1,ZHOOK_HANDLE_1)

  IF (LHOOK) CALL DR_HOOK ('CREATE_SHUFFLE4:2',0,ZHOOK_HANDLE_1)
  CALL SORTI4X1 (4*IGPTOT2, IORD_BY_GLO1, IGLO1ALL)
  IF (LHOOK) CALL DR_HOOK ('CREATE_SHUFFLE4:2',1,ZHOOK_HANDLE_1)

  IF (LHOOK) CALL DR_HOOK ('CREATE_SHUFFLE4:3',0,ZHOOK_HANDLE_1)
  CALL REVERSE (IORD_BY_GLO1, IREV_BY_GLO1)

! Reorder indices of grid #1

  IGLO1ALL = IGLO1ALL (IORD_BY_GLO1)

! Reduce the list of indices on grid #1

  IRED_BY_GLO1 (1) = 1
  JJ = 1
  DO II = 2, 4*IGPTOT2
    IF (IGLO1ALL (II-1) == IGLO1ALL (II)) THEN
      IRED_BY_GLO1 (II) = IRED_BY_GLO1 (II-1)
    ELSE
      JJ = JJ + 1
      IRED_BY_GLO1 (II) = JJ
    ENDIF
  ENDDO

  INPT1 = JJ

! Build the list of indices of grid #1 (unique indices)

  ALLOCATE (IPRCGLO1 (2, INPT1))
  IPRC1 => IPRCGLO1 (1, :)
  IGLO1 => IPRCGLO1 (2, :)
  DO II = 1, 4*IGPTOT2
    IGLO1 (IRED_BY_GLO1 (II)) = IGLO1ALL (II)
  ENDDO
  IF (LHOOK) CALL DR_HOOK ('CREATE_SHUFFLE4:3',1,ZHOOK_HANDLE_1)

! Find processors of elements of grid #1
  IF (LHOOK) CALL DR_HOOK ('CREATE_SHUFFLE4:4',0,ZHOOK_HANDLE_1)

!$OMP PARALLEL DO PRIVATE (II, JLAT1A, JLAT1B, JLAT1M, JLAT1, JLON1, JA1, JB1)
  DO II = 1, INPT1
    IF (IGLO1 (II) /= 0) THEN
      JLAT1A = 1; JLAT1B = INLAT1+1
      DO
        JLAT1M = (JLAT1A + JLAT1B) / 2
        IF (IGLOOFF1 (JLAT1A)+1 <= IGLO1 (II) .AND. IGLO1 (II) <= IGLOOFF1 (JLAT1M)) THEN
          JLAT1B = JLAT1M
        ELSE
          JLAT1A = JLAT1M
        ENDIF
        IF (JLAT1B - JLAT1A <= 1) EXIT
      ENDDO
      JLAT1 = JLAT1A; JLON1 = IGLO1 (II) - IGLOOFF1 (JLAT1)
      CALL JLONJLAT_TO_JAJB (JLON1, JLAT1, YDDIST1, JA1, JB1)
      IPRC1 (II) = YDDIST1%NGPSET2PE (JA1, JB1)
    ELSE
      IPRC1 (II) = 0
    ENDIF
  ENDDO
!$OMP END PARALLEL DO

  IF (LHOOK) CALL DR_HOOK ('CREATE_SHUFFLE4:4',1,ZHOOK_HANDLE_1)

! Sort by processor, global index

  IF (LHOOK) CALL DR_HOOK ('CREATE_SHUFFLE4:5',0,ZHOOK_HANDLE_1)

  ALLOCATE (IORD_BY_PRC1GLO1 (INPT1), IREV_BY_PRC1GLO1 (INPT1))
  CALL SORTI4X2 (INPT1, IORD_BY_PRC1GLO1, IPRCGLO1)

  CALL REVERSE (IORD_BY_PRC1GLO1, IREV_BY_PRC1GLO1)

! Reorder

  IGLO1 = IGLO1 (IORD_BY_PRC1GLO1)
  IPRC1 = IPRC1 (IORD_BY_PRC1GLO1)

! Final sort array
  YDSHFL4%ISORT = IREV_BY_PRC1GLO1 (IRED_BY_GLO1 (IREV_BY_GLO1))

  IF (LHOOK) CALL DR_HOOK ('CREATE_SHUFFLE4:5',1,ZHOOK_HANDLE_1)
ENDBLOCK

BLOCK
  INTEGER (KIND=JPIM), ALLOCATABLE :: IREQRECV (:), IREQSEND (:)
  INTEGER (KIND=JPIM) :: ISENDCNT (INPROC), IRECVCNT (INPROC)
  INTEGER (KIND=JPIM) :: IPROC, ISKIP, ICNT, IOFF, II
  INTEGER (KIND=JPIM) :: INSEND, INRECV
  INTEGER (KIND=JPIM), ALLOCATABLE :: IGLOBAL1 (:)

  IF (LHOOK) CALL DR_HOOK ('CREATE_SHUFFLE4:6',0,ZHOOK_HANDLE_1)

  ISKIP = 0 ! Number of points not found; they are supposed to be at the begining of the list
  IRECVCNT = 0
  DO II = 1, SIZE (IPRC1)
    IPROC = IPRC1 (II)
    IF (IPROC > 0) THEN
      IRECVCNT (IPROC) = IRECVCNT (IPROC) + 1
    ELSE
      ISKIP = ISKIP + 1
    ENDIF
  ENDDO

! Copy indices to contiguous array for sending

  ALLOCATE (IGLOBAL1 (SIZE (IGLO1)))
  IGLOBAL1 = IGLO1
  DEALLOCATE (IPRCGLO1); NULLIFY (IGLO1); NULLIFY (IPRC1)


! Exchange send/recv counts

  CALL MPL_ALLTOALLV (KSENDBUF=IRECVCNT, KRECVBUF=ISENDCNT, &
                    & KSENDCOUNTS=[(1,IPROC=1,INPROC)],   &
                    & KRECVCOUNTS=[(1,IPROC=1,INPROC)],   &
                    & CDSTRING='CREATE_SHUFFLE4', KCOMM=ICOMM)

  INSEND = COUNT (ISENDCNT /= 0)
  INRECV = COUNT (IRECVCNT /= 0)

! Create send/recv descriptors

  ALLOCATE (YDSHFL4%YL_SEND (INSEND), YDSHFL4%YL_RECV (INRECV))

  INSEND = 0
  DO IPROC = 1, INPROC
    IF (ISENDCNT (IPROC) > 0) THEN
      INSEND = INSEND + 1
      YDSHFL4%YL_SEND (INSEND)%IPROC = IPROC
      YDSHFL4%YL_SEND (INSEND)%ICNT = ISENDCNT (IPROC)
      ALLOCATE (YDSHFL4%YL_SEND (INSEND)%ILOCAL  (ISENDCNT (IPROC)))
    ENDIF
  ENDDO
  YDSHFL4%YL_SEND (1)%IOFF = 0
  DO II = 2, INSEND
    YDSHFL4%YL_SEND (II)%IOFF = YDSHFL4%YL_SEND (II-1)%IOFF + YDSHFL4%YL_SEND (II-1)%ICNT
  ENDDO

  INRECV = 0
  DO IPROC = 1, INPROC
    IF (IRECVCNT (IPROC) > 0) THEN
      INRECV = INRECV + 1
      YDSHFL4%YL_RECV (INRECV)%IPROC = IPROC
      YDSHFL4%YL_RECV (INRECV)%ICNT  = IRECVCNT (IPROC)
    ENDIF
  ENDDO
  YDSHFL4%YL_RECV (1)%IOFF = ISKIP
  DO II = 2, INRECV
    YDSHFL4%YL_RECV (II)%IOFF = YDSHFL4%YL_RECV (II-1)%IOFF + YDSHFL4%YL_RECV (II-1)%ICNT
  ENDDO

  IF (LHOOK) CALL DR_HOOK ('CREATE_SHUFFLE4:6',1,ZHOOK_HANDLE_1)

! Exchange global indices of grid #1

  IF (LHOOK) CALL DR_HOOK ('CREATE_SHUFFLE4:7',0,ZHOOK_HANDLE_1)

  ALLOCATE (IREQSEND (INSEND), IREQRECV (INRECV))
  IREQSEND = MPI_REQUEST_NULL
  IREQRECV = MPI_REQUEST_NULL

! Send indices we need to send values for

  DO II = 1, INSEND
! Receive global indices in ILOCAL; they will be translated to local indices later
    IPROC = YDSHFL4%YL_SEND (II)%IPROC
    CALL MPL_RECV (KBUF=YDSHFL4%YL_SEND (II)%ILOCAL, KSOURCE=IPROC, KTAG=101, CDSTRING='CREATE_SHUFFLE4', &
                 & KMP_TYPE=JP_NON_BLOCKING_STANDARD, KREQUEST=IREQSEND (II), KCOMM=ICOMM)
  ENDDO

  CALL MPL_BARRIER (CDSTRING='CREATE_SHUFFLE4', KCOMM=ICOMM)

! Receive indices we shall send values for

  DO II = 1, INRECV
    IOFF = YDSHFL4%YL_RECV (II)%IOFF
    ICNT = YDSHFL4%YL_RECV (II)%ICNT
    IPROC = YDSHFL4%YL_RECV (II)%IPROC
    CALL MPL_SEND (KBUF=IGLOBAL1 (IOFF+1:IOFF+ICNT), KDEST=IPROC, KTAG=101, CDSTRING='CREATE_SHUFFLE4', &
                 & KMP_TYPE=JP_NON_BLOCKING_STANDARD, KREQUEST=IREQRECV (II), KCOMM=ICOMM)
  ENDDO

  CALL MPL_WAIT (KREQUEST=IREQSEND, CDSTRING='CREATE_SHUFFLE4')

  IF (LHOOK) CALL DR_HOOK ('CREATE_SHUFFLE4:7',1,ZHOOK_HANDLE_1)

! We have received the global indices we should transmit; decode them into
! lat/lon indices, then into local indices

  BLOCK
    INTEGER (KIND=JPIM) :: II, JJ, JGLO1, JLAT1A, JLAT1B, JLAT1M, JLAT1, JLON1, JLOC1
    INTEGER (KIND=JPIM), ALLOCATABLE :: ILOCOFF1 (:)
    TYPE (REGION_t) :: YLMYREG1

    IF (LHOOK) CALL DR_HOOK ('CREATE_SHUFFLE4:8',0,ZHOOK_HANDLE_1)

    CALL GET_MYREGION (YLMYREG1, YDDIST1, YDGRID1)

    ALLOCATE (ILOCOFF1 (YLMYREG1%NLAN:YLMYREG1%NLAS))
   
! First compute an ancillary array to go from lat/lon indices to local indices

    ILOCOFF1 (YLMYREG1%NLAN) = 0
    DO JLAT1 = YLMYREG1%NLAN+1, YLMYREG1%NLAS
      ILOCOFF1 (JLAT1) = ILOCOFF1 (JLAT1-1) + 1 + &
         & MODULO (YLMYREG1%NLOE (JLAT1-1) - YLMYREG1%NLOW (JLAT1-1), YDGRID1%NLOEN (JLAT1-1))
    ENDDO

!$OMP PARALLEL DO PRIVATE (II, JJ, JGLO1, JLAT1A, JLAT1B, JLAT1M, JLAT1, JLON1, JLOC1) 
    DO II = 1, INSEND
      DO JJ = 1, SIZE (YDSHFL4%YL_SEND (II)%ILOCAL)
        JGLO1 = YDSHFL4%YL_SEND (II)%ILOCAL (JJ)
        JLAT1A = 1; JLAT1B = INLAT1+1
        DO
          JLAT1M = (JLAT1A + JLAT1B) / 2
          IF (IGLOOFF1 (JLAT1A)+1 <= JGLO1 .AND. JGLO1 <= IGLOOFF1 (JLAT1M)) THEN
            JLAT1B = JLAT1M
          ELSE
            JLAT1A = JLAT1M
          ENDIF
          IF (JLAT1B - JLAT1A <= 1) EXIT
        ENDDO
        JLAT1 = JLAT1A; JLON1 = JGLO1 - IGLOOFF1 (JLAT1)
        JLOC1 = ILOCOFF1 (JLAT1) + 1 + MODULO (JLON1-YLMYREG1%NLOW (JLAT1), YDGRID1%NLOEN (JLAT1))
        YDSHFL4%YL_SEND (II)%ILOCAL (JJ) = JLOC1
      ENDDO
    ENDDO
!$OMP END PARALLEL DO
  ENDBLOCK

  IF (LHOOK) CALL DR_HOOK ('CREATE_SHUFFLE4:8',1,ZHOOK_HANDLE_1)
  IF (LHOOK) CALL DR_HOOK ('CREATE_SHUFFLE4:9',0,ZHOOK_HANDLE_1)

  CALL MPL_WAIT (KREQUEST=IREQRECV, CDSTRING='CREATE_SHUFFLE4')

  YDSHFL4%ISIZE = YDSHFL4%YL_RECV (1)%IOFF+SUM (YDSHFL4%YL_RECV%ICNT)

  IF (LHOOK) CALL DR_HOOK ('CREATE_SHUFFLE4:9',1,ZHOOK_HANDLE_1)
ENDBLOCK

IF (LHOOK) CALL DR_HOOK ('CREATE_SHUFFLE4',1,ZHOOK_HANDLE)

CONTAINS

SUBROUTINE REVERSE (KORD, KREV)

INTEGER (KIND=JPIM) :: KORD (:), KREV (:)
INTEGER (KIND=JPIM) :: II

KREV = [(II, II = 1, SIZE (KREV))]
KREV (KORD) = KREV

END SUBROUTINE

END SUBROUTINE

SUBROUTINE CREATE_SHUFFLE4A (YDDIST1,   YDGRID1,   YDDIST2,   YDGRID2,  &
                             YDDIST1_A, YDGRID1_A, YDDIST2_A, YDGRID2_A, &
                           & YDSHFL4, YDSHFL4A)

USE MPL_MPIF,          ONLY : MPI_REQUEST_NULL, MPI_UNDEFINED
USE MPL_DATA_MODULE,   ONLY : JP_NON_BLOCKING_STANDARD
USE MPL_MODULE,        ONLY : MPL_MYRANK, MPL_NUMPROC
USE MPL_ALLTOALLV_MOD, ONLY : MPL_ALLTOALLV
USE MPL_SEND_MOD,      ONLY : MPL_SEND
USE MPL_RECV_MOD,      ONLY : MPL_RECV
USE MPL_BARRIER_MOD,   ONLY : MPL_BARRIER
USE MPL_WAIT_MOD,      ONLY : MPL_WAIT
USE MPL_MODULE,        ONLY : MPL_COMM_OML

USE ATLAS_MODULE

TYPE (DIST_t),     INTENT (IN)  :: YDDIST1, YDDIST2
TYPE (GRID_t),     INTENT (IN)  :: YDGRID1, YDGRID2
TYPE (ATLAS_GRIDDISTRIBUTION),INTENT (IN)  :: YDDIST1_A, YDDIST2_A
TYPE (ATLAS_STRUCTUREDGRID),  INTENT (IN)  :: YDGRID1_A, YDGRID2_A
TYPE (SHUFFLE4_t), INTENT (OUT) :: YDSHFL4
TYPE (SHUFFLE4_t), INTENT (OUT) :: YDSHFL4A

INTEGER (KIND=JPIM) :: MYPROC, IGPTOT1, IGPTOT2, INPROC, INLAT1, INPT1

INTEGER (KIND=JPIM), POINTER :: IGLO1 (:), IPRC1 (:)
INTEGER (KIND=JPIM), ALLOCATABLE, TARGET :: IPRCGLO1 (:,:)

INTEGER (KIND=JPIM), ALLOCATABLE :: IGLOOFF1 (:)

INTEGER (KIND=JPIM), PARAMETER :: ISW = -3, ISE = -2, INW = -1, INE = -0
INTEGER (KIND=JPIM) :: ICOMM
INTEGER (KIND=JPIM) :: JNEXT, KLO, KLOEN

TYPE (ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS) :: YLFS1_A
TYPE (ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS) :: YLFS2_A

TYPE (ATLAS_FIELD) :: YLGLIDX2_A, YLI2_A, YLJ2_A

INTEGER (KIND=JPIB), POINTER :: IGLOBAL_RANK (:)
INTEGER (KIND=JPIM) :: JJ

REAL(KIND=JPRB) :: ZHOOK_HANDLE, ZHOOK_HANDLE_1

JNEXT (KLO, KLOEN) = 1 + MODULO (KLO, KLOEN) ! Next longitude

IF (LHOOK) CALL DR_HOOK ('CREATE_SHUFFLE4',0,ZHOOK_HANDLE)


YLFS1_A = ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS (YDGRID1_A, YDDIST1_A)
YLFS2_A = ATLAS_FUNCTIONSPACE_STRUCTUREDCOLUMNS (YDGRID2_A, YDDIST2_A)


MYPROC = MPL_MYRANK ()
ICOMM  = MPL_COMM_OML (1)

IGPTOT1  = YDDIST1%NGPTOTL (MYPROC)
IGPTOT2  = YDDIST2%NGPTOTL (MYPROC)
INLAT1   = YDGRID1%NDGLG
INPROC   = YDDIST2%NPROC

ALLOCATE (YDSHFL4%ISORT (4*IGPTOT2))
ALLOCATE (IGLOOFF1 (INLAT1+1))


BLOCK
  REAL (KIND=JPRB) :: ZLATLON2 (IGPTOT2, 2), ZLAT1 (0:INLAT1+1), ZLAT2, ZLON2
  INTEGER (KIND=JPIM) :: II, JJ, JA1, JB1
  INTEGER (KIND=JPIM) :: INLON1, JLOC2, JLAT1A, JLAT1B, JLAT1M, JLON1A, JLON1B, JLAT1, JLON1
  INTEGER (KIND=JPIM) :: IGLO1ALL  (4*IGPTOT2)
  INTEGER (KIND=JPIM) :: IORD_BY_GLO1 (4*IGPTOT2), IREV_BY_GLO1 (4*IGPTOT2), IRED_BY_GLO1 (4*IGPTOT2)
  INTEGER (KIND=JPIM), ALLOCATABLE :: IORD_BY_PRC1GLO1 (:), IREV_BY_PRC1GLO1 (:)
  REAL (KIND=JPRB) :: ZCOSLAT2, ZSINLAT2, ZCOSLON2, ZSINLON2, ZXYZ2 (3)
  LOGICAL :: LLDBG


  IF (LHOOK) CALL DR_HOOK ('CREATE_SHUFFLE4:1',0,ZHOOK_HANDLE_1)

! Unrotated/unstretched latitude if YDGRID1 is rotated/stretched; regular
! latitude otherwise
  ZLAT1 = [+RPI/2, (ASIN (YDGRID1%RMU (JLAT1)), JLAT1 = 1, INLAT1), -RPI/2]

  PRINT *, "ZLAT1"
  DO JLAT1 = 1, INLAT1
    WRITE (*, '(F30.20)') ZLAT1 (JLAT1) * RAD2DEG
  ENDDO


  IGLOOFF1 (1) = 0
  DO JLAT1 = 2, INLAT1+1
    IGLOOFF1 (JLAT1) = IGLOOFF1 (JLAT1-1) + YDGRID1%NLOEN (JLAT1-1)
  ENDDO
 
  CALL GET_MY_LATLON (YDGRID2, YDDIST2, ZLATLON2)

!#OMP PARALLEL DO PRIVATE (JLOC2, ZLAT2, ZLON2, JLAT1A, JLAT1B, JLAT1M, INLON1, JLON1A, JLON1B, &
!#OMP                    & ZCOSLAT2, ZSINLAT2, ZCOSLON2, ZSINLON2, ZXYZ2) 
  DO JLOC2 = 1, IGPTOT2
  LLDBG = (MYPROC == 1) .AND. (JLOC2 == 12)

    ZLAT2 = ZLATLON2 (JLOC2, 1)
    ZLON2 = ZLATLON2 (JLOC2, 2)

! Go back to unrotated lat/lon
    IF (YDGRID1%LROTATED .OR. YDGRID1%LSTRETCH) THEN
      ZCOSLAT2 = COS (ZLAT2); ZSINLAT2 = SIN (ZLAT2)
      ZCOSLON2 = COS (ZLON2); ZSINLON2 = SIN (ZLON2)
! Compute XYZ in unrotated frame
      ZXYZ2 (1) = ZCOSLON2 * ZCOSLAT2
      ZXYZ2 (2) = ZSINLON2 * ZCOSLAT2
      ZXYZ2 (3) =            ZSINLAT2
! Rotate back
      ZXYZ2 = MATMUL (YDGRID1%ZROTI, ZXYZ2)
      ZLAT2 = ASIN (ZXYZ2 (3))
      ZLON2 = MODULO (ATAN2 (ZXYZ2 (2), ZXYZ2 (1)), R2PI)
! Unstretch
      ZSINLAT2 = SIN (ZLAT2)
      ZLAT2 = ASIN ((-YDGRID1%ZOMC2 + ZSINLAT2 * YDGRID1%ZOPC2) &
            &     / (+YDGRID1%ZOPC2 - ZSINLAT2 * YDGRID1%ZOMC2))
    ENDIF

! Find nearest latitude just below

    JLAT1A = 0; JLAT1B = INLAT1+1
   
    DO 
      JLAT1M = (JLAT1A + JLAT1B) / 2
      IF (ZLAT1 (JLAT1A) >= ZLAT2 .AND. ZLAT2 >= ZLAT1 (JLAT1M)) THEN
        JLAT1B = JLAT1M
      ELSE
        JLAT1A = JLAT1M
      ENDIF
      IF (ABS (JLAT1B - JLAT1A) <= 1) EXIT
    ENDDO
   
    IF (LLDBG) THEN
      WRITE (0, *) __FILE__, ':', __LINE__, " JLAT1A, JLAT1B = ", JLAT1A, JLAT1B
      WRITE (0, *) " ZLAT2 = ", ZLAT2 * RAD2DEG
      WRITE (0, *) " ZLON2 = ", ZLON2 * RAD2DEG
    ENDIF

! Point above

    JLAT1B = JLAT1A + 1

    IF (JLAT1B > INLAT1+1) STOP
   
! Find nearest longitude just below

    IF (JLAT1A > 0) THEN
      INLON1 = YDGRID1%NLOEN (JLAT1A)
      JLON1A = 1 + MODULO (INT ((REAL (INLON1, JPRB) &
           & * (ZLON2 - YDGRID1%RLONOFF)) / (R2PI)), INLON1)
IF (LLDBG) THEN
  WRITE (0, *) __FILE__, ':', __LINE__, " JLON1A = ", JLON1A
  PRINT *, " INLON1 = ", INLON1
  WRITE (*, '(E30.20)') (ZLON2 - YDGRID1%RLONOFF) / (R2PI)
  WRITE (*, '(E30.20)') REAL (INLON1, JPRB) * (ZLON2 - YDGRID1%RLONOFF) / (R2PI)
ENDIF
      IGLO1ALL (4*JLOC2+ISW) = IGLOOFF1 (JLAT1A) + JLON1A
      IGLO1ALL (4*JLOC2+ISE) = IGLOOFF1 (JLAT1A) + JNEXT (JLON1A, INLON1)
    ELSE
      JLON1A = 0
      IGLO1ALL (4*JLOC2+ISW) = 0
      IGLO1ALL (4*JLOC2+ISE) = 0
    ENDIF

    IF (JLAT1B < INLAT1+1) THEN
      INLON1 = YDGRID1%NLOEN (JLAT1B)
      JLON1B = 1 + MODULO (INT ((REAL (INLON1, JPRB) &
           & * (ZLON2 - YDGRID1%RLONOFF)) / (R2PI)), INLON1)
      IGLO1ALL (4*JLOC2+INW) = IGLOOFF1 (JLAT1B) + JLON1B
      IGLO1ALL (4*JLOC2+INE) = IGLOOFF1 (JLAT1B) + JNEXT (JLON1B, INLON1)
    ELSE
      JLON1B = 0
      IGLO1ALL (4*JLOC2+INW) = 0
      IGLO1ALL (4*JLOC2+INE) = 0
    ENDIF

   IF (LLDBG) WRITE (0, *) __FILE__, ':', __LINE__, " IGLO1ALL_A = ", IGLO1ALL (4*(JLOC2-1)+1:4*(JLOC2-1)+4)

  ENDDO
!#OMP END PARALLEL DO

CALL PRIGLO (IGLO1ALL, "IGLO1ALL")

BLOCK
  INTEGER (KIND=JPIM), ALLOCATABLE :: IGLO1ALL_A (:)
  REAL (KIND=JPRB), ALLOCATABLE :: ZLAT1 (:)
  REAL (KIND=JPRB) :: ZLONLAT1 (2)
  REAL (KIND=JPRB), ALLOCATABLE :: ZLONLAT2_A (:,:), ZXY2_A (:,:)
  INTEGER (KIND=JPIM), POINTER :: I2_A (:), J2_A (:)
  INTEGER (KIND=JPIM) :: JLOC2, JLAT1, JLON1

  ALLOCATE (IGLO1ALL_A (4*YLFS2_A%SIZE_OWNED ()))
  ALLOCATE (ZLONLAT2_A (2, YLFS2_A%SIZE_OWNED ()))
  ALLOCATE (ZXY2_A (2, YLFS2_A%SIZE_OWNED ()))

  YLGLIDX2_A = YLFS2_A%GLOBAL_INDEX ()
  CALL YLGLIDX2_A%DATA (IGLOBAL_RANK)

  YLI2_A = YLFS2_A%INDEX_I ()
  CALL YLI2_A%DATA (I2_A)
  YLJ2_A = YLFS2_A%INDEX_J ()
  CALL YLJ2_A%DATA (J2_A)

  ! TODO : 
  ! - map grid #2 lonlat to grid #1 xy (cannot do that in Fortran) using proj #1
  !   for a batch of points
  ! - specify periodic_points = true in fs creation if needed

  PRINT *, " YLFS2_A%SIZE_OWNED () = ", YLFS2_A%SIZE_OWNED ()
  PRINT *, " YDGRID2_A%SIZE ()   = ", YDGRID2_A%SIZE ()
  PRINT *, " YLGLIDX2_A%SIZE () = ", YLGLIDX2_A%SIZE ()
  PRINT *, " SIZE (IGLOBAL_RANK) = ", SIZE (IGLOBAL_RANK)

  DO JLOC2 = 1, YLFS2_A%SIZE_OWNED ()
    ZLONLAT2_A (1:2, JLOC2) = YDGRID2_A%LONLAT (I2_A (JLOC2), J2_A (JLOC2))
    ZXY2_A     (1:2, JLOC2) = YDGRID2_A%XY     (I2_A (JLOC2), J2_A (JLOC2))
  ENDDO

  DO JLOC2 = 1, YLFS2_A%SIZE_OWNED ()
    WRITE (*, '(I8," > ",I8," | ",F12.4,F12.4)') & 
         & JLOC2, IGLOBAL_RANK (JLOC2), &
         & ZXY2_A (1, JLOC2), ZXY2_A (2, JLOC2)
  ENDDO

  ALLOCATE (ZLAT1 (0:YDGRID1_A%NY ()+1))
  JLAT1 = 0
  ZLAT1 (JLAT1) = +180.0_JPRB
  DO JLAT1 = 1, YDGRID1_A%NY ()
    ZLONLAT1 = YDGRID1_A%LONLAT (1, JLAT1)
    ZLAT1 (JLAT1) = ZLONLAT1 (2)
  ENDDO
  ZLAT1 (JLAT1) = -180.0_JPRB

  PRINT *, "ZLAT1"
  DO JLAT1 = 1, YDGRID1_A%NY ()
    WRITE (*, '(F30.20)') ZLAT1 (JLAT1)
  ENDDO
  

  PRINT *, " YDGRID1%RLONOFF= ", YDGRID1%RLONOFF

  DO JLOC2 = 1, YLFS2_A%SIZE_OWNED ()
  BLOCK
    LOGICAL :: LLDBG
    INTEGER (KIND=JPIM) :: JLAT1A, JLAT1B, JLAT1M, INLON1

    LLDBG = (MYPROC == 1) .AND. (JLOC2 == 12)

    JLAT1A = 0; JLAT1B = YDGRID1_A%NY ()+1
    
    ZLON2 = ZLONLAT2_A (1, JLOC2)
    ZLAT2 = ZLONLAT2_A (2, JLOC2)

! Find nearest latitude just below

    DO 
      JLAT1M = (JLAT1A + JLAT1B) / 2
      IF (ZLAT1 (JLAT1A) >= ZLAT2 .AND. ZLAT2 >= ZLAT1 (JLAT1M)) THEN
        JLAT1B = JLAT1M
      ELSE
        JLAT1A = JLAT1M
      ENDIF
      IF (ABS (JLAT1B - JLAT1A) <= 1) EXIT
    ENDDO

    IF (LLDBG) THEN
      WRITE (0, *) __FILE__, ':', __LINE__, " JLAT1A, JLAT1B = ", JLAT1A, JLAT1B
      WRITE (0, *) " ZLAT2 = ", ZLAT2
      WRITE (0, *) " ZLON2 = ", ZLON2
    ENDIF
               

! Point above

    JLAT1B = JLAT1A + 1

    IF (JLAT1B > INLAT1+1) THEN
      PRINT *, " JLOC2 = ", JLOC2
      PRINT *, " ZLON2, ZLAT2 = ", ZLON2, ZLAT2
      PRINT *, " JLAT1B = ", JLAT1B
      PRINT *, " INLAT1 = ", INLAT1
      PRINT *, "STOP"
      STOP
    ENDIF

! Find nearest longitude just below

    IF (JLAT1A > 0) THEN
      INLON1 = YDGRID1_A%NX (JLAT1A)

! TODO : change this to work on other geometries (ie != from the sphere, with
! units in degrees)

      JLON1A = 1 + MODULO (INT ((REAL (INLON1, JPRB) &
           & * (ZLON2 - YDGRID1%RLONOFF)) / (360.0_JPRB)), INLON1)
IF (LLDBG) THEN
  WRITE (0, *) __FILE__, ':', __LINE__, " JLON1A = ", JLON1A
  PRINT *, " INLON1 = ", INLON1
  WRITE (*, '(E30.20)') (ZLON2 - YDGRID1%RLONOFF) / (360.0_JPRB)
  WRITE (*, '(E30.20)') REAL (INLON1, JPRB) * (ZLON2 - YDGRID1%RLONOFF) / (360.0_JPRB)
ENDIF
      IGLO1ALL_A (4*JLOC2+ISW) = IGLOOFF1 (JLAT1A) + JLON1A
      IGLO1ALL_A (4*JLOC2+ISE) = IGLOOFF1 (JLAT1A) + JNEXT (JLON1A, INLON1)
    ELSE
      JLON1A = 0
      IGLO1ALL_A (4*JLOC2+ISW) = 0
      IGLO1ALL_A (4*JLOC2+ISE) = 0
    ENDIF

    IF (JLAT1B < INLAT1+1) THEN
      INLON1 = YDGRID1_A%NX (JLAT1B)
      JLON1B = 1 + MODULO (INT ((REAL (INLON1, JPRB) &
           & * (ZLON2 - YDGRID1%RLONOFF)) / (360.0_JPRB)), INLON1)
      IGLO1ALL_A (4*JLOC2+INW) = IGLOOFF1 (JLAT1B) + JLON1B
      IGLO1ALL_A (4*JLOC2+INE) = IGLOOFF1 (JLAT1B) + JNEXT (JLON1B, INLON1)
    ELSE
      JLON1B = 0
      IGLO1ALL_A (4*JLOC2+INW) = 0
      IGLO1ALL_A (4*JLOC2+INE) = 0
    ENDIF

IF (LLDBG) WRITE (0, *) __FILE__, ':', __LINE__, " IGLO1ALL_A = ", IGLO1ALL_A (4*(JLOC2-1)+1:4*(JLOC2-1)+4)
    
  ENDBLOCK
  ENDDO

CALL PRIGLO (IGLO1ALL_A, "IGLO1ALL_A")

ENDBLOCK

  IF (LHOOK) CALL DR_HOOK ('CREATE_SHUFFLE4:1',1,ZHOOK_HANDLE_1)

  IF (LHOOK) CALL DR_HOOK ('CREATE_SHUFFLE4:2',0,ZHOOK_HANDLE_1)
  CALL SORTI4X1 (4*IGPTOT2, IORD_BY_GLO1, IGLO1ALL)
  IF (LHOOK) CALL DR_HOOK ('CREATE_SHUFFLE4:2',1,ZHOOK_HANDLE_1)

  IF (LHOOK) CALL DR_HOOK ('CREATE_SHUFFLE4:3',0,ZHOOK_HANDLE_1)
  CALL REVERSE (IORD_BY_GLO1, IREV_BY_GLO1)

! Reorder indices of grid #1

  IGLO1ALL = IGLO1ALL (IORD_BY_GLO1)

! Reduce the list of indices on grid #1

  IRED_BY_GLO1 (1) = 1
  JJ = 1
  DO II = 2, 4*IGPTOT2
    IF (IGLO1ALL (II-1) == IGLO1ALL (II)) THEN
      IRED_BY_GLO1 (II) = IRED_BY_GLO1 (II-1)
    ELSE
      JJ = JJ + 1
      IRED_BY_GLO1 (II) = JJ
    ENDIF
  ENDDO

  INPT1 = JJ

! Build the list of indices of grid #1 (unique indices)

  ALLOCATE (IPRCGLO1 (2, INPT1))
  IPRC1 => IPRCGLO1 (1, :)
  IGLO1 => IPRCGLO1 (2, :)
  DO II = 1, 4*IGPTOT2
    IGLO1 (IRED_BY_GLO1 (II)) = IGLO1ALL (II)
  ENDDO
  IF (LHOOK) CALL DR_HOOK ('CREATE_SHUFFLE4:3',1,ZHOOK_HANDLE_1)

! Find processors of elements of grid #1
  IF (LHOOK) CALL DR_HOOK ('CREATE_SHUFFLE4:4',0,ZHOOK_HANDLE_1)

!$OMP PARALLEL DO PRIVATE (II, JLAT1A, JLAT1B, JLAT1M, JLAT1, JLON1, JA1, JB1)
  DO II = 1, INPT1
    IF (IGLO1 (II) /= 0) THEN
      JLAT1A = 1; JLAT1B = INLAT1+1
      DO
        JLAT1M = (JLAT1A + JLAT1B) / 2
        IF (IGLOOFF1 (JLAT1A)+1 <= IGLO1 (II) .AND. IGLO1 (II) <= IGLOOFF1 (JLAT1M)) THEN
          JLAT1B = JLAT1M
        ELSE
          JLAT1A = JLAT1M
        ENDIF
        IF (JLAT1B - JLAT1A <= 1) EXIT
      ENDDO
      JLAT1 = JLAT1A; JLON1 = IGLO1 (II) - IGLOOFF1 (JLAT1)
      CALL JLONJLAT_TO_JAJB (JLON1, JLAT1, YDDIST1, JA1, JB1)
      IPRC1 (II) = YDDIST1%NGPSET2PE (JA1, JB1)
    ELSE
      IPRC1 (II) = 0
    ENDIF
  ENDDO
!$OMP END PARALLEL DO

  IF (LHOOK) CALL DR_HOOK ('CREATE_SHUFFLE4:4',1,ZHOOK_HANDLE_1)

! Sort by processor, global index

  IF (LHOOK) CALL DR_HOOK ('CREATE_SHUFFLE4:5',0,ZHOOK_HANDLE_1)

  ALLOCATE (IORD_BY_PRC1GLO1 (INPT1), IREV_BY_PRC1GLO1 (INPT1))
  CALL SORTI4X2 (INPT1, IORD_BY_PRC1GLO1, IPRCGLO1)

  CALL REVERSE (IORD_BY_PRC1GLO1, IREV_BY_PRC1GLO1)

! Reorder

  IGLO1 = IGLO1 (IORD_BY_PRC1GLO1)
  IPRC1 = IPRC1 (IORD_BY_PRC1GLO1)

! Final sort array
  YDSHFL4%ISORT = IREV_BY_PRC1GLO1 (IRED_BY_GLO1 (IREV_BY_GLO1))

  IF (LHOOK) CALL DR_HOOK ('CREATE_SHUFFLE4:5',1,ZHOOK_HANDLE_1)
ENDBLOCK

BLOCK
  INTEGER (KIND=JPIM), ALLOCATABLE :: IREQRECV (:), IREQSEND (:)
  INTEGER (KIND=JPIM) :: ISENDCNT (INPROC), IRECVCNT (INPROC)
  INTEGER (KIND=JPIM) :: IPROC, ISKIP, ICNT, IOFF, II
  INTEGER (KIND=JPIM) :: INSEND, INRECV
  INTEGER (KIND=JPIM), ALLOCATABLE :: IGLOBAL1 (:)

  IF (LHOOK) CALL DR_HOOK ('CREATE_SHUFFLE4:6',0,ZHOOK_HANDLE_1)

  ISKIP = 0 ! Number of points not found; they are supposed to be at the begining of the list
  IRECVCNT = 0
  DO II = 1, SIZE (IPRC1)
    IPROC = IPRC1 (II)
    IF (IPROC > 0) THEN
      IRECVCNT (IPROC) = IRECVCNT (IPROC) + 1
    ELSE
      ISKIP = ISKIP + 1
    ENDIF
  ENDDO

! Copy indices to contiguous array for sending

  ALLOCATE (IGLOBAL1 (SIZE (IGLO1)))
  IGLOBAL1 = IGLO1
  DEALLOCATE (IPRCGLO1); NULLIFY (IGLO1); NULLIFY (IPRC1)


! Exchange send/recv counts

  CALL MPL_ALLTOALLV (KSENDBUF=IRECVCNT, KRECVBUF=ISENDCNT, &
                    & KSENDCOUNTS=[(1,IPROC=1,INPROC)],   &
                    & KRECVCOUNTS=[(1,IPROC=1,INPROC)],   &
                    & CDSTRING='CREATE_SHUFFLE4', KCOMM=ICOMM)

  INSEND = COUNT (ISENDCNT /= 0)
  INRECV = COUNT (IRECVCNT /= 0)

! Create send/recv descriptors

  ALLOCATE (YDSHFL4%YL_SEND (INSEND), YDSHFL4%YL_RECV (INRECV))

  INSEND = 0
  DO IPROC = 1, INPROC
    IF (ISENDCNT (IPROC) > 0) THEN
      INSEND = INSEND + 1
      YDSHFL4%YL_SEND (INSEND)%IPROC = IPROC
      YDSHFL4%YL_SEND (INSEND)%ICNT = ISENDCNT (IPROC)
      ALLOCATE (YDSHFL4%YL_SEND (INSEND)%ILOCAL  (ISENDCNT (IPROC)))
    ENDIF
  ENDDO
  YDSHFL4%YL_SEND (1)%IOFF = 0
  DO II = 2, INSEND
    YDSHFL4%YL_SEND (II)%IOFF = YDSHFL4%YL_SEND (II-1)%IOFF + YDSHFL4%YL_SEND (II-1)%ICNT
  ENDDO

  INRECV = 0
  DO IPROC = 1, INPROC
    IF (IRECVCNT (IPROC) > 0) THEN
      INRECV = INRECV + 1
      YDSHFL4%YL_RECV (INRECV)%IPROC = IPROC
      YDSHFL4%YL_RECV (INRECV)%ICNT  = IRECVCNT (IPROC)
    ENDIF
  ENDDO
  YDSHFL4%YL_RECV (1)%IOFF = ISKIP
  DO II = 2, INRECV
    YDSHFL4%YL_RECV (II)%IOFF = YDSHFL4%YL_RECV (II-1)%IOFF + YDSHFL4%YL_RECV (II-1)%ICNT
  ENDDO

  IF (LHOOK) CALL DR_HOOK ('CREATE_SHUFFLE4:6',1,ZHOOK_HANDLE_1)

! Exchange global indices of grid #1

  IF (LHOOK) CALL DR_HOOK ('CREATE_SHUFFLE4:7',0,ZHOOK_HANDLE_1)

  ALLOCATE (IREQSEND (INSEND), IREQRECV (INRECV))
  IREQSEND = MPI_REQUEST_NULL
  IREQRECV = MPI_REQUEST_NULL

! Send indices we need to send values for

  DO II = 1, INSEND
! Receive global indices in ILOCAL; they will be translated to local indices later
    IPROC = YDSHFL4%YL_SEND (II)%IPROC
    CALL MPL_RECV (KBUF=YDSHFL4%YL_SEND (II)%ILOCAL, KSOURCE=IPROC, KTAG=101, CDSTRING='CREATE_SHUFFLE4', &
                 & KMP_TYPE=JP_NON_BLOCKING_STANDARD, KREQUEST=IREQSEND (II), KCOMM=ICOMM)
  ENDDO

  CALL MPL_BARRIER (CDSTRING='CREATE_SHUFFLE4', KCOMM=ICOMM)

! Receive indices we shall send values for

  DO II = 1, INRECV
    IOFF = YDSHFL4%YL_RECV (II)%IOFF
    ICNT = YDSHFL4%YL_RECV (II)%ICNT
    IPROC = YDSHFL4%YL_RECV (II)%IPROC
    CALL MPL_SEND (KBUF=IGLOBAL1 (IOFF+1:IOFF+ICNT), KDEST=IPROC, KTAG=101, CDSTRING='CREATE_SHUFFLE4', &
                 & KMP_TYPE=JP_NON_BLOCKING_STANDARD, KREQUEST=IREQRECV (II), KCOMM=ICOMM)
  ENDDO

  CALL MPL_WAIT (KREQUEST=IREQSEND, CDSTRING='CREATE_SHUFFLE4')

  IF (LHOOK) CALL DR_HOOK ('CREATE_SHUFFLE4:7',1,ZHOOK_HANDLE_1)

! We have received the global indices we should transmit; decode them into
! lat/lon indices, then into local indices

  BLOCK
    INTEGER (KIND=JPIM) :: II, JJ, JGLO1, JLAT1A, JLAT1B, JLAT1M, JLAT1, JLON1, JLOC1
    INTEGER (KIND=JPIM), ALLOCATABLE :: ILOCOFF1 (:)
    TYPE (REGION_t) :: YLMYREG1

    IF (LHOOK) CALL DR_HOOK ('CREATE_SHUFFLE4:8',0,ZHOOK_HANDLE_1)

    CALL GET_MYREGION (YLMYREG1, YDDIST1, YDGRID1)

    ALLOCATE (ILOCOFF1 (YLMYREG1%NLAN:YLMYREG1%NLAS))
   
! First compute an ancillary array to go from lat/lon indices to local indices

    ILOCOFF1 (YLMYREG1%NLAN) = 0
    DO JLAT1 = YLMYREG1%NLAN+1, YLMYREG1%NLAS
      ILOCOFF1 (JLAT1) = ILOCOFF1 (JLAT1-1) + 1 + &
         & MODULO (YLMYREG1%NLOE (JLAT1-1) - YLMYREG1%NLOW (JLAT1-1), YDGRID1%NLOEN (JLAT1-1))
    ENDDO

!$OMP PARALLEL DO PRIVATE (II, JJ, JGLO1, JLAT1A, JLAT1B, JLAT1M, JLAT1, JLON1, JLOC1) 
    DO II = 1, INSEND
      DO JJ = 1, SIZE (YDSHFL4%YL_SEND (II)%ILOCAL)
        JGLO1 = YDSHFL4%YL_SEND (II)%ILOCAL (JJ)
        JLAT1A = 1; JLAT1B = INLAT1+1
        DO
          JLAT1M = (JLAT1A + JLAT1B) / 2
          IF (IGLOOFF1 (JLAT1A)+1 <= JGLO1 .AND. JGLO1 <= IGLOOFF1 (JLAT1M)) THEN
            JLAT1B = JLAT1M
          ELSE
            JLAT1A = JLAT1M
          ENDIF
          IF (JLAT1B - JLAT1A <= 1) EXIT
        ENDDO
        JLAT1 = JLAT1A; JLON1 = JGLO1 - IGLOOFF1 (JLAT1)
        JLOC1 = ILOCOFF1 (JLAT1) + 1 + MODULO (JLON1-YLMYREG1%NLOW (JLAT1), YDGRID1%NLOEN (JLAT1))
        YDSHFL4%YL_SEND (II)%ILOCAL (JJ) = JLOC1
      ENDDO
    ENDDO
!$OMP END PARALLEL DO
  ENDBLOCK

  IF (LHOOK) CALL DR_HOOK ('CREATE_SHUFFLE4:8',1,ZHOOK_HANDLE_1)
  IF (LHOOK) CALL DR_HOOK ('CREATE_SHUFFLE4:9',0,ZHOOK_HANDLE_1)

  CALL MPL_WAIT (KREQUEST=IREQRECV, CDSTRING='CREATE_SHUFFLE4')

  YDSHFL4%ISIZE = YDSHFL4%YL_RECV (1)%IOFF+SUM (YDSHFL4%YL_RECV%ICNT)

  IF (LHOOK) CALL DR_HOOK ('CREATE_SHUFFLE4:9',1,ZHOOK_HANDLE_1)
ENDBLOCK

IF (LHOOK) CALL DR_HOOK ('CREATE_SHUFFLE4',1,ZHOOK_HANDLE)

CONTAINS

SUBROUTINE REVERSE (KORD, KREV)

INTEGER (KIND=JPIM) :: KORD (:), KREV (:)
INTEGER (KIND=JPIM) :: II

KREV = [(II, II = 1, SIZE (KREV))]
KREV (KORD) = KREV

END SUBROUTINE

SUBROUTINE PRIGLO (KGLO1ALL, CDBASE)

INTEGER (KIND=JPIM) :: KGLO1ALL (:)
CHARACTER (LEN=*) :: CDBASE

INTEGER (KIND=JPIM) :: JLOC2
CHARACTER (LEN=32) :: CLFILE

WRITE (CLFILE, '(I6.6)') MYPROC
CLFILE = TRIM (CDBASE) // '.' // TRIM (CLFILE)

OPEN (77, FILE=TRIM (CLFILE), FORM="FORMATTED")

  WRITE (77, '(A8," > ",4A8)') "", "SW", "SE", "NW", "NE"
  DO JLOC2 = 1, SIZE (KGLO1ALL) / 4
    WRITE (77, '(I8," > ",4I8)') JLOC2, KGLO1ALL (4*(JLOC2-1)+1:4*(JLOC2-1)+4)
  ENDDO

CLOSE (77)

END SUBROUTINE

END SUBROUTINE CREATE_SHUFFLE4A

SUBROUTINE DO_SHUFFLE4 (YDDIST1, YDGRID1, YDDIST2, YDGRID2, YDSHFL4, PGP1, PGP2E)

USE MPL_MPIF,          ONLY : MPI_REQUEST_NULL, MPI_UNDEFINED
USE MPL_DATA_MODULE,   ONLY : JP_NON_BLOCKING_STANDARD
USE MPL_MODULE,        ONLY : MPL_MYRANK, MPL_NUMPROC
USE MPL_ALLTOALLV_MOD, ONLY : MPL_ALLTOALLV
USE MPL_SEND_MOD,      ONLY : MPL_SEND
USE MPL_RECV_MOD,      ONLY : MPL_RECV
USE MPL_BARRIER_MOD,   ONLY : MPL_BARRIER
USE MPL_WAIT_MOD,      ONLY : MPL_WAIT
USE MPL_MODULE,        ONLY : MPL_COMM_OML

TYPE (DIST_t),     INTENT (IN)  :: YDDIST1, YDDIST2
TYPE (GRID_t),     INTENT (IN)  :: YDGRID1, YDGRID2
TYPE (SHUFFLE4_t), INTENT (IN)  :: YDSHFL4
REAL (KIND=JPRB),  INTENT (IN)  :: PGP1 (:,:)
REAL (KIND=JPRB),  INTENT (OUT) :: PGP2E (:,:)

REAL (KIND=JPRB) :: ZBUFR (SIZE (PGP1, 2) * (YDSHFL4%YL_RECV (1)%IOFF+SUM (YDSHFL4%YL_RECV%ICNT)))
REAL (KIND=JPRB) :: ZBUFS (SIZE (PGP1, 2) * (YDSHFL4%YL_SEND (1)%IOFF+SUM (YDSHFL4%YL_SEND%ICNT)))
INTEGER (KIND=JPIM) :: MYPROC, INFLD, JFLD
INTEGER (KIND=JPIM) :: ICOMM
INTEGER (KIND=JPIM) :: II, IOFF, ICNT, JJ, JLOC2, JIND1

INTEGER (KIND=JPIM) :: IREQRECV (SIZE (YDSHFL4%YL_RECV)), IREQSEND (SIZE (YDSHFL4%YL_SEND))
REAL (KIND=JPRB) :: ZHOOK_HANDLE, ZHOOK_HANDLE_1

IF (LHOOK) CALL DR_HOOK ('DO_SHUFFLE4',0,ZHOOK_HANDLE)

MYPROC = MPL_MYRANK ()
ICOMM  = MPL_COMM_OML (1)

INFLD   = SIZE (PGP1, 2)

IREQRECV = MPI_REQUEST_NULL
IREQSEND = MPI_REQUEST_NULL

ZBUFR (1:YDSHFL4%YL_RECV (1)%IOFF) = 0._JPRB
DO II = 1, SIZE (YDSHFL4%YL_RECV)
  IOFF = YDSHFL4%YL_RECV (II)%IOFF
  ICNT = YDSHFL4%YL_RECV (II)%ICNT
  CALL MPL_RECV (PBUF=ZBUFR (INFLD*IOFF+1:INFLD*IOFF+INFLD*ICNT), KCOMM=ICOMM,         &
               & KSOURCE=YDSHFL4%YL_RECV (II)%IPROC, KTAG=101, CDSTRING='DO_SHUFFLE4', &
               & KMP_TYPE=JP_NON_BLOCKING_STANDARD, KREQUEST=IREQRECV (II))
ENDDO

CALL MPL_BARRIER (CDSTRING='DO_SHUFFLE4', KCOMM=ICOMM)

!$OMP PARALLEL DO PRIVATE (II, IOFF, ICNT, JFLD)
DO II = 1, SIZE (YDSHFL4%YL_SEND)
  IOFF = YDSHFL4%YL_SEND (II)%IOFF
  ICNT = YDSHFL4%YL_SEND (II)%ICNT
  DO JFLD = 1, INFLD
    ZBUFS (INFLD*IOFF+(JFLD-1)*ICNT+1:INFLD*IOFF+JFLD*ICNT) = PGP1 (YDSHFL4%YL_SEND (II)%ILOCAL, JFLD)
  ENDDO
  CALL MPL_SEND (PBUF=ZBUFS (INFLD*IOFF+1:INFLD*IOFF+INFLD*ICNT), KCOMM=ICOMM,       &
               & KDEST=YDSHFL4%YL_SEND (II)%IPROC, KTAG=101, CDSTRING='DO_SHUFFLE4', &
               & KMP_TYPE=JP_NON_BLOCKING_STANDARD, KREQUEST=IREQSEND (II))
ENDDO
!$OMP END PARALLEL DO

CALL MPL_WAIT (KREQUEST=IREQRECV, CDSTRING='DO_SHUFFLE4')

PGP2E (1:YDSHFL4%YL_RECV (1)%IOFF,:) = 0._JPRB
!$OMP PARALLEL DO PRIVATE (II, IOFF, ICNT, JFLD)
DO II = 1, SIZE (YDSHFL4%YL_RECV)
  IOFF = YDSHFL4%YL_RECV (II)%IOFF
  ICNT = YDSHFL4%YL_RECV (II)%ICNT
  DO JFLD = 1, INFLD
    PGP2E (IOFF+1:IOFF+ICNT, JFLD) = ZBUFR (INFLD*IOFF+(JFLD-1)*ICNT+1:INFLD*IOFF+JFLD*ICNT)
  ENDDO
ENDDO
!$OMP END PARALLEL DO

CALL MPL_WAIT (KREQUEST=IREQSEND, CDSTRING='DO_SHUFFLE4')

IF (LHOOK) CALL DR_HOOK ('DO_SHUFFLE4',1,ZHOOK_HANDLE)

END SUBROUTINE

SUBROUTINE CREATE_WEIGHTS4 (YDDIST1, YDGRID1, YDDIST2, YDGRID2, YDSHFL4, YDWGHT4)

USE MPL_MODULE,        ONLY : MPL_MYRANK, MPL_NUMPROC

TYPE (DIST_t),     INTENT (IN)  :: YDDIST1, YDDIST2
TYPE (GRID_t),     INTENT (IN)  :: YDGRID1, YDGRID2
TYPE (SHUFFLE4_t), INTENT (IN)  :: YDSHFL4
TYPE (WEIGHTS4_t), INTENT (OUT) :: YDWGHT4

INTEGER (KIND=JPIM), PARAMETER :: ISW = -3, ISE = -2, INW = -1, INE = -0

INTEGER (KIND=JPIM) :: MYPROC, IGPTOT1, IGPTOT2

REAL (KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK ('CREATE_WEIGHTS4',0,ZHOOK_HANDLE)

MYPROC = MPL_MYRANK ()

IGPTOT1  = YDDIST1%NGPTOTL (MYPROC)
IGPTOT2  = YDDIST2%NGPTOTL (MYPROC)

BLOCK
  REAL (KIND=JPRB) :: ZXYZ1 (IGPTOT1, 3), ZXYZ2 (IGPTOT2, 3) 
  REAL (KIND=JPRB) :: ZXYZ2E (YDSHFL4%ISIZE, 3)
  INTEGER (KIND=JPIM) :: JLOC2, JJ, JIND1
  INTEGER (KIND=JPIM) :: JI1SE, JI1SW, JI1NE, JI1NW

  CALL GET_MY_XYZ (YDGRID1, YDDIST1, ZXYZ1)
  CALL DO_SHUFFLE4 (YDDIST1, YDGRID1, YDDIST2, YDGRID2, YDSHFL4, ZXYZ1, ZXYZ2E)
  CALL GET_MY_XYZ (YDGRID2, YDDIST2, ZXYZ2)

  ALLOCATE (YDWGHT4%ZVALUES (4*IGPTOT2))

!$OMP PARALLEL DO PRIVATE (JLOC2, JJ, JIND1)
  DO JLOC2 = 1, IGPTOT2
! The weight is the inverse of the distance in radian between the target point 
! and the points used for interpolation
    DO JJ = ISW, INE
      JIND1 = YDSHFL4%ISORT (4*JLOC2+JJ)
! affect a zero value when there is no point; prevent division by zero
      YDWGHT4%ZVALUES (4*JLOC2+JJ) = REAL (MIN (JIND1, 1), JPRB) / &
     & MAX (ACOS (SUM (ZXYZ2E (JIND1, 1:3) * ZXYZ2 (JLOC2, 1:3))), 1.E-10_JPRB)
    ENDDO
! Rebalance weights so that their sum be 1
    YDWGHT4%ZVALUES (4*JLOC2+ISW:4*JLOC2+INE) = YDWGHT4%ZVALUES (4*JLOC2+ISW:4*JLOC2+INE) &
                                       & / SUM (YDWGHT4%ZVALUES (4*JLOC2+ISW:4*JLOC2+INE))
  
  ENDDO
!$OMP END PARALLEL DO

ENDBLOCK

IF (LHOOK) CALL DR_HOOK ('CREATE_WEIGHTS4',1,ZHOOK_HANDLE)

END SUBROUTINE

SUBROUTINE DO_INTERPOLATION4 (YDDIST1, YDGRID1, YDDIST2, YDGRID2, PGP1, PGP2, &
                            & YDWGHT4, PUNDEF, LDUNDEF, PGP2E, YDSHFL12)

USE MPL_MODULE,        ONLY : MPL_MYRANK, MPL_NUMPROC

TYPE (DIST_t),    INTENT (IN)  :: YDDIST1, YDDIST2
TYPE (GRID_t),    INTENT (IN)  :: YDGRID1, YDGRID2
REAL (KIND=JPRB), INTENT (IN)  :: PGP1 (:,:)
REAL (KIND=JPRB), INTENT (OUT) :: PGP2 (:,:)
TYPE (WEIGHTS4_t),INTENT (IN)  :: YDWGHT4
REAL (KIND=JPRB), INTENT (IN), OPTIONAL :: PUNDEF (:)
LOGICAL,          INTENT (IN), OPTIONAL :: LDUNDEF (:)
REAL (KIND=JPRB), INTENT (IN), OPTIONAL, TARGET :: PGP2E (:,:)
TYPE (SHUFFLE4_t),INTENT (IN), OPTIONAL :: YDSHFL12

INTEGER (KIND=JPIM) :: MYPROC, IGPTOT1, IGPTOT2, INFLD
INTEGER (KIND=JPIM), PARAMETER :: ISW = -3, ISE = -2, INW = -1, INE = -0

REAL (KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK ('DO_INTERPOLATION4',0,ZHOOK_HANDLE)

MYPROC   = MPL_MYRANK ()
IGPTOT1  = YDDIST1%NGPTOTL (MYPROC)
IGPTOT2  = YDDIST2%NGPTOTL (MYPROC)
INFLD    = SIZE (PGP1, 2)

BLOCK
  REAL (KIND=JPRB), POINTER :: ZGP2E (:,:)
  REAL (KIND=JPRB), ALLOCATABLE, TARGET :: ZZGP2E (:,:)
  LOGICAL :: LLUNDEF (INFLD)
  INTEGER (KIND=JPIM) :: JFLD, JISW, JISE, JINW, JINE, JJ, JIND, JLOC2
  REAL (KIND=JPRB) :: ZWG

  IF (PRESENT (LDUNDEF) .AND. PRESENT (PUNDEF)) THEN
    LLUNDEF = LDUNDEF
  ELSE
    LLUNDEF = PRESENT (PUNDEF)
  ENDIF
 
  IF (PRESENT (YDSHFL12)) THEN
    ALLOCATE (ZZGP2E (YDSHFL12%ISIZE, INFLD))
    ZGP2E => ZZGP2E
    CALL DO_SHUFFLE4 (YDDIST1, YDGRID1, YDDIST2, YDGRID2, YDSHFL12, PGP1, ZGP2E)
  ELSE
    ZGP2E => PGP2E
  ENDIF

  DO JFLD = 1, INFLD
    IF (LLUNDEF (JFLD)) THEN
!$OMP PARALLEL DO PRIVATE (JLOC2, ZWG, JJ, JIND)
      DO JLOC2 = 1, IGPTOT2
        PGP2 (JLOC2, JFLD) = 0._JPRB
        ZWG = 0._JPRB
        DO JJ = ISW, INE
          JIND = YDSHFL12%ISORT (4*JLOC2+JJ)
          IF (ZGP2E (JIND, JFLD) /= PUNDEF (JFLD)) THEN
            PGP2 (JLOC2, JFLD) = PGP2 (JLOC2, JFLD) + &
                & YDWGHT4%ZVALUES (4*JLOC2+JJ) * ZGP2E (JIND, JFLD)
            ZWG = ZWG + YDWGHT4%ZVALUES (4*JLOC2+JJ)
          ENDIF
        ENDDO
        IF (ZWG > 0._JPRB) THEN
          PGP2 (JLOC2, JFLD) = PGP2 (JLOC2, JFLD) / ZWG
        ELSE
          PGP2 (JLOC2, JFLD) = PUNDEF (JFLD)
        ENDIF
      ENDDO
!$OMP END PARALLEL DO
    ELSE
!$OMP PARALLEL DO PRIVATE (JLOC2, JISW, JISE, JINW, JINE)
      DO JLOC2 = 1, IGPTOT2
        JISW = YDSHFL12%ISORT (4*JLOC2+ISW)
        JISE = YDSHFL12%ISORT (4*JLOC2+ISE)
        JINW = YDSHFL12%ISORT (4*JLOC2+INW)
        JINE = YDSHFL12%ISORT (4*JLOC2+INE)
        PGP2 (JLOC2, JFLD) = &
          & YDWGHT4%ZVALUES (4*JLOC2+ISW) * ZGP2E (JISW, JFLD) + &
          & YDWGHT4%ZVALUES (4*JLOC2+ISE) * ZGP2E (JISE, JFLD) + &
          & YDWGHT4%ZVALUES (4*JLOC2+INW) * ZGP2E (JINW, JFLD) + &
          & YDWGHT4%ZVALUES (4*JLOC2+INE) * ZGP2E (JINE, JFLD)
      ENDDO
!$OMP END PARALLEL DO
    ENDIF

  ENDDO


ENDBLOCK

IF (LHOOK) CALL DR_HOOK ('DO_INTERPOLATION4',1,ZHOOK_HANDLE)

END SUBROUTINE

SUBROUTINE DO_INTERPOLATION (YDDIST1, YDGRID1, YDDIST2, YDGRID2, PGP1, PGP2, &
                           & PUNDEF, LDUNDEF, PGP2E, YDSHFL12, CDTYPE)

USE MPL_MODULE,        ONLY : MPL_MYRANK, MPL_NUMPROC

TYPE (DIST_t),    INTENT (IN)  :: YDDIST1, YDDIST2
TYPE (GRID_t),    INTENT (IN)  :: YDGRID1, YDGRID2
REAL (KIND=JPRB), INTENT (IN)  :: PGP1 (:,:)
REAL (KIND=JPRB), INTENT (OUT) :: PGP2 (:,:)
REAL (KIND=JPRB), INTENT (IN), OPTIONAL :: PUNDEF (:)
LOGICAL,          INTENT (IN), OPTIONAL :: LDUNDEF (:)
REAL (KIND=JPRB), INTENT (IN), OPTIONAL, TARGET :: PGP2E (:,:)
TYPE (SHUFFLE_t), INTENT (IN), OPTIONAL :: YDSHFL12
CHARACTER (LEN=*),INTENT (IN), OPTIONAL :: CDTYPE (:)


INTEGER (KIND=JPIM) :: IGPTOT1, IGPTOT2, ISUMRECV, MYPROC
INTEGER (KIND=JPIM) :: II, JLOC2, ICNT, IOFF, JFLD, INFLD, ICNTD

REAL(KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK ('DO_INTERPOLATION',0,ZHOOK_HANDLE)

MYPROC   = MPL_MYRANK ()
IGPTOT1  = YDDIST1%NGPTOTL (MYPROC)
IGPTOT2  = YDDIST2%NGPTOTL (MYPROC)
ISUMRECV = SUM (YDSHFL12%YL_RECV%ISIZE)
INFLD    = SIZE (PGP1, 2)

BLOCK
  REAL (KIND=JPRB), POINTER :: ZGP2E (:,:)
  REAL (KIND=JPRB), ALLOCATABLE, TARGET :: ZZGP2E (:,:)
  LOGICAL :: LLUNDEF (INFLD)
  CHARACTER(LEN=3) :: CLTYPE (INFLD)
REAL (KIND=JPRB), PARAMETER :: ZZ2 = 1.7E+308_JPRB, ZZ1 = 8.0E+307_JPRB

  IF (PRESENT (LDUNDEF) .AND. PRESENT (PUNDEF)) THEN
    LLUNDEF = LDUNDEF
  ELSE
    LLUNDEF = PRESENT (PUNDEF)
  ENDIF
 
  IF (PRESENT (YDSHFL12)) THEN
    ALLOCATE (ZZGP2E (ISUMRECV, INFLD))
    ZGP2E => ZZGP2E
    CALL DO_SHUFFLE (YDDIST1, YDGRID1, YDDIST2, YDGRID2, YDSHFL12, PGP1, ZGP2E)
  ELSE
    ZGP2E => PGP2E
  ENDIF

  IF (PRESENT (CDTYPE)) THEN
    CLTYPE = CDTYPE (1:3) (:)
  ELSE
    CLTYPE = 'AVG'
  ENDIF
  
!$OMP PARALLEL DO PRIVATE (JFLD, JLOC2, II, IOFF, ICNT, ICNTD) COLLAPSE (2)
  DO JFLD = 1, INFLD
    DO JLOC2 = 1, IGPTOT2
  
      IOFF = YDSHFL12%ILOCAL_OFF (JLOC2)
      ICNT = YDSHFL12%ILOCAL_CNT (JLOC2)

      PGP2 (JLOC2, JFLD) = 0._JPRB

      SELECT CASE (CLTYPE (JFLD))
        CASE ('AVG')
          IF (LLUNDEF (JFLD)) THEN
            ICNTD = 0
            DO II = IOFF+1, IOFF+ICNT
               IF (ZGP2E (II, JFLD) /= PUNDEF (JFLD)) THEN
                 PGP2 (JLOC2, JFLD) = PGP2 (JLOC2, JFLD) + ZGP2E (II, JFLD)
                 ICNTD = ICNTD + 1
               ENDIF
            ENDDO
            IF (ICNTD > 0) THEN
              PGP2 (JLOC2, JFLD) = PGP2 (JLOC2, JFLD) / REAL (ICNTD, JPRB)
            ELSE
              PGP2 (JLOC2, JFLD) = PUNDEF (JFLD)
            ENDIF
          ELSE
            DO II = IOFF+1, IOFF+ICNT
               PGP2 (JLOC2, JFLD) = PGP2 (JLOC2, JFLD) + ZGP2E (II, JFLD)
            ENDDO
            PGP2 (JLOC2, JFLD) = PGP2 (JLOC2, JFLD) / REAL (ICNT, JPRB)
          ENDIF
        CASE ('MAX')
          IF (LLUNDEF (JFLD)) THEN
            IF (COUNT (ZGP2E (IOFF+1:IOFF+ICNT, JFLD) /= PUNDEF (JFLD)) > 0) THEN
              PGP2 (JLOC2, JFLD) = MAXVAL (ZGP2E (IOFF+1:IOFF+ICNT, JFLD), &
                    & MASK=ZGP2E (IOFF+1:IOFF+ICNT, JFLD) /= PUNDEF (JFLD))
            ELSE
              PGP2 (JLOC2, JFLD) = PUNDEF (JFLD)
            ENDIF
          ELSE
            PGP2 (JLOC2, JFLD) = MAXVAL (ZGP2E (IOFF+1:IOFF+ICNT, JFLD))
          ENDIF
        CASE ('MIN')
          IF (LLUNDEF (JFLD)) THEN
            IF (COUNT (ZGP2E (IOFF+1:IOFF+ICNT, JFLD) /= PUNDEF (JFLD)) > 0) THEN
              PGP2 (JLOC2, JFLD) = MINVAL (ZGP2E (IOFF+1:IOFF+ICNT, JFLD), &
                    & MASK=ZGP2E (IOFF+1:IOFF+ICNT, JFLD) /= PUNDEF (JFLD))
            ELSE
              PGP2 (JLOC2, JFLD) = PUNDEF (JFLD)
            ENDIF
          ELSE
            PGP2 (JLOC2, JFLD) = MINVAL (ZGP2E (IOFF+1:IOFF+ICNT, JFLD))
          ENDIF
      END SELECT
    ENDDO
  ENDDO
!$OMP END PARALLEL DO
  
ENDBLOCK

IF (LHOOK) CALL DR_HOOK ('DO_INTERPOLATION',1,ZHOOK_HANDLE)

END SUBROUTINE 

SUBROUTINE DEMO_GRADIENT (YDDIST, YDGRID)

USE MPL_MODULE,        ONLY : MPL_MYRANK, MPL_NUMPROC

TYPE (DIST_t),    INTENT (IN)     :: YDDIST
TYPE (GRID_t),    INTENT (IN)     :: YDGRID

INTEGER (KIND=JPIM) :: IGPTOT, MYPROC
TYPE (HALO_t)   :: YLHALO

MYPROC   = MPL_MYRANK ()
IGPTOT   = YDDIST%NGPTOTL (MYPROC)

CALL CREATE_HALO (YDGRID, YDDIST, 1, YLHALO)

BLOCK
  REAL (KIND=JPRB) :: ZCOORDYX (YLHALO%ISIZE+YLHALO%IH_SIZE, 2)
  REAL (KIND=JPRB) :: ZLATLON  (IGPTOT,                      2)
  REAL (KIND=JPRB) :: ZXYZ     (IGPTOT,                      3)
  REAL (KIND=JPRB) :: ZGRADX_  (IGPTOT,                      3)
  REAL (KIND=JPRB) :: ZGRADY_  (IGPTOT,                      3)
  REAL (KIND=JPRB) :: ZGP      (YLHALO%ISIZE+YLHALO%IH_SIZE, 3)
  REAL (KIND=JPRB) :: ZGRADX   (YLHALO%ISIZE+YLHALO%IH_SIZE, 3)
  REAL (KIND=JPRB) :: ZGRADY   (YLHALO%ISIZE+YLHALO%IH_SIZE, 3)
  REAL (KIND=JPRB) :: ZROTX (3, 3), ZROTY (3, 3), ZROTZ (3, 3), ZROTXYZ (3, 3)
  REAL (KIND=JPRB) :: ZANGX,        ZANGY,        ZANGZ
  REAL (KIND=JPRB) :: ZFACTOR (IGPTOT)
  INTEGER (KIND=JPIM) :: JL
  REAL (KIND=JPRB) :: ZLAT, ZSINLAT

  ZROTX = 0._JPRB; ZROTX (1,1) = 1._JPRB; ZROTX (2,2) = 1._JPRB; ZROTX (3,3) = 1._JPRB
  ZROTY = 0._JPRB; ZROTY (1,1) = 1._JPRB; ZROTY (2,2) = 1._JPRB; ZROTY (3,3) = 1._JPRB
  ZROTZ = 0._JPRB; ZROTZ (1,1) = 1._JPRB; ZROTZ (2,2) = 1._JPRB; ZROTZ (3,3) = 1._JPRB

  ZANGX = RPI / 4._JPRB
  ZROTX ([2,3],2) = [+COS(ZANGX),-SIN(ZANGX)]
  ZROTX ([2,3],3) = [+SIN(ZANGX),+COS(ZANGX)]

  ZANGY = RPI / 3._JPRB
  ZROTY ([1,3],1) = [+COS(ZANGY),+SIN(ZANGY)]
  ZROTY ([1,3],3) = [-SIN(ZANGY),+COS(ZANGY)]

  ZANGZ = 0._JPRB
  ZROTZ ([1,2],1) = [+COS(ZANGZ),+SIN(ZANGZ)]
  ZROTZ ([1,2],2) = [-SIN(ZANGZ),+COS(ZANGZ)]

  ZROTXYZ (1:3,1) = ROT (ZROTZ, ROT (ZROTY, ZROTX (1:3,1)))
  ZROTXYZ (1:3,2) = ROT (ZROTZ, ROT (ZROTY, ZROTX (1:3,2)))
  ZROTXYZ (1:3,3) = ROT (ZROTZ, ROT (ZROTY, ZROTX (1:3,3)))

  CALL GET_MY_LATLON  (YDGRID, YDDIST, ZLATLON)
  CALL GET_MY_COORDYX (YDGRID, YDDIST, ZCOORDYX)
  CALL GET_MY_XYZ (YDGRID, YDDIST, ZXYZ)

  DO JL = 1, IGPTOT

    ZGP (JL, 1) = ZXYZ (JL, 1)
    ZGP (JL, 2) = ZXYZ (JL, 2)
    ZGP (JL, 3) = ZXYZ (JL, 3)

! Rotate

!   ZGP     (JL, :) = ROT (ZROTXYZ, ZGP     (JL, :))

! Compute real gradient

    ZGRADX_ (JL, 1) = - SIN (ZLATLON (JL, 2)) * (+ COS (ZLATLON (JL, 1)))
    ZGRADY_ (JL, 1) = + COS (ZLATLON (JL, 2)) * (- SIN (ZLATLON (JL, 1)))

    ZGRADX_ (JL, 2) = + COS (ZLATLON (JL, 2)) * (+ COS (ZLATLON (JL, 1)))
    ZGRADY_ (JL, 2) = + SIN (ZLATLON (JL, 2)) * (- SIN (ZLATLON (JL, 1)))

    ZGRADX_ (JL, 3) =                           (  0._JPRB              )
    ZGRADY_ (JL, 3) =                           (+ COS (ZLATLON (JL, 1)))

! Rotate gradient

!   ZGRADX_ (JL, :) = ROT (ZROTXYZ, ZGRADX_ (JL, :))
!   ZGRADY_ (JL, :) = ROT (ZROTXYZ, ZGRADY_ (JL, :))

  ENDDO

  CALL DO_HALO (YLHALO, YDDIST, ZCOORDYX)
  CALL DO_HALO (YLHALO, YDDIST, ZGP)
 
! Compute real gradient

  CALL GET_MY_FACTOR (YDGRID, YDDIST, ZFACTOR)
  CALL DO_GRADIENT (YLHALO, YDDIST, YDGRID, ZCOORDYX, ZGP, ZGRADX, ZGRADY, PFACTOR=ZFACTOR)

  CALL GMSH (ZGP      (:,1), IGPTOT, "X.msh",       YDGRID, YDDIST)
  CALL GMSH (ZGRADX_  (:,1), IGPTOT, "dXdlon_.msh", YDGRID, YDDIST)
  CALL GMSH (ZGRADY_  (:,1), IGPTOT, "dXdlat_.msh", YDGRID, YDDIST)
  CALL GMSH (ZGRADX   (:,1), IGPTOT, "dXdlon.msh",  YDGRID, YDDIST)
  CALL GMSH (ZGRADY   (:,1), IGPTOT, "dXdlat.msh",  YDGRID, YDDIST)

  CALL GMSH (ZGP      (:,2), IGPTOT, "Y.msh",       YDGRID, YDDIST)
  CALL GMSH (ZGRADX_  (:,2), IGPTOT, "dYdlon_.msh", YDGRID, YDDIST)
  CALL GMSH (ZGRADY_  (:,2), IGPTOT, "dYdlat_.msh", YDGRID, YDDIST)
  CALL GMSH (ZGRADX   (:,2), IGPTOT, "dYdlon.msh",  YDGRID, YDDIST)
  CALL GMSH (ZGRADY   (:,2), IGPTOT, "dYdlat.msh",  YDGRID, YDDIST)

  CALL GMSH (ZGP      (:,3), IGPTOT, "Z.msh",       YDGRID, YDDIST)
  CALL GMSH (ZGRADX_  (:,3), IGPTOT, "dZdlon_.msh", YDGRID, YDDIST)
  CALL GMSH (ZGRADY_  (:,3), IGPTOT, "dZdlat_.msh", YDGRID, YDDIST)
  CALL GMSH (ZGRADX   (:,3), IGPTOT, "dZdlon.msh",  YDGRID, YDDIST)
  CALL GMSH (ZGRADY   (:,3), IGPTOT, "dZdlat.msh",  YDGRID, YDDIST)

  CALL WFA (ZFACTOR, IGPTOT, 1_JPIM, "GRADIENT.fa", ["SURF"], [0], ["FACTOR"], YDGRID, YDDIST)
  
  CALL WFA (ZGP (1:YLHALO%ISIZE,1:3), IGPTOT, 3_JPIM, "GRADIENT.fa", ["SURF", "SURF", "SURF"], &
          & [0, 0, 0], ["X", "Y", "Z"], YDGRID, YDDIST)
  
  CALL WFA (ZGRADX_, IGPTOT, 3_JPIM, "GRADIENT.fa", ["SURF", "SURF", "SURF"], &
          & [0, 0, 0], ["dXdlon_", "dYdlon_", "dZdlon_"], YDGRID, YDDIST)
  
  CALL WFA (ZGRADY_, IGPTOT, 3_JPIM, "GRADIENT.fa", ["SURF", "SURF", "SURF"], &
          & [0, 0, 0], ["dXdlat_", "dYdlat_", "dZdlat_"], YDGRID, YDDIST)

  CALL WFA (ZGRADX (1:YLHALO%ISIZE,1:3), IGPTOT, 3_JPIM, "GRADIENT.fa", ["SURF", "SURF", "SURF"], &
          & [0, 0, 0], ["dXdlon", "dYdlon", "dZdlon"], YDGRID, YDDIST)
  
  CALL WFA (ZGRADY (1:YLHALO%ISIZE,1:3), IGPTOT, 3_JPIM, "GRADIENT.fa", ["SURF", "SURF", "SURF"], &
          & [0, 0, 0], ["dXdlat", "dYdlat", "dZdlat"], YDGRID, YDDIST)

ENDBLOCK

CONTAINS

REAL (KIND=JPRB) FUNCTION ROT (PROT, PXYZ)

DIMENSION :: ROT (3)
REAL (KIND=JPRB), INTENT (IN) :: PROT (3, 3), PXYZ (3)

ROT (1) = SUM (PROT (1, 1:3) * PXYZ (1:3))
ROT (2) = SUM (PROT (2, 1:3) * PXYZ (1:3))
ROT (3) = SUM (PROT (3, 1:3) * PXYZ (1:3))

END FUNCTION

END SUBROUTINE

SUBROUTINE DO_HALFDIFF (YDHALO, YDDIST, YDGRID, PLATLON, PGP, &
                      & PDIFFXP, PDIFFXM, PDIFFYP, PDIFFYM,   &
                      & PDXP,    PDXM,    PDYP,    PDYM,      &
                      & PUNDEF, LDUNDEF, PFACTOR)

USE MPL_MODULE,        ONLY : MPL_MYRANK, MPL_NUMPROC

TYPE (HALO_t),    INTENT (IN)     :: YDHALO
TYPE (DIST_t),    INTENT (IN)     :: YDDIST
TYPE (GRID_t),    INTENT (IN)     :: YDGRID
REAL (KIND=JPRB), INTENT (IN)     :: PLATLON (:,:) ! Latlon over halo
REAL (KIND=JPRB), INTENT (IN)     :: PGP (:,:)
REAL (KIND=JPRB), INTENT (OUT)    :: PDIFFXP (:,:)
REAL (KIND=JPRB), INTENT (OUT)    :: PDIFFXM (:,:)
REAL (KIND=JPRB), INTENT (OUT)    :: PDIFFYP (:,:)
REAL (KIND=JPRB), INTENT (OUT)    :: PDIFFYM (:,:)
REAL (KIND=JPRB), INTENT (OUT)    :: PDXP    (:,:)
REAL (KIND=JPRB), INTENT (OUT)    :: PDXM    (:,:)
REAL (KIND=JPRB), INTENT (OUT)    :: PDYP    (:,:)
REAL (KIND=JPRB), INTENT (OUT)    :: PDYM    (:,:)
REAL (KIND=JPRB), INTENT (IN), OPTIONAL :: PUNDEF (:)
LOGICAL,          INTENT (IN), OPTIONAL :: LDUNDEF (:)
REAL (KIND=JPRB), INTENT (IN), OPTIONAL :: PFACTOR (:)


INTEGER (KIND=JPIM) :: IGPTOT, MYPROC
INTEGER (KIND=JPIM) :: JL, JFLD, INFLD, JLAT
INTEGER (KIND=JPIM) :: I_W, I_E, IN_, IS_, INE, ISE, INW, ISW
REAL (KIND=JPRB) :: Z_W, Z_E, ZN_, ZS_
REAL (KIND=JPRB) :: ZLON_W, ZLON_E, ZLONNW, ZLONNE
REAL (KIND=JPRB) :: ZLONSW, ZLONSE, ZLATN_, ZLATS_
REAL (KIND=JPRB) :: ZVAL
REAL (KIND=JPRB), ALLOCATABLE :: ZLAT (:), ZCOSLAT (:)
REAL (KIND=JPRB) :: ZLON, ZTMP, ZUNDEF
LOGICAL :: LLUNDEF (SIZE (PGP, 2))
REAL (KIND=JPRB) :: ZNW, ZNE, ZSW, ZSE

REAL(KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK ('DO_HALFDIFF',0,ZHOOK_HANDLE)

MYPROC   = MPL_MYRANK ()
IGPTOT   = YDDIST%NGPTOTL (MYPROC)
INFLD    = SIZE (PGP, 2)

ALLOCATE (ZLAT (YDGRID%NDGLG), ZCOSLAT (YDGRID%NDGLG))
ZLAT = [(ASIN (YDGRID%RMU (JLAT)), JLAT = 1, YDGRID%NDGLG)]
ZCOSLAT = COS (ZLAT)

IF (PRESENT (LDUNDEF) .AND. PRESENT (PUNDEF)) THEN
  LLUNDEF = LDUNDEF
ELSE
  LLUNDEF = PRESENT (PUNDEF)
ENDIF
 
!$OMP PARALLEL DO PRIVATE &
!$OMP & (JL, JFLD, I_W, I_E, IN_, IS_, INE, ISE, INW, ISW, ZLON, ZTMP, ZUNDEF, &
!$OMP &  ZLON_W, ZLON_E, ZLONNW, ZLONNE, ZLONSW, ZLONSE, ZLATN_, ZLATS_, &
!$OMP &  ZNW, ZNE, ZSW, ZSE, Z_W, Z_E, ZN_, ZS_, ZVAL) COLLAPSE (2)
DO JFLD = 1, INFLD
  DO JL = 1, IGPTOT

    IF (LLUNDEF (JFLD)) THEN
      ZUNDEF = PUNDEF (JFLD)
    ELSE
      ZUNDEF = HUGE (ZUNDEF)
    ENDIF
    
    IF (PGP (JL, JFLD) == ZUNDEF) THEN
      PDIFFXP (JL,JFLD) = ZUNDEF; PDXP (JL, JFLD) = ZUNDEF
      PDIFFXM (JL,JFLD) = ZUNDEF; PDXM (JL, JFLD) = ZUNDEF
      PDIFFYP (JL,JFLD) = ZUNDEF; PDYP (JL, JFLD) = ZUNDEF
      PDIFFYM (JL,JFLD) = ZUNDEF; PDYM (JL, JFLD) = ZUNDEF
      GOTO 888
    ELSE
      PDIFFXP (JL,JFLD) = 0._JPRB; PDXP (JL, JFLD) = 1._JPRB
      PDIFFXM (JL,JFLD) = 0._JPRB; PDXM (JL, JFLD) = 1._JPRB
      PDIFFYP (JL,JFLD) = 0._JPRB; PDYP (JL, JFLD) = 1._JPRB
      PDIFFYM (JL,JFLD) = 0._JPRB; PDYM (JL, JFLD) = 1._JPRB
    ENDIF

    I_W = YDHALO%JNEIGHBOURS (JIDX__W, JL)
    I_E = YDHALO%JNEIGHBOURS (JIDX__E, JL)
    IN_ = YDHALO%JNEIGHBOURS (JIDX_N_, JL)
    IS_ = YDHALO%JNEIGHBOURS (JIDX_S_, JL)
    INE = YDHALO%JNEIGHBOURS (JIDX_NE, JL)
    ISE = YDHALO%JNEIGHBOURS (JIDX_SE, JL)
    INW = YDHALO%JNEIGHBOURS (JIDX_NW, JL)
    ISW = YDHALO%JNEIGHBOURS (JIDX_SW, JL)

    JLAT   = YDHALO%JLAT (JL)
    ZLON   = PLATLON (JL,  2)
    ZVAL   = PGP (JL, JFLD)

! X direction
    Z_W    = PGP (I_W, JFLD)
    ZLON_W = PLATLON (I_W, 2)

    Z_E    = PGP (I_E, JFLD)
    ZLON_E = PLATLON (I_E, 2)

    IF (Z_E /= ZUNDEF) THEN
      PDIFFXP (JL,JFLD) = (Z_E - ZVAL)
      PDXP (JL, JFLD) = (RA * MODULO (ZLON_E - ZLON, R2PI) * ZCOSLAT (JLAT)) 
      IF (PRESENT (PFACTOR)) PDXP (JL, JFLD) = PDXP (JL, JFLD) / PFACTOR (JL)
    ENDIF

    IF (Z_W /= ZUNDEF) THEN
      PDIFFXM (JL,JFLD) = (ZVAL - Z_W) 
      PDXM (JL, JFLD) = (RA * MODULO (ZLON - ZLON_W, R2PI) * ZCOSLAT (JLAT))
      IF (PRESENT (PFACTOR)) PDXM (JL, JFLD) = PDXM (JL, JFLD) / PFACTOR (JL)
    ENDIF

! Y direction


! Calculate value at the north
    ZN_ = ZUNDEF
    IF (IN_ > 0) THEN                 ! We have a point at the north
      ZN_ = PGP (IN_, JFLD)
    ENDIF

    IF (ZN_ == ZUNDEF) THEN
      ZLONNW = PLATLON (INW, 2)
      ZLONNE = PLATLON (INE, 2)
      IF (JLAT == 1) THEN ! Cross North pole; interpolate at ZLON + RPI
        ZLON = ZLON + RPI
        ZTMP = ZLONNW; ZLONNW = ZLONNE; ZLONNE = ZTMP
      ENDIF
      ZNW = PGP (INW, JFLD); ZNE = PGP (INE, JFLD)
      IF (ZNW /= ZUNDEF .AND. ZNE /= ZUNDEF) THEN
        ZN_ = (MODULO (ZLONNE-ZLON, R2PI) * ZNW + MODULO (ZLON-ZLONNW, R2PI) * ZNE) &
           & / MODULO (ZLONNE-ZLONNW, R2PI)
      ELSEIF (ZNW /= ZUNDEF) THEN
        ZN_ = ZNW
      ELSEIF (ZNE /= ZUNDEF) THEN
        ZN_ = ZNE
      ENDIF
    ENDIF
 
    ZS_ = ZUNDEF
    IF (IS_ > 0) THEN                            ! We have a point at the south
      ZS_ = PGP (IS_, JFLD)
    ENDIF

! Calculate value at the south

    IF (ZS_ == ZUNDEF) THEN
      ZLONSW = PLATLON (ISW, 2)
      ZLONSE = PLATLON (ISE, 2)
      IF (JLAT == YDGRID%NDGLG) THEN ! Cross South pole
        ZLON = ZLON + RPI
        ZTMP = ZLONSW; ZLONSW = ZLONSE; ZLONSE = ZTMP
      ENDIF
      ZSW = PGP (ISW, JFLD); ZSE = PGP (ISE, JFLD)
      IF (ZSW /= ZUNDEF .AND. ZSE /= ZUNDEF) THEN
        ZS_ = (MODULO (ZLONSE-ZLON, R2PI) * ZSW + MODULO (ZLON-ZLONSW, R2PI) * ZSE) &
           & / MODULO (ZLONSE-ZLONSW, R2PI)
      ELSEIF (ZSW /= ZUNDEF) THEN
        ZS_ = ZSW
      ELSEIF (ZSE /= ZUNDEF) THEN
        ZS_ = ZSE
      ENDIF
    ENDIF

    IF (JLAT == 1) THEN ! Cross North pole
      ZLATN_ = + RPI - ZLAT (JLAT)
    ELSE
      ZLATN_ = ZLAT (JLAT-1)
    ENDIF
    
    IF (JLAT == YDGRID%NDGLG) THEN ! Cross South pole
      ZLATS_ = - RPI - ZLAT (JLAT)
    ELSE
      ZLATS_ = ZLAT (JLAT+1)
    ENDIF

    IF (ZN_ /= ZUNDEF) THEN
      PDIFFYP (JL,JFLD) = (ZN_ - ZVAL) 
      PDYP (JL, JFLD) = (RA * MODULO (ZLATN_ - ZLAT (JLAT), R2PI)) 
      IF (PRESENT (PFACTOR)) PDYP (JL, JFLD) = PDYP (JL, JFLD) / PFACTOR (JL)
    ENDIF

    IF (ZS_ /= ZUNDEF) THEN
      PDIFFYM (JL,JFLD) = (ZVAL - ZS_) 
      PDYM (JL, JFLD) = (RA * MODULO (ZLAT (JLAT) - ZLATS_, R2PI)) 
      IF (PRESENT (PFACTOR)) PDYM (JL, JFLD) = PDYM (JL, JFLD) / PFACTOR (JL)
    ENDIF

888 CONTINUE

  ENDDO
ENDDO
!$OMP END PARALLEL DO

  
IF (LHOOK) CALL DR_HOOK ('DO_HALFDIFF',1,ZHOOK_HANDLE)

END SUBROUTINE DO_HALFDIFF


SUBROUTINE DO_GRADIENT (YDHALO, YDDIST, YDGRID, PCOORDYX, PGP, PGRADX, PGRADY, &
                      & PUNDEF, LDUNDEF, PFACTOR)

USE MPL_MODULE,        ONLY : MPL_MYRANK, MPL_NUMPROC

TYPE (HALO_t),    INTENT (IN)     :: YDHALO
TYPE (DIST_t),    INTENT (IN)     :: YDDIST
TYPE (GRID_t),    INTENT (IN)     :: YDGRID
REAL (KIND=JPRB), INTENT (IN)     :: PCOORDYX (:,:) ! Latlon over halo
REAL (KIND=JPRB), INTENT (IN)     :: PGP (:,:)
REAL (KIND=JPRB), INTENT (OUT)    :: PGRADX (:,:)
REAL (KIND=JPRB), INTENT (OUT)    :: PGRADY (:,:)
REAL (KIND=JPRB), INTENT (IN), OPTIONAL :: PUNDEF (:)
LOGICAL,          INTENT (IN), OPTIONAL :: LDUNDEF (:)
REAL (KIND=JPRB), INTENT (IN), OPTIONAL :: PFACTOR (:)


INTEGER (KIND=JPIM) :: IGPTOT, MYPROC
INTEGER (KIND=JPIM) :: JL, JFLD, INFLD, JLAT
INTEGER (KIND=JPIM) :: I_W, I_E, IN_, IS_, INE, ISE, INW, ISW
REAL (KIND=JPRB) :: Z_W, Z_E, ZN_, ZS_
REAL (KIND=JPRB) :: ZLON_W, ZLON_E, ZLONNW, ZLONNE
REAL (KIND=JPRB) :: ZLONSW, ZLONSE, ZLATN_, ZLATS_
REAL (KIND=JPRB), ALLOCATABLE :: ZLAT (:), ZCOSLAT (:)
REAL (KIND=JPRB) :: ZLON, ZTMP, ZUNDEF
LOGICAL :: LLUNDEF (SIZE (PGP, 2))
REAL (KIND=JPRB) :: ZNW, ZNE, ZSW, ZSE

REAL(KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK ('DO_GRADIENT',0,ZHOOK_HANDLE)

MYPROC   = MPL_MYRANK ()
IGPTOT   = YDDIST%NGPTOTL (MYPROC)
INFLD    = SIZE (PGP, 2)

ALLOCATE (ZLAT (YDGRID%NDGLG), ZCOSLAT (YDGRID%NDGLG))
ZLAT = [(ASIN (YDGRID%RMU (JLAT)), JLAT = 1, YDGRID%NDGLG)]
ZCOSLAT = COS (ZLAT)

IF (PRESENT (LDUNDEF) .AND. PRESENT (PUNDEF)) THEN
  LLUNDEF = LDUNDEF
ELSE
  LLUNDEF = PRESENT (PUNDEF)
ENDIF
 

!$OMP PARALLEL DO PRIVATE &
!$OMP& (JL, JFLD, I_W, I_E, IN_, IS_, INE, ISE, INW, ISW, ZLON, ZTMP, ZUNDEF, &
!$OMP&  ZLON_W, ZLON_E, ZLONNW, ZLONNE, ZLONSW, ZLONSE, ZLATN_, ZLATS_, &
!$OMP&  ZNW, ZNE, ZSW, ZSE, Z_W, Z_E, ZN_, ZS_) &
!$OMP& COLLAPSE (2)
DO JFLD = 1, INFLD
  DO JL = 1, IGPTOT

    IF (LLUNDEF (JFLD)) THEN
      ZUNDEF = PUNDEF (JFLD)
    ELSE
      ZUNDEF = HUGE (ZUNDEF)
    ENDIF
    
    IF (PGP (JL, JFLD) == ZUNDEF) THEN
      PGRADX (JL,JFLD) = ZUNDEF
      PGRADY (JL,JFLD) = ZUNDEF
      GOTO 888
    ENDIF

    I_W = YDHALO%JNEIGHBOURS (JIDX__W, JL)
    I_E = YDHALO%JNEIGHBOURS (JIDX__E, JL)
    IN_ = YDHALO%JNEIGHBOURS (JIDX_N_, JL)
    IS_ = YDHALO%JNEIGHBOURS (JIDX_S_, JL)
    INE = YDHALO%JNEIGHBOURS (JIDX_NE, JL)
    ISE = YDHALO%JNEIGHBOURS (JIDX_SE, JL)
    INW = YDHALO%JNEIGHBOURS (JIDX_NW, JL)
    ISW = YDHALO%JNEIGHBOURS (JIDX_SW, JL)

    JLAT   = YDHALO%JLAT (JL)
    ZLON   = PCOORDYX (JL,  2)

! X direction
    Z_W    = PGP (I_W, JFLD)
    ZLON_W = PCOORDYX (I_W, 2)

    Z_E    = PGP (I_E, JFLD)
    ZLON_E = PCOORDYX (I_E, 2)

    IF (Z_E == ZUNDEF) THEN
      Z_E    = PGP (JL, JFLD)
      ZLON_E = ZLON
    ENDIF
    IF (Z_W == ZUNDEF) THEN
      Z_W    = PGP (JL, JFLD)
      ZLON_W = ZLON
    ENDIF

    IF (ZLON_W /= ZLON_E) THEN
      PGRADX (JL,JFLD) = (Z_E - Z_W) / (RA * MODULO (ZLON_E - ZLON_W, R2PI) * ZCOSLAT (JLAT)) ! This is dx
      IF (PRESENT (PFACTOR)) PGRADX (JL,JFLD) = PGRADX (JL,JFLD) * PFACTOR (JL)
    ELSE
      PGRADX (JL,JFLD) = 0._JPRB
    ENDIF

! Y direction


! Calculate value at the north
    ZN_ = ZUNDEF
    IF (IN_ > 0) THEN                 ! We have a point at the north
      ZN_ = PGP (IN_, JFLD)
    ENDIF

    IF (ZN_ == ZUNDEF) THEN
      ZLONNW = PCOORDYX (INW, 2)
      ZLONNE = PCOORDYX (INE, 2)
      IF (JLAT == 1) THEN ! Cross North pole; interpolate at ZLON + RPI
        ZLON = ZLON + RPI
        ZTMP = ZLONNW; ZLONNW = ZLONNE; ZLONNE = ZTMP
      ENDIF
      ZNW = PGP (INW, JFLD); ZNE = PGP (INE, JFLD)
      IF (ZNW /= ZUNDEF .AND. ZNE /= ZUNDEF) THEN
        ZN_ = (MODULO (ZLONNE-ZLON, R2PI) * ZNW + MODULO (ZLON-ZLONNW, R2PI) * ZNE) &
           & / MODULO (ZLONNE-ZLONNW, R2PI)
      ELSEIF (ZNW /= ZUNDEF) THEN
        ZN_ = ZNW
      ELSEIF (ZNE /= ZUNDEF) THEN
        ZN_ = ZNE
      ENDIF
    ENDIF
 
    ZS_ = ZUNDEF
    IF (IS_ > 0) THEN                            ! We have a point at the south
      ZS_ = PGP (IS_, JFLD)
    ENDIF

! Calculate value at the south

    IF (ZS_ == ZUNDEF) THEN
      ZLONSW = PCOORDYX (ISW, 2)
      ZLONSE = PCOORDYX (ISE, 2)
      IF (JLAT == YDGRID%NDGLG) THEN ! Cross South pole
        ZLON = ZLON + RPI
        ZTMP = ZLONSW; ZLONSW = ZLONSE; ZLONSE = ZTMP
      ENDIF
      ZSW = PGP (ISW, JFLD); ZSE = PGP (ISE, JFLD)
      IF (ZSW /= ZUNDEF .AND. ZSE /= ZUNDEF) THEN
        ZS_ = (MODULO (ZLONSE-ZLON, R2PI) * ZSW + MODULO (ZLON-ZLONSW, R2PI) * ZSE) &
           & / MODULO (ZLONSE-ZLONSW, R2PI)
      ELSEIF (ZSW /= ZUNDEF) THEN
        ZS_ = ZSW
      ELSEIF (ZSE /= ZUNDEF) THEN
        ZS_ = ZSE
      ENDIF
    ENDIF

    IF (JLAT == 1) THEN ! Cross North pole
      ZLATN_ = + RPI - ZLAT (JLAT)
    ELSE
      ZLATN_ = ZLAT (JLAT-1)
    ENDIF
    
    IF (JLAT == YDGRID%NDGLG) THEN ! Cross South pole
      ZLATS_ = - RPI - ZLAT (JLAT)
    ELSE
      ZLATS_ = ZLAT (JLAT+1)
    ENDIF

    IF (ZN_ == ZUNDEF) THEN
      ZN_    = PGP (JL, JFLD)
      ZLATN_ = PCOORDYX (JL,  1)
    ENDIF
    IF (ZS_ == ZUNDEF) THEN
      ZS_    = PGP (JL, JFLD)
      ZLATS_ = PCOORDYX (JL,  1)
    ENDIF

    IF (ZLATN_ /= ZLATS_) THEN
      PGRADY (JL,JFLD) = (ZN_ - ZS_) / (RA * MODULO (ZLATN_ - ZLATS_, R2PI)) ! This is dy
      IF (PRESENT (PFACTOR)) PGRADY (JL,JFLD) = PGRADY (JL,JFLD) * PFACTOR (JL)
    ELSE 
      PGRADY (JL,JFLD) = 0._JPRB
    ENDIF

888 CONTINUE

  ENDDO
ENDDO
!$OMP END PARALLEL DO
  
IF (LHOOK) CALL DR_HOOK ('DO_GRADIENT',1,ZHOOK_HANDLE)

END SUBROUTINE


SUBROUTINE DEMO_SHUFFLE (YDDIST1,dDist, YDGRID1,dGrid, YDDIST2,eDist, YDGRID2,eGrid, LDPRINT)

USE MPL_MODULE,        ONLY : MPL_MYRANK, MPL_NUMPROC
USE atlas_module
!USE atlas_module  , ONLY:atlas_griddistribution,atlas_structuredgrid,atlas_reducedgaussiangrid,atlas_structuredgrid

TYPE (DIST_t),    INTENT (IN)  :: YDDIST1, YDDIST2
TYPE (GRID_t),    INTENT (IN)  :: YDGRID1, YDGRID2
LOGICAL,          INTENT (IN)  :: LDPRINT

type(atlas_structuredgrid):: dGrid
type(atlas_griddistribution):: dDist
type(atlas_structuredgrid):: eGrid
type(atlas_griddistribution):: eDist
type (SHUFFLE_t) :: ylshflatlas


TYPE (SHUFFLE_t) :: YLSHFL
INTEGER (KIND=JPIM) :: IGPTOT1, IGPTOT2, ISUMRECV, MYPROC
LOGICAL :: LLTESTGLOBAL, LLTESTINTERPXYZ
REAL(KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK ('DEMO_SHUFFLE',0,ZHOOK_HANDLE)

LLTESTGLOBAL = .TRUE.
LLTESTINTERPXYZ = .TRUE.


CALL CREATE_SHUFFLE (YDDIST1,dDist, YDGRID1,dGrid, YDDIST2,eDist, YDGRID2,eGrid, YLSHFL,ylshflatlas)

MYPROC   = MPL_MYRANK ()
IGPTOT1  = YDDIST1%NGPTOTL (MYPROC)
IGPTOT2  = YDDIST2%NGPTOTL (MYPROC)
ISUMRECV = SUM (YLSHFL%YL_RECV%ISIZE)

IF (LLTESTGLOBAL) THEN
  BLOCK 
    REAL (KIND=JPRB) :: ZLATLONGLOBAL1 (IGPTOT1, 3), ZLATLON2 (IGPTOT2, 2), ZLATLONGLOBAL2E (ISUMRECV, 3)
    INTEGER (KIND=JPIM) :: JGLOBAL1 (IGPTOT1), IOFF, ICNT, II, JLOC2

    CALL GET_MY_LATLON (YDGRID1, YDDIST1, ZLATLONGLOBAL1)
    CALL GET_MY_LATLON (YDGRID2, YDDIST2, ZLATLON2)
    CALL GET_MY_GLOBAL (YDGRID1, YDDIST1, JGLOBAL1)
    ZLATLONGLOBAL1 (:,3) = REAL (JGLOBAL1, JPRB)
   
    CALL DO_SHUFFLE (YDDIST1, YDGRID1, YDDIST2, YDGRID2, YLSHFL, ZLATLONGLOBAL1, ZLATLONGLOBAL2E)
   
    IF (LDPRINT) THEN
    
      DO JLOC2 = 1, IGPTOT2
      
        WRITE (0, '(" JLOC2 = ",I6," ",2F12.4)') JLOC2, RAD2DEG * ZLATLON2 (JLOC2, 1:2)
      
        IOFF = YLSHFL%ILOCAL_OFF (JLOC2)
        ICNT = YLSHFL%ILOCAL_CNT (JLOC2)
      
        DO II = IOFF+1, IOFF+ICNT
           WRITE (0, '(15X," ",2F12.4," ",I6)') &
            & RAD2DEG * ZLATLONGLOBAL2E (II, 1), RAD2DEG * ZLATLONGLOBAL2E (II, 2), INT (ZLATLONGLOBAL2E (II, 3))
        ENDDO
        
        WRITE (0, *)
      
        WRITE (0, '(15X," ",2F12.4)') &
           & RAD2DEG * SUM (ZLATLONGLOBAL2E (IOFF+1:IOFF+ICNT, 1)) / ICNT, &
           & RAD2DEG * SUM (ZLATLONGLOBAL2E (IOFF+1:IOFF+ICNT, 2)) / ICNT
      
        WRITE (0, *)
        WRITE (0, *)
      
      ENDDO
    
    ENDIF

  ENDBLOCK

ENDIF

IF (LLTESTINTERPXYZ) THEN

  BLOCK
    USE MPL_ALLREDUCE_MOD, ONLY : MPL_ALLREDUCE

    REAL (KIND=JPRB) :: ZXYZ1 (IGPTOT1, 3), ZXYZ2 (IGPTOT2, 3), ZXYZ2E (ISUMRECV, 3)
    REAL (KIND=JPRB) :: ZXYZ2I (IGPTOT2, 3)
    REAL (KIND=JPRB) :: ZDISTMAX
    INTEGER (KIND=JPIM) :: IOFF, ICNT, II, JLOC2, JFLD

    CALL GET_MY_XYZ (YDGRID1, YDDIST1, ZXYZ1)
    CALL GET_MY_XYZ (YDGRID2, YDDIST2, ZXYZ2)
   
    IF (LDPRINT) THEN
      CALL GMSH (ZXYZ1 (:,1), IGPTOT1, "x1.msh", YDGRID1, YDDIST1)
      CALL GMSH (ZXYZ1 (:,2), IGPTOT1, "y1.msh", YDGRID1, YDDIST1)
      CALL GMSH (ZXYZ1 (:,3), IGPTOT1, "z1.msh", YDGRID1, YDDIST1)
      CALL WFA (ZXYZ1, IGPTOT1, 3_JPIM, "ZXYZ1.fa", ["SURF", "SURF", "SURF"], &
              & [0, 0, 0], ["X", "Y", "Z"], YDGRID1, YDDIST1)
    ENDIF
    
    CALL DO_SHUFFLE (YDDIST1, YDGRID1, YDDIST2, YDGRID2, YLSHFL, ZXYZ1, ZXYZ2E)
    
!$OMP PARALLEL DO PRIVATE (JFLD, JLOC2, II, IOFF, ICNT) COLLAPSE (2)
    DO JFLD = 1, 3
      DO JLOC2 = 1, IGPTOT2
    
        IOFF = YLSHFL%ILOCAL_OFF (JLOC2)
        ICNT = YLSHFL%ILOCAL_CNT (JLOC2)
       
        ZXYZ2I (JLOC2, JFLD) = 0._JPRB
    
        DO II = IOFF+1, IOFF+ICNT
           ZXYZ2I (JLOC2, JFLD) = ZXYZ2I (JLOC2, JFLD) + ZXYZ2E (II, JFLD)
        ENDDO
    
        ZXYZ2I (JLOC2, JFLD) = ZXYZ2I (JLOC2, JFLD) / REAL (ICNT, JPRB)
      
      ENDDO
    ENDDO
!$OMP END PARALLEL DO
  
    IF (LDPRINT) THEN
      CALL GMSH (ZXYZ2I (:,1), IGPTOT2, "x2.msh", YDGRID2, YDDIST2)
      CALL GMSH (ZXYZ2I (:,2), IGPTOT2, "y2.msh", YDGRID2, YDDIST2)
      CALL GMSH (ZXYZ2I (:,3), IGPTOT2, "z2.msh", YDGRID2, YDDIST2)
      CALL WFA (ZXYZ2I, IGPTOT2, 3_JPIM, "ZXYZ2I.fa", ["SURF", "SURF", "SURF"], &
              & [0, 0, 0], ["X", "Y", "Z"], YDGRID2, YDDIST2)
    ENDIF
   
    ZDISTMAX = 0._JPRB
!$OMP PARALLEL DO REDUCTION (MAX: ZDISTMAX)
    DO JLOC2 = 1, IGPTOT2
      ZDISTMAX = MAX (ZDISTMAX, SQRT (SUM ((ZXYZ2I (JLOC2, 1:3) - ZXYZ2 (JLOC2, 1:3))**2)))
    ENDDO
!$OMP END PARALLEL DO

   CALL MPL_ALLREDUCE (ZDISTMAX, 'MAX', CDSTRING='DEMO_SHUFFLE')

   IF (MYPROC == 1) THEN
     WRITE (0, *) " ZDISTMAX = ", ZDISTMAX
   ENDIF


  ENDBLOCK

ENDIF

IF (LHOOK) CALL DR_HOOK ('DEMO_SHUFFLE',1,ZHOOK_HANDLE)

END SUBROUTINE 


SUBROUTINE DO_SHUFFLE (YDDIST1, YDGRID1, YDDIST2, YDGRID2, YDSHFL, PGP1, PGP2E)

USE MPL_MODULE,        ONLY : MPL_MYRANK, MPL_NUMPROC
USE MPL_SEND_MOD,      ONLY : MPL_SEND
USE MPL_RECV_MOD,      ONLY : MPL_RECV
USE MPL_WAIT_MOD,      ONLY : MPL_WAIT
USE MPL_WAITANY_MOD,   ONLY : MPL_WAITANY
USE MPL_BARRIER_MOD,   ONLY : MPL_BARRIER
USE MPL_DATA_MODULE,   ONLY : JP_NON_BLOCKING_STANDARD
USE MPL_MODULE,        ONLY : MPL_COMM_OML
USE MPL_MPIF,          ONLY : MPI_REQUEST_NULL, MPI_UNDEFINED

TYPE (DIST_t),    INTENT (IN)  :: YDDIST1, YDDIST2
TYPE (GRID_t),    INTENT (IN)  :: YDGRID1, YDGRID2
TYPE (SHUFFLE_t), INTENT (IN)  :: YDSHFL
REAL (KIND=JPRB), INTENT (IN)  :: PGP1 (:,:)
REAL (KIND=JPRB), INTENT (OUT) :: PGP2E (:,:)

REAL (KIND=JPRB) :: ZBUFR (SUM (YDSHFL%YL_RECV%ISIZE) * SIZE (PGP1, 2))
REAL (KIND=JPRB) :: ZBUFS (SUM (YDSHFL%YL_SEND%ISIZE) * SIZE (PGP1, 2))
INTEGER (KIND=JPIM) :: IREQR (SIZE (YDSHFL%YL_RECV)), IREQS (SIZE (YDSHFL%YL_SEND))
INTEGER (KIND=JPIM) :: IOFFS_ALL (SIZE (YDSHFL%YL_SEND)), IOFFR_ALL (SIZE (YDSHFL%YL_RECV))
INTEGER (KIND=JPIM) :: IOFFR, IOFFS
INTEGER (KIND=JPIM) :: INRECV, INSEND, IPROC, MYPROC
INTEGER (KIND=JPIM) :: INFLD, ISIZE, II, JJ, JFLD, ICOMM
REAL(KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK ('DO_SHUFFLE',0,ZHOOK_HANDLE)

MYPROC = MPL_MYRANK ()
INRECV = SIZE (YDSHFL%YL_RECV)
INSEND = SIZE (YDSHFL%YL_SEND)
INFLD  = SIZE (PGP1, 2)
ICOMM  = MPL_COMM_OML (1)
IREQR  = MPI_REQUEST_NULL
IREQS  = MPI_REQUEST_NULL

IOFFR = 0
DO II = 1, INRECV

  IPROC = YDSHFL%YL_RECV (II)%IPROC
  ISIZE = YDSHFL%YL_RECV (II)%ISIZE

  CALL MPL_RECV (PBUF=ZBUFR (IOFFR+1:IOFFR+INFLD*ISIZE), KSOURCE=IPROC,   &
               & KMP_TYPE=JP_NON_BLOCKING_STANDARD, KREQUEST=IREQR (II),  &
               & KTAG=101, CDSTRING='DO_SHUFFLE', KCOMM=ICOMM)

  IOFFR = IOFFR + INFLD * ISIZE
ENDDO


CALL MPL_BARRIER (CDSTRING='DO_SHUFFLE', KCOMM=ICOMM)

IOFFS = 0
DO II = 1, INSEND
  ISIZE = YDSHFL%YL_SEND (II)%ISIZE
  IOFFS_ALL (II) = IOFFS
  IOFFS = IOFFS + INFLD * ISIZE
ENDDO

DO II = 1, INSEND

  IOFFS = IOFFS_ALL (II)
  IPROC = YDSHFL%YL_SEND (II)%IPROC
  ISIZE = YDSHFL%YL_SEND (II)%ISIZE

!$OMP PARALLEL DO PRIVATE (JJ, JFLD) COLLAPSE (2)
  DO JFLD = 1, INFLD
    DO JJ = 1, ISIZE
      ZBUFS (IOFFS+(JFLD-1)*ISIZE+JJ) = PGP1 (YDSHFL%YL_SEND (II)%ILOCAL (JJ), JFLD)
    ENDDO
  ENDDO
!$OMP END PARALLEL DO

  CALL MPL_SEND (PBUF=ZBUFS (IOFFS+1:IOFFS+INFLD*ISIZE), KDEST=IPROC,     &
               & KMP_TYPE=JP_NON_BLOCKING_STANDARD, KREQUEST=IREQS (II),  &
               & KTAG=101, CDSTRING='DO_SHUFFLE', KCOMM=ICOMM)

ENDDO

IOFFR = 0
DO II = 1, INRECV
  IOFFR_ALL (II) = IOFFR
  ISIZE = YDSHFL%YL_RECV (II)%ISIZE
  IOFFR = IOFFR + ISIZE
ENDDO

DO
  CALL MPL_WAITANY (KREQUEST=IREQR, KINDEX=II, CDSTRING='DO_SHUFFLE')
  IF (II == MPI_UNDEFINED) EXIT

  IOFFR = IOFFR_ALL (II)
  ISIZE = YDSHFL%YL_RECV (II)%ISIZE

!$OMP PARALLEL DO PRIVATE (JJ, JFLD) COLLAPSE (2)
  DO JFLD = 1, INFLD
    DO JJ = 1, ISIZE
      PGP2E (YDSHFL%ISORT (IOFFR+JJ),JFLD) = ZBUFR (IOFFR*INFLD+(JFLD-1)*ISIZE+JJ)
    ENDDO
  ENDDO
!$OMP END PARALLEL DO

ENDDO

CALL MPL_WAIT (KREQUEST=IREQS, CDSTRING='DO_SHUFFLE')

IF (LHOOK) CALL DR_HOOK ('DO_SHUFFLE',1,ZHOOK_HANDLE)

END SUBROUTINE

SUBROUTINE CREATE_SHUFFLE (YDDIST1,dDist, YDGRID1,dGrid, YDDIST2,eDist, YDGRID2,eGrid, YDSHFL,ydshflatlas)

USE MPL_MPIF,          ONLY : MPI_REQUEST_NULL, MPI_UNDEFINED
USE MPL_DATA_MODULE,   ONLY : JP_NON_BLOCKING_STANDARD
USE MPL_MODULE,        ONLY : MPL_MYRANK, MPL_NUMPROC
USE MPL_ALLTOALLV_MOD, ONLY : MPL_ALLTOALLV
USE MPL_SEND_MOD,      ONLY : MPL_SEND
USE MPL_RECV_MOD,      ONLY : MPL_RECV
USE MPL_BARRIER_MOD,   ONLY : MPL_BARRIER
USE MPL_WAIT_MOD,      ONLY : MPL_WAIT

USE atlas_module  , ONLY : atlas_griddistribution,atlas_structuredgrid,atlas_reducedgaussiangrid,atlas_structuredgrid

TYPE (DIST_t),    INTENT (IN)  :: YDDIST1, YDDIST2
TYPE (GRID_t),    INTENT (IN)  :: YDGRID1, YDGRID2
TYPE (SHUFFLE_t), INTENT (OUT) :: YDSHFL

type(atlas_structuredgrid):: dGrid
type(atlas_griddistribution):: dDist
type(atlas_structuredgrid):: eGrid
type(atlas_griddistribution):: eDist
type (SHUFFLE_t), INTENT (OUT) :: ydshflatlas



TYPE RECV_t
  INTEGER (KIND=JPIM), ALLOCATABLE :: IALLX (:,:)
  INTEGER (KIND=JPIM), POINTER :: ILON2 (:), ILAT2 (:), IGLO1 (:)
END TYPE RECV_t

TYPE (RECV_t), ALLOCATABLE, TARGET :: YLRECV (:)
TYPE (REGION_t) :: YLMYREGION2
INTEGER (KIND=JPIM), ALLOCATABLE, TARGET :: IALLX (:,:)
INTEGER (KIND=JPIM), ALLOCATABLE :: IPRC2 (:), ILOC1 (:)
INTEGER (KIND=JPIM), POINTER :: ILON2 (:), ILAT2 (:), IGLO1 (:) 
INTEGER (KIND=JPIM), ALLOCATABLE :: ISENDCNT (:), IRECVCNT (:), ISENDOFF (:)
INTEGER (KIND=JPIM) :: IGPTO1, MYPROC, INPROC
INTEGER (KIND=JPIM) :: JLAT2, JLON2, JLOC1
INTEGER (KIND=JPIM) :: INLAT2, INLON2
INTEGER (KIND=JPIM) :: INSEND, INRECV, IPROC
REAL(KIND=JPRB) :: ZHOOK_HANDLE, ZHOOK_HANDLE_1, ZHOOK_HANDLE_2



INTEGER (KIND=JPIM) :: agpto1,anproc,anlat2

IF (LHOOK) CALL DR_HOOK ('CREATE_SHUFFLE',0,ZHOOK_HANDLE)

MYPROC = MPL_MYRANK ()

IGPTO1 = YDDIST1%NGPTOTL (MYPROC)
INLAT2 = YDGRID2%NDGLG
INPROC = YDDIST2%NPROC

!!HERRE

!anlat2=eGrid%ny()
!anproc=eDist%nb_partitions()


BLOCK
!  INTEGER (KIND=JPIM) :: jloop
!  DO jloop=1,anproc
!    write(*,*) dDist%nb_pts()[jloop];
!  ENDDO 

ENDBLOCK

IF (LHOOK) CALL DR_HOOK ('CREATE_SHUFFLE.1',0,ZHOOK_HANDLE_1)
BLOCK
  REAL (KIND=JPRB) :: ZLATLON1 (IGPTO1,2), ZLAT2 (0:INLAT2+1)
  REAL (KIND=JPRB) :: ZLON1, ZLAT1
  INTEGER (KIND=JPIM) :: JLAT2A, JLAT2M, JLAT2B, JA2, JB2
  REAL (KIND=JPRB) :: ZCOSLAT1, ZSINLAT1, ZCOSLON1, ZSINLON1, ZXYZ1 (3)

  ALLOCATE (IALLX (3,IGPTO1), IPRC2 (IGPTO1), ILOC1 (IGPTO1))
  ILON2 => IALLX (1, :); ILAT2 => IALLX (2, :); IGLO1 => IALLX (3, :)

! Unrotated/unstretched latitude if YDGRID1 is rotated/stretched; regular
! latitude otherwise
  ZLAT2 = [+RPI/2, (ASIN (YDGRID2%RMU (JLAT2)), JLAT2 = 1, INLAT2), -RPI/2]

  CALL GET_MY_GLOBAL (YDGRID1, YDDIST1, IGLO1)
  CALL GET_MY_LATLON (YDGRID1, YDDIST1, ZLATLON1)


! For all points of grid #1 (only in our region), we find the nearest point of grid #2. Here,
! "nearest" means nearest latitude and nearest longitude. We also find the task
! which holds this point of grid #2

!$OMP PARALLEL DO PRIVATE (JLOC1, ZLAT1, ZLON1, JLAT2A, JLAT2B, JLAT2M, JLAT2, INLON2, JLON2, JA2, JB2, &
!$OMP                    & ZCOSLAT1, ZSINLAT1, ZCOSLON1, ZSINLON1, ZXYZ1) 

  DO JLOC1 = 1, IGPTO1

    ZLAT1 = ZLATLON1 (JLOC1, 1)
    ZLON1 = ZLATLON1 (JLOC1, 2)

! Go back to unrotated lat/lon
    IF (YDGRID2%LROTATED .OR. YDGRID2%LSTRETCH) THEN
      ZCOSLAT1 = COS (ZLAT1); ZSINLAT1 = SIN (ZLAT1)
      ZCOSLON1 = COS (ZLON1); ZSINLON1 = SIN (ZLON1)
! Compute XYZ in unrotated frame
      ZXYZ1 (1) = ZCOSLON1 * ZCOSLAT1
      ZXYZ1 (2) = ZSINLON1 * ZCOSLAT1
      ZXYZ1 (3) =            ZSINLAT1
! Rotate back
      ZXYZ1 = MATMUL (YDGRID2%ZROTI, ZXYZ1)
      ZLAT1 = ASIN (ZXYZ1 (3))
      ZLON1 = MODULO (ATAN2 (ZXYZ1 (2), ZXYZ1 (1)), R2PI)
! Unstretch
      ZSINLAT1 = SIN (ZLAT1)
      ZLAT1 = ASIN ((-YDGRID2%ZOMC2 + ZSINLAT1 * YDGRID2%ZOPC2) &
            &     / (+YDGRID2%ZOPC2 - ZSINLAT1 * YDGRID2%ZOMC2))
    ENDIF

! Find nearest latitude

    JLAT2A = 0; JLAT2B = INLAT2+1
   
    DO 
      JLAT2M = (JLAT2A + JLAT2B) / 2
      IF (ZLAT2 (JLAT2A) >= ZLAT1 .AND. ZLAT1 >= ZLAT2 (JLAT2M)) THEN
        JLAT2B = JLAT2M
      ELSE
        JLAT2A = JLAT2M
      ENDIF
      IF (ABS (JLAT2B - JLAT2A) <= 1) EXIT
    ENDDO
   
    IF (ABS (ZLAT1 - ZLAT2 (JLAT2A)) < ABS (ZLAT1 - ZLAT2 (JLAT2B))) THEN
      JLAT2 = JLAT2A
    ELSE
      JLAT2 = JLAT2B
    ENDIF
   
    JLAT2 = MAX (MIN (JLAT2, INLAT2), 1)

! Find nearest longitude

    INLON2 = YDGRID2%NLOEN (JLAT2)
    JLON2 = 1 + MODULO (NINT ((REAL (INLON2, JPRB) * (ZLON1 - YDGRID2%RLONOFF)) / (R2PI)), INLON2)

! Find processor

    CALL JLONJLAT_TO_JAJB (JLON2, JLAT2, YDDIST2, JA2, JB2)
   
    IPRC2 (JLOC1) = YDDIST2%NGPSET2PE (JA2, JB2)
    ILON2 (JLOC1) = JLON2
    ILAT2 (JLOC1) = JLAT2
    ILOC1 (JLOC1) = JLOC1

  ENDDO

!$OMP END PARALLEL DO

ENDBLOCK
IF (LHOOK) CALL DR_HOOK ('CREATE_SHUFFLE.1',1,ZHOOK_HANDLE_1)

! Compute & exchange send/recv counts

ALLOCATE (ISENDCNT (INPROC), IRECVCNT (INPROC), ISENDOFF (INPROC))
ISENDCNT = 0

DO JLOC1 = 1, IGPTO1
  ISENDCNT (IPRC2 (JLOC1)) = ISENDCNT (IPRC2 (JLOC1)) + 1
ENDDO

ISENDOFF (1) = 0
DO IPROC = 2, INPROC
  ISENDOFF (IPROC) = ISENDOFF (IPROC-1) + ISENDCNT (IPROC-1)
ENDDO

CALL MPL_ALLTOALLV (KSENDBUF=ISENDCNT, KRECVBUF=IRECVCNT, &
                  & KSENDCOUNTS=[(1,IPROC=1,INPROC)], &
                  & KRECVCOUNTS=[(1,IPROC=1,INPROC)], &
                  & CDSTRING='CREATE_SHUFFLE')

! Sort points by task, latitude, longitude

IF (LHOOK) CALL DR_HOOK ('CREATE_SHUFFLE.2',0,ZHOOK_HANDLE_1)
BLOCK 
  INTEGER (KIND=JPIM) :: ISORT (2, IGPTO1)
  INTEGER (KIND=JPIM) :: IORD (IGPTO1)
  INTEGER (KIND=JPIM) :: IGLO2_OFF (YDGRID2%NDGLG)

  IGLO2_OFF (1) = 0
  DO JLAT2 = 2, YDGRID2%NDGLG 
    IGLO2_OFF (JLAT2) = IGLO2_OFF (JLAT2-1) + YDGRID2%NLOEN (JLAT2-1)
  ENDDO

  IF (LHOOK) CALL DR_HOOK ('CREATE_SHUFFLE.2.1',0,ZHOOK_HANDLE_2)
!$OMP PARALLEL DO PRIVATE (JLOC1)
  DO JLOC1 = 1, IGPTO1
    ISORT (1, JLOC1) = IPRC2 (JLOC1)
    ISORT (2, JLOC1) = IGLO2_OFF (ILAT2 (JLOC1)) + ILON2 (JLOC1)
  ENDDO
!$OMP END PARALLEL DO
  IF (LHOOK) CALL DR_HOOK ('CREATE_SHUFFLE.2.1',1,ZHOOK_HANDLE_2)

  IF (LHOOK) CALL DR_HOOK ('CREATE_SHUFFLE.2.2',0,ZHOOK_HANDLE_2)
  CALL SORTI4X2 (IGPTO1, IORD, ISORT)
  IF (LHOOK) CALL DR_HOOK ('CREATE_SHUFFLE.2.2',1,ZHOOK_HANDLE_2)

  IF (LHOOK) CALL DR_HOOK ('CREATE_SHUFFLE.2.3',0,ZHOOK_HANDLE_2)
  IPRC2 = IPRC2 (IORD)
  ILON2 = ILON2 (IORD)
  ILAT2 = ILAT2 (IORD)
  ILOC1 = ILOC1 (IORD)
  IGLO1 = IGLO1 (IORD)
  IF (LHOOK) CALL DR_HOOK ('CREATE_SHUFFLE.2.3',1,ZHOOK_HANDLE_2)

ENDBLOCK
IF (LHOOK) CALL DR_HOOK ('CREATE_SHUFFLE.2',1,ZHOOK_HANDLE_1)

INSEND = COUNT (ISENDCNT /= 0)
INRECV = COUNT (IRECVCNT /= 0)

BLOCK

  INTEGER (KIND=JPIM) :: IREQRECV (INRECV)
  INTEGER (KIND=JPIM) :: IREQSEND (INSEND)

  IF (LHOOK) CALL DR_HOOK ('CREATE_SHUFFLE.3',0,ZHOOK_HANDLE_1)

  ALLOCATE (YLRECV (INRECV))
  ALLOCATE (YDSHFL%YL_SEND (INSEND), YDSHFL%YL_RECV (INRECV))
  
  IREQRECV = MPI_REQUEST_NULL
  IREQRECV = MPI_REQUEST_NULL
  
! Prepare reception of latitude/longitude indices (grid #2 indices,
! corresponding to the points of grid #1 we will receive)

  INRECV = 1
  DO IPROC = 1, INPROC
    IF (IRECVCNT (IPROC) > 0) THEN
      YDSHFL%YL_RECV (INRECV)%IPROC = IPROC
      ALLOCATE (YLRECV (INRECV)%IALLX (3, IRECVCNT (IPROC)))
      YLRECV (INRECV)%ILON2 => YLRECV (INRECV)%IALLX (1,:)
      YLRECV (INRECV)%ILAT2 => YLRECV (INRECV)%IALLX (2,:)
      YLRECV (INRECV)%IGLO1 => YLRECV (INRECV)%IALLX (3,:)
      CALL MPL_RECV (KBUF=YLRECV (INRECV)%IALLX, KSOURCE=IPROC, KTAG=101, CDSTRING='CREATE_SHUFFLE', &
                   & KMP_TYPE=JP_NON_BLOCKING_STANDARD, KREQUEST=IREQRECV (INRECV))
      INRECV = INRECV + 1
    ENDIF
  ENDDO
  
  CALL MPL_BARRIER (CDSTRING='CREATE_SHUFFLE')
  
! Send latitude/longitude indices 
  
  INSEND = 1
  DO IPROC = 1, INPROC
    IF (ISENDCNT (IPROC) > 0) THEN
      YDSHFL%YL_SEND (INSEND)%IPROC = IPROC
      YDSHFL%YL_SEND (INSEND)%ISIZE = ISENDCNT (IPROC)
      ALLOCATE (YDSHFL%YL_SEND (INSEND)%ILOCAL (ISENDCNT (IPROC)))
      YDSHFL%YL_SEND (INSEND)%ILOCAL = ILOC1 (ISENDOFF (IPROC)+1:ISENDOFF (IPROC)+ISENDCNT (IPROC))
      CALL MPL_SEND (KBUF=IALLX (1:3,ISENDOFF (IPROC)+1:ISENDOFF (IPROC)+ISENDCNT (IPROC)), &
                   & KMP_TYPE=JP_NON_BLOCKING_STANDARD, KREQUEST=IREQSEND (INSEND),         &
                   & KDEST=IPROC, KTAG=101, CDSTRING='CREATE_SHUFFLE')
      INSEND = INSEND + 1
    ENDIF
  ENDDO
  
  CALL MPL_WAIT (KREQUEST=IREQRECV, CDSTRING='CREATE_SHUFFLE')
  
  CALL GET_MYREGION (YLMYREGION2, YDDIST2, YDGRID2)
  
  BLOCK
    INTEGER (KIND=JPIM) :: ILOCAL_OFF (YLMYREGION2%NLAN:YLMYREGION2%NLAS)
    INTEGER (KIND=JPIM) :: INLOC, II, JJ, ISIZE
  
  
! Ancillary array used to find local index when latitude and longitude indices
! are known
  
    ILOCAL_OFF (YLMYREGION2%NLAN) = 0
    DO JLAT2 = YLMYREGION2%NLAN+1, YLMYREGION2%NLAS
      ILOCAL_OFF (JLAT2) = ILOCAL_OFF (JLAT2-1) + 1 + &
     & MODULO (YLMYREGION2%NLOE (JLAT2-1) - YLMYREGION2%NLOW (JLAT2-1), YDGRID2%NLOEN (JLAT2-1))
    ENDDO
  
!$OMP PARALLEL DO PRIVATE (II, JLAT2, JLON2, INLOC, JJ, ISIZE)
    DO II = 1, SIZE (YDSHFL%YL_RECV)
  
! Count number of different local points
      JLAT2 = -1; JLON2 = -1
      INLOC = 0
      DO JJ = 1, SIZE (YLRECV (II)%ILON2)
        IF (JLAT2 /= YLRECV (II)%ILAT2 (JJ) .OR. JLON2 /= YLRECV (II)%ILON2 (JJ)) THEN
          INLOC = INLOC + 1
          JLAT2 = YLRECV (II)%ILAT2 (JJ); JLON2 = YLRECV (II)%ILON2 (JJ)
        ENDIF
      ENDDO

! Count number of different remote points for each local point on grid #2
  
      ALLOCATE (YDSHFL%YL_RECV (II)%ILOCAL      (INLOC), &
              & YDSHFL%YL_RECV (II)%IREMOTE_CNT (INLOC), &
              & YDSHFL%YL_RECV (II)%IREMOTE_OFF (INLOC))
     
      JLAT2 = -1; JLON2 = -1
      INLOC = 0
      DO JJ = 1, SIZE (YLRECV (II)%ILON2)

        IF (JLAT2 /= YLRECV (II)%ILAT2 (JJ) .OR. JLON2 /= YLRECV (II)%ILON2 (JJ)) THEN
  
          JLAT2 = YLRECV (II)%ILAT2 (JJ); JLON2 = YLRECV (II)%ILON2 (JJ)

          INLOC = INLOC + 1

          YDSHFL%YL_RECV (II)%IREMOTE_OFF (INLOC) = JJ-1

! Compute local index
  
          YDSHFL%YL_RECV (II)%ILOCAL (INLOC) = ILOCAL_OFF (JLAT2) + 1 + &
               & MODULO (JLON2 - YLMYREGION2%NLOW (JLAT2), YDGRID2%NLOEN (JLAT2))

        ENDIF

      ENDDO

      ISIZE = SIZE (YDSHFL%YL_RECV (II)%IREMOTE_CNT)
      DO JJ = 1, ISIZE-1
        YDSHFL%YL_RECV (II)%IREMOTE_CNT (JJ) = YDSHFL%YL_RECV (II)%IREMOTE_OFF (JJ+1) &
                                           & - YDSHFL%YL_RECV (II)%IREMOTE_OFF (JJ)
      ENDDO
      YDSHFL%YL_RECV (II)%IREMOTE_CNT (ISIZE) = SIZE (YLRECV (II)%ILON2) - YDSHFL%YL_RECV (II)%IREMOTE_OFF (ISIZE)
      
     
      YDSHFL%YL_RECV (II)%ISIZE = SUM (YDSHFL%YL_RECV (II)%IREMOTE_CNT)
  
    ENDDO
!$OMP END PARALLEL DO

  ENDBLOCK

  IF (LHOOK) CALL DR_HOOK ('CREATE_SHUFFLE.3',1,ZHOOK_HANDLE_1)
  IF (LHOOK) CALL DR_HOOK ('CREATE_SHUFFLE.4',0,ZHOOK_HANDLE_1)

  BLOCK
    INTEGER (KIND=JPIM) :: ISIZE, JL, II, JJ, IGPTO2, JLOC2
    INTEGER (KIND=JPIM) :: IOFF, ICNT
    INTEGER (KIND=JPIM), ALLOCATABLE :: ISORT (:,:), IORD (:)

    IF (LHOOK) CALL DR_HOOK ('CREATE_SHUFFLE.4.1',0,ZHOOK_HANDLE_2)
    IGPTO2 = YDDIST2%NGPTOTL (MYPROC)

    ISIZE = SUM (YDSHFL%YL_RECV%ISIZE)
 
    ALLOCATE (ISORT (2, ISIZE), YDSHFL%ISORT (ISIZE), YDSHFL%ILOCAL_CNT (IGPTO2), YDSHFL%ILOCAL_OFF (IGPTO2), IORD (ISIZE))
    YDSHFL%ILOCAL_CNT = 0

    DO II = 1, SIZE (YDSHFL%YL_RECV)
      DO JJ = 1, SIZE (YDSHFL%YL_RECV (II)%ILOCAL)
        JLOC2 = YDSHFL%YL_RECV (II)%ILOCAL (JJ)
        YDSHFL%ILOCAL_CNT (JLOC2) = YDSHFL%ILOCAL_CNT (JLOC2) + YDSHFL%YL_RECV (II)%IREMOTE_CNT (JJ)
      ENDDO
    ENDDO
    IF (LHOOK) CALL DR_HOOK ('CREATE_SHUFFLE.4.1',1,ZHOOK_HANDLE_2)

    IF (LHOOK) CALL DR_HOOK ('CREATE_SHUFFLE.4.2',0,ZHOOK_HANDLE_2)
    YDSHFL%ILOCAL_OFF (1) = 0
    DO JLOC2 = 2, IGPTO2
      YDSHFL%ILOCAL_OFF (JLOC2) = YDSHFL%ILOCAL_OFF (JLOC2-1) + YDSHFL%ILOCAL_CNT (JLOC2-1)
    ENDDO
    IF (LHOOK) CALL DR_HOOK ('CREATE_SHUFFLE.4.2',1,ZHOOK_HANDLE_2)

! Compute sort key

    IF (LHOOK) CALL DR_HOOK ('CREATE_SHUFFLE.4.3',0,ZHOOK_HANDLE_2)
    JL = 0
    DO II = 1, SIZE (YDSHFL%YL_RECV)

!$OMP PARALLEL DO PRIVATE (JJ, JLOC2, IOFF, ICNT)
      DO JJ = 1, SIZE (YDSHFL%YL_RECV (II)%ILOCAL)
        JLOC2 = YDSHFL%YL_RECV (II)%ILOCAL (JJ) 
        IOFF = JL + YDSHFL%YL_RECV (II)%IREMOTE_OFF (JJ) 
        ICNT =      YDSHFL%YL_RECV (II)%IREMOTE_CNT (JJ) 
        ISORT (1,IOFF+1:IOFF+ICNT) = JLOC2
      ENDDO
!$OMP END PARALLEL DO

      JL = JL + YDSHFL%YL_RECV (II)%ISIZE
    ENDDO
    IF (LHOOK) CALL DR_HOOK ('CREATE_SHUFFLE.4.3',1,ZHOOK_HANDLE_2)

    IF (LHOOK) CALL DR_HOOK ('CREATE_SHUFFLE.4.4',0,ZHOOK_HANDLE_2)
    JL = 0
    DO II = 1, SIZE (YLRECV)
!$OMP PARALLEL DO PRIVATE (JJ)
      DO JJ = 1, SIZE (YLRECV (II)%IGLO1)
        ISORT (2,JL+JJ) = YLRECV (II)%IGLO1 (JJ)
      ENDDO
!$OMP END PARALLEL DO
      JL = JL + SIZE (YLRECV (II)%IGLO1)
    ENDDO
    IF (LHOOK) CALL DR_HOOK ('CREATE_SHUFFLE.4.4',1,ZHOOK_HANDLE_2)


! Sort by local index, remote index

    IF (LHOOK) CALL DR_HOOK ('CREATE_SHUFFLE.4.5',0,ZHOOK_HANDLE_2)
    CALL SORTI4X2 (ISIZE, IORD, ISORT)
    IF (LHOOK) CALL DR_HOOK ('CREATE_SHUFFLE.4.5',1,ZHOOK_HANDLE_2)

    DO JJ = 1, SIZE (YDSHFL%ISORT)
      YDSHFL%ISORT (IORD (JJ)) = JJ
    ENDDO

  ENDBLOCK
  IF (LHOOK) CALL DR_HOOK ('CREATE_SHUFFLE.4',1,ZHOOK_HANDLE_1)
  
  CALL MPL_WAIT (KREQUEST=IREQSEND, CDSTRING='CREATE_SHUFFLE')

ENDBLOCK

BLOCK
  INTEGER (KIND=JPIM) :: JLOC2, IGPTO2, ICOUNT
  IGPTO2 = YDDIST2%NGPTOTL (MYPROC)

  ICOUNT = 0
  DO JLOC2 = 1, IGPTO2
    IF (YDSHFL%ILOCAL_CNT (JLOC2) == 0) THEN
      ICOUNT = ICOUNT + 1
      IF (ICOUNT < 20) THEN
        WRITE (0, *) 'CREATE_SHUFFLE: NO POINTS WERE FOUND FOR LOCAL ', JLOC2
      ENDIF
    ENDIF
  ENDDO
  IF (ICOUNT > 0) THEN
    WRITE (0, *) 'CREATE_SHUFFLE: ...'
    WRITE (0, *) 'CREATE_SHUFFLE: NO POINTS WERE FOUND FOR ', ICOUNT, ' POINTS'
  ENDIF

ENDBLOCK


IF (LHOOK) CALL DR_HOOK ('CREATE_SHUFFLE',1,ZHOOK_HANDLE)

END SUBROUTINE

SUBROUTINE DEMO_LATLON (YDDIST, YDGRID, LDPRINT)

USE MPL_MODULE,        ONLY : MPL_MYRANK, MPL_NUMPROC

TYPE (DIST_t), INTENT (IN) :: YDDIST
TYPE (GRID_t), INTENT (IN) :: YDGRID
LOGICAL,       INTENT (IN) :: LDPRINT

INTEGER (KIND=JPIM) :: IGPTOT, MYPROC
REAL (KIND=JPRB), ALLOCATABLE :: ZLATLON (:,:)
REAL(KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK ('DEMO_LATLON',0,ZHOOK_HANDLE)

MYPROC = MPL_MYRANK ()

IGPTOT = YDDIST%NGPTOTL (MYPROC)

ALLOCATE (ZLATLON (IGPTOT, 2))

CALL GET_MY_LATLON (YDGRID, YDDIST, ZLATLON)

IF (LDPRINT) THEN
CALL GMSH (ZLATLON (:,1), IGPTOT, "lat.msh", YDGRID, YDDIST)
CALL GMSH (ZLATLON (:,2), IGPTOT, "lon.msh", YDGRID, YDDIST)
CALL WFA (ZLATLON, IGPTOT, 2_JPIM, "LATLON.fa", ["SURF", "SURF"], &
        & [0, 0], ["LAT", "LON"], YDGRID, YDDIST)
ENDIF

IF (LHOOK) CALL DR_HOOK ('DEMO_LATLON',1,ZHOOK_HANDLE)
END SUBROUTINE

SUBROUTINE DEMO_GATHDIST (YDDIST, YDGRID, KFLDG, LDTEST, LDPRINT)

USE MPL_MODULE,        ONLY : MPL_MYRANK, MPL_NUMPROC

TYPE (DIST_t),       INTENT (IN) :: YDDIST
TYPE (GRID_t),       INTENT (IN) :: YDGRID
INTEGER (KIND=JPIM), INTENT (IN) :: KFLDG
LOGICAL,             INTENT (IN) :: LDTEST
LOGICAL,             INTENT (IN) :: LDPRINT

#include "gath_grid.h"
#include "dist_grid.h"

REAL (KIND=JPRB), ALLOCATABLE :: ZGPBUFL (:,:,:), ZGPBUFL1 (:,:,:)
REAL (KIND=JPRB), ALLOCATABLE :: ZGPBUFG (:,:),   ZGPBUFG1 (:,:)

LOGICAL :: LLTEST
INTEGER (KIND=JPIM) :: INFLD
INTEGER (KIND=JPIM) :: MYPROC, IGPTOT, II, JJ, JFLD
INTEGER (KIND=JPIM), ALLOCATABLE :: IFLD2PROC (:)
REAL(KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK ('DEMO_GATHDIST',0,ZHOOK_HANDLE)

MYPROC = MPL_MYRANK ()
IGPTOT = YDDIST%NGPTOTL (MYPROC)

LLTEST = LDTEST .AND. YDDIST%NRESOL > 1

INFLD = KFLDG

ALLOCATE (ZGPBUFL (IGPTOT, INFLD, 1))

IF (LLTEST) THEN
  ALLOCATE (ZGPBUFL1 (IGPTOT, INFLD, 1))
ENDIF

ALLOCATE (IFLD2PROC (INFLD))

DO JJ = 1, INFLD
  IF (MODULO (JJ, 2) == 1) THEN
    ZGPBUFL (:, JJ, 1) = JJ * 1000 + MYPROC
  ELSE
    ZGPBUFL (:, JJ, 1) = [(II + REAL (JJ) / 1000._JPRB, II = 1, IGPTOT)]
  ENDIF
  IFLD2PROC (JJ) = 1 + MODULO (JJ, YDDIST%NPROC)
ENDDO

IF (LLTEST) THEN
  ZGPBUFL1 = ZGPBUFL
ENDIF

ALLOCATE (ZGPBUFG (YDGRID%NGPTOTG, INFLD))
ZGPBUFG = 0

IF (LLTEST) THEN
  ALLOCATE (ZGPBUFG1 (YDGRID%NGPTOTG, INFLD))
  ZGPBUFG1 = 0
ENDIF

CALL GRID_GATH (PGPG=ZGPBUFG, KFIELDG=INFLD, KFLD2PROC=IFLD2PROC, &
              & YDGRID=YDGRID, YDDIST=YDDIST, PGP=ZGPBUFL (:,:,1))
IF (LLTEST) THEN
  CALL GATH_GRID (PGPG=ZGPBUFG1, KFGATHG=INFLD, KTO=IFLD2PROC, &
                & PGP=ZGPBUFL1 (:,:,:), KRESOL=YDDIST%NRESOL)
ENDIF

IF (LLTEST) THEN
  JFLD = 0
  DO JJ = 1, INFLD
    IF (MYPROC == IFLD2PROC (JJ)) THEN
      JFLD = JFLD + 1
      DO II = 1, YDGRID%NGPTOTG
        IF (ZGPBUFG1 (II, JFLD) /= ZGPBUFG (II, JFLD)) THEN
          WRITE (0, *) " DIFF1 ", JJ, II, ZGPBUFG1 (II, JFLD), ZGPBUFG (II, JFLD)
        ENDIF
      ENDDO
    ENDIF
  ENDDO
ENDIF

ZGPBUFL = 0

IF (LLTEST) THEN
  ZGPBUFL1 = 0
ENDIF

CALL GRID_DIST (PGPG=ZGPBUFG, KFIELDG=INFLD, KFLD2PROC=IFLD2PROC, &
              & YDGRID=YDGRID, YDDIST=YDDIST, PGP=ZGPBUFL (:,:,1))

IF (LLTEST) THEN
  CALL DIST_GRID (PGPG=ZGPBUFG1, KFDISTG=INFLD, KFROM=IFLD2PROC, &
                & PGP=ZGPBUFL1 (:,:,:), KRESOL=YDDIST%NRESOL)
ENDIF

DO JJ = 1, INFLD
  IF (MODULO (JJ, 2) == 1) THEN
!$OMP PARALLEL DO PRIVATE (II)
    DO II = 1, IGPTOT
      IF (ZGPBUFL (II, JJ, 1) /= JJ * 1000 + MYPROC) THEN
        WRITE (0, *) " DIFF2 ", JJ, II, ZGPBUFL (II, JJ, 1), JJ * 1000 + MYPROC
      ENDIF
    ENDDO
!$OMP END PARALLEL DO
  ELSE
!$OMP PARALLEL DO PRIVATE (II)
    DO II = 1, IGPTOT
      IF (ZGPBUFL (II, JJ, 1) /= II + REAL (JJ) / 1000._JPRB) THEN
        WRITE (0, *) " DIFF2 ", JJ, II, ZGPBUFL (II, JJ, 1), II + REAL (JJ) / 1000._JPRB
      ENDIF
    ENDDO
!$OMP END PARALLEL DO
  ENDIF
ENDDO

IF (LHOOK) CALL DR_HOOK ('DEMO_GATHDIST',1,ZHOOK_HANDLE)

END SUBROUTINE  

SUBROUTINE GRID_DIST (PGPG, KFIELDG, KFLD2PROC, YDGRID, YDDIST, PGP)

USE MPL_DATA_MODULE,   ONLY : JP_NON_BLOCKING_STANDARD
USE MPL_MODULE,        ONLY : MPL_MYRANK, MPL_NUMPROC
USE MPL_RECV_MOD,      ONLY : MPL_RECV
USE MPL_SEND_MOD,      ONLY : MPL_SEND
USE MPL_BARRIER_MOD,   ONLY : MPL_BARRIER
USE MPL_MPIF,          ONLY : MPI_REQUEST_NULL, MPI_UNDEFINED
USE MPL_WAIT_MOD,      ONLY : MPL_WAIT
USE MPL_WAITANY_MOD,   ONLY : MPL_WAITANY
USE MPL_MODULE,        ONLY : MPL_COMM_OML

REAL (KIND=JPRB),    INTENT (IN), OPTIONAL :: PGPG (:, :)
INTEGER (KIND=JPIM), INTENT (IN)  :: KFIELDG
INTEGER (KIND=JPIM), INTENT (IN)  :: KFLD2PROC (:)
TYPE (GRID_t),       INTENT (IN)  :: YDGRID
TYPE (DIST_t),       INTENT (IN)  :: YDDIST
REAL (KIND=JPRB),    INTENT (OUT) :: PGP (:, :)

#include "abor1.intfb.h"

INTEGER (KIND=JPIM) :: IREQD (YDDIST%NPROC), IREQR (YDDIST%NPROC)
INTEGER (KIND=JPIM) :: MYPROC, IFIELDL, IPROC
INTEGER (KIND=JPIM) :: IOFFD, ILEND, IOFFR, ILENR, IGPTOT
INTEGER (KIND=JPIM), ALLOCATABLE :: IOFFR_ALL (:)
INTEGER (KIND=JPIM), ALLOCATABLE :: IOFFD_ALL (:)
INTEGER (KIND=JPIM) :: JA, JB, JLON, JLAT, IGLOOFF, ILOC, JFLDG, JFLDL, INFLD, IGL, II
INTEGER (KIND=JPIM) :: ICOMM
REAL (KIND=JPRB), ALLOCATABLE :: ZBUFR (:), ZBUFD (:)
REAL(KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK ('GRID_DIST',0,ZHOOK_HANDLE)

ICOMM = MPL_COMM_OML (1)
IREQD = MPI_REQUEST_NULL
IREQR = MPI_REQUEST_NULL

MYPROC = MPL_MYRANK ()

IFIELDL = COUNT (KFLD2PROC == MYPROC)

IF (IFIELDL > 0) THEN
  IF (.NOT. PRESENT (PGPG)) THEN
    CALL ABOR1 ('GRID_DIST: PGPG IS REQUIRED')
  ENDIF
  IF (SIZE (PGPG, 1) /= YDGRID%NGPTOTG .OR. SIZE (PGPG, 2) /= IFIELDL) THEN
    CALL ABOR1 ('GRID_DIST: WRONG SIZE FOR PGPG')
  ENDIF
ENDIF

IGPTOT = YDDIST%NGPTOTL (MYPROC)

ALLOCATE (ZBUFD (IGPTOT * KFIELDG))
ALLOCATE (IOFFD_ALL (YDDIST%NPROC))

IOFFD = 0
ILEND = IGPTOT
DO IPROC = 1, YDDIST%NPROC
  INFLD = COUNT (KFLD2PROC == IPROC)

  IOFFD_ALL (IPROC) = IOFFD

  IF (INFLD > 0) THEN
    CALL MPL_RECV (PBUF=ZBUFD (IOFFD+1:IOFFD+ILEND*INFLD), KSOURCE=IPROC,     &
                 & KMP_TYPE=JP_NON_BLOCKING_STANDARD, KREQUEST=IREQD (IPROC), &
                 & KTAG=101, KCOMM=ICOMM, CDSTRING='GRID_DIST')

    IOFFD = IOFFD + ILEND * INFLD
  ENDIF
ENDDO

CALL MPL_BARRIER (KCOMM=ICOMM, CDSTRING='GRID_DIST')

IF (IFIELDL > 0) THEN

  ALLOCATE (ZBUFR (IFIELDL*YDGRID%NGPTOTG))
  ALLOCATE (IOFFR_ALL (YDDIST%NPROC))

  IOFFR = 0
  DO IPROC = 1, YDDIST%NPROC
    ILENR = YDDIST%NGPTOTL (IPROC) * IFIELDL
    IOFFR_ALL (IPROC) = IOFFR
    IOFFR = IOFFR + ILENR
  ENDDO

!$OMP PARALLEL DO PRIVATE (IPROC, JA, JB, ILENR, IOFFR, ILOC, IGLOOFF, JLAT, IGL, JLON, JFLDL)

  DO IPROC = 1, YDDIST%NPROC
    JA = YDDIST%NGPPE2SET (1, IPROC)
    JB = YDDIST%NGPPE2SET (2, IPROC)

    ILENR = YDDIST%NGPTOTL (IPROC)
    IOFFR = IOFFR_ALL (IPROC)

    ILOC = 1
    IGLOOFF = SUM (YDGRID%NLOEN (1:YDDIST%NFRSTLAT (JA)-1))

    DO JLAT = YDDIST%NFRSTLAT (JA), YDDIST%NLSTLAT (JA)
      IGL = YDDIST%NPTRFRSTLAT (JA) + JLAT - YDDIST%NFRSTLAT (JA)
      DO JLON = YDDIST%NSTA (IGL, JB), YDDIST%NSTA (IGL, JB) + YDDIST%NONL (IGL, JB)-1
        DO JFLDL = 1, IFIELDL
          ZBUFR (IOFFR+(JFLDL-1)*ILENR+ILOC) = PGPG (IGLOOFF+JLON, JFLDL)
        ENDDO
        ILOC = ILOC + 1
      ENDDO
      IGLOOFF = IGLOOFF + YDGRID%NLOEN (JLAT)
    ENDDO

    CALL MPL_SEND (PBUF=ZBUFR (IOFFR+1:IOFFR+ILENR*IFIELDL), KDEST=IPROC,     &
                 & KMP_TYPE=JP_NON_BLOCKING_STANDARD, KREQUEST=IREQR (IPROC), &
                 & KTAG=101, KCOMM=ICOMM, CDSTRING='GRID_DIST')
  
  ENDDO

!$OMP END PARALLEL DO

ENDIF

DO 
  CALL MPL_WAITANY (KREQUEST=IREQD, KINDEX=IPROC, CDSTRING='GRID_DIST')
  IF (IPROC == MPI_UNDEFINED) EXIT

  ILEND = IGPTOT
  IOFFD = IOFFD_ALL (IPROC)
  INFLD = 0
  DO JFLDG = 1, KFIELDG
    IF (KFLD2PROC (JFLDG) == IPROC) THEN
      INFLD = INFLD + 1
!$OMP PARALLEL DO PRIVATE (II)
      DO II = 1, ILEND
        PGP (II, JFLDG) = ZBUFD (IOFFD+(INFLD-1)*ILEND+II) 
      ENDDO
!$OMP END PARALLEL DO
    ENDIF
  ENDDO

ENDDO

CALL MPL_WAIT (KREQUEST=IREQR, CDSTRING='GRID_DIST')

IF (LHOOK) CALL DR_HOOK ('GRID_DIST',1,ZHOOK_HANDLE)

END SUBROUTINE

SUBROUTINE GRID_GATH (PGPG, KFIELDG, KFLD2PROC, YDGRID, YDDIST, PGP)

USE MPL_DATA_MODULE,   ONLY : JP_NON_BLOCKING_STANDARD
USE MPL_MODULE,        ONLY : MPL_MYRANK, MPL_NUMPROC
USE MPL_RECV_MOD,      ONLY : MPL_RECV
USE MPL_SEND_MOD,      ONLY : MPL_SEND
USE MPL_BARRIER_MOD,   ONLY : MPL_BARRIER
USE MPL_MPIF,          ONLY : MPI_REQUEST_NULL, MPI_UNDEFINED
USE MPL_WAIT_MOD,      ONLY : MPL_WAIT
USE MPL_WAITANY_MOD,   ONLY : MPL_WAITANY
USE MPL_MODULE,        ONLY : MPL_COMM_OML

REAL (KIND=JPRB),    INTENT (OUT), OPTIONAL :: PGPG (:, :)
INTEGER (KIND=JPIM), INTENT (IN) :: KFIELDG
INTEGER (KIND=JPIM), INTENT (IN) :: KFLD2PROC (:)
TYPE (GRID_t),       INTENT (IN) :: YDGRID
TYPE (DIST_t),       INTENT (IN) :: YDDIST
REAL (KIND=JPRB),    INTENT (IN) :: PGP (:, :)

#include "abor1.intfb.h"

INTEGER (KIND=JPIM) :: IREQD (YDDIST%NPROC), IREQR (YDDIST%NPROC)
INTEGER (KIND=JPIM) :: MYPROC, IFIELDL, IPROC
INTEGER (KIND=JPIM) :: IOFFD, ILEND, IOFFR, ILENR, IGPTOT
INTEGER (KIND=JPIM), ALLOCATABLE :: IOFFR_ALL (:)
INTEGER (KIND=JPIM), ALLOCATABLE :: IOFFD_ALL (:)
INTEGER (KIND=JPIM) :: JA, JB, JLON, JLAT, IGLOOFF, ILOC, JFLDG, JFLDL, INFLD, IGL, II
INTEGER (KIND=JPIM) :: ICOMM
REAL (KIND=JPRB), ALLOCATABLE :: ZBUFR (:), ZBUFD (:)
REAL(KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK ('GRID_GATH',0,ZHOOK_HANDLE)

ICOMM = MPL_COMM_OML (1)
IREQD = MPI_REQUEST_NULL
IREQR = MPI_REQUEST_NULL

MYPROC = MPL_MYRANK ()

IFIELDL = COUNT (KFLD2PROC == MYPROC)

IF (IFIELDL > 0) THEN

  IF (.NOT. PRESENT (PGPG)) THEN
    CALL ABOR1 ('GRID_GATH: PGPG IS REQUIRED')
  ENDIF
  IF (SIZE (PGPG, 1) /= YDGRID%NGPTOTG .OR. SIZE (PGPG, 2) /= IFIELDL) THEN
    CALL ABOR1 ('GRID_GATH: WRONG SIZE FOR PGPG')
  ENDIF

  ALLOCATE (ZBUFR (IFIELDL*YDGRID%NGPTOTG))
  ALLOCATE (IOFFR_ALL (YDDIST%NPROC))

  IOFFR = 0
  DO IPROC = 1, YDDIST%NPROC
    ILENR = YDDIST%NGPTOTL (IPROC) * IFIELDL
    IOFFR_ALL (IPROC) = IOFFR
    CALL MPL_RECV (PBUF=ZBUFR (IOFFR+1:IOFFR+ILENR), KSOURCE=IPROC,           &
                 & KMP_TYPE=JP_NON_BLOCKING_STANDARD, KREQUEST=IREQR (IPROC), &
                 & KTAG=102, KCOMM=ICOMM, CDSTRING='GRID_GATH')
    IOFFR = IOFFR + ILENR
  ENDDO

ENDIF

CALL MPL_BARRIER (KCOMM=ICOMM, CDSTRING='GRID_GATH')

IGPTOT = YDDIST%NGPTOTL (MYPROC)

ALLOCATE (ZBUFD (IGPTOT * KFIELDG))
ALLOCATE (IOFFD_ALL (YDDIST%NPROC))

IOFFD = 0
ILEND = IGPTOT
DO IPROC = 1, YDDIST%NPROC
  INFLD = COUNT (KFLD2PROC == IPROC)
  IOFFD_ALL (IPROC) = IOFFD
  IOFFD = IOFFD + ILEND * INFLD
ENDDO

ILEND = IGPTOT

!$OMP PARALLEL DO PRIVATE (IPROC, INFLD, II, IOFFD)

DO IPROC = 1, YDDIST%NPROC
  IOFFD = IOFFD_ALL (IPROC)
  INFLD = 0
  DO JFLDG = 1, KFIELDG
    IF (KFLD2PROC (JFLDG) == IPROC) THEN
      INFLD = INFLD + 1
      DO II = 1, ILEND
        ZBUFD (IOFFD+(INFLD-1)*ILEND+II) = PGP (II, JFLDG)
      ENDDO
    ENDIF
  ENDDO

  IF (INFLD > 0) THEN
    CALL MPL_SEND (PBUF=ZBUFD (IOFFD+1:IOFFD+ILEND*INFLD), KDEST=IPROC,       &
                 & KMP_TYPE=JP_NON_BLOCKING_STANDARD, KREQUEST=IREQD (IPROC), &
                 & KTAG=102, KCOMM=ICOMM, CDSTRING='GRID_GATH')
  ENDIF

ENDDO

!$OMP END PARALLEL DO 

IF (IFIELDL > 0) THEN

!$OMP PARALLEL
!$OMP SINGLE

  DO 
    CALL MPL_WAITANY (KREQUEST=IREQR, KINDEX=IPROC, CDSTRING='GRID_GATH')
    IF (IPROC == MPI_UNDEFINED) EXIT

!$OMP TASK PRIVATE (JA, JB, ILENR, IOFFR, IGLOOFF, JLAT, JLON, IGL, JFLDL, ILOC, ZHOOK_HANDLE) FIRSTPRIVATE (IPROC)

    IF (LHOOK) CALL DR_HOOK ('GRID_GATH:COPY',0,ZHOOK_HANDLE)

    JA = YDDIST%NGPPE2SET (1, IPROC)
    JB = YDDIST%NGPPE2SET (2, IPROC)

    ILENR = YDDIST%NGPTOTL (IPROC)
    IOFFR = IOFFR_ALL (IPROC)

    ILOC = 1
    IGLOOFF = SUM (YDGRID%NLOEN (1:YDDIST%NFRSTLAT (JA)-1))

    DO JLAT = YDDIST%NFRSTLAT (JA), YDDIST%NLSTLAT (JA)
      IGL = YDDIST%NPTRFRSTLAT (JA) + JLAT - YDDIST%NFRSTLAT (JA)
      DO JLON = YDDIST%NSTA (IGL, JB), YDDIST%NSTA (IGL, JB) + YDDIST%NONL (IGL, JB)-1
        DO JFLDL = 1, IFIELDL
          PGPG (IGLOOFF+JLON, JFLDL) = ZBUFR (IOFFR+(JFLDL-1)*ILENR+ILOC)
        ENDDO
        ILOC = ILOC + 1
      ENDDO
      IGLOOFF = IGLOOFF + YDGRID%NLOEN (JLAT)
    ENDDO

    IF (LHOOK) CALL DR_HOOK ('GRID_GATH:COPY',1,ZHOOK_HANDLE)

!$OMP END TASK

  ENDDO
!$OMP END SINGLE
!$OMP END PARALLEL

  DEALLOCATE (ZBUFR)

ENDIF

CALL MPL_WAIT (KREQUEST=IREQD, CDSTRING='GRID_GATH')

IF (LHOOK) CALL DR_HOOK ('GRID_GATH',1,ZHOOK_HANDLE)

END SUBROUTINE

SUBROUTINE DEMO_HALO (YDGRID, YDDIST, LDPRINT)

USE MPL_MODULE, ONLY : MPL_MYRANK, MPL_NUMPROC

TYPE (GRID_t), INTENT (IN) :: YDGRID
TYPE (DIST_t), INTENT (IN) :: YDDIST
LOGICAL,       INTENT (IN) :: LDPRINT

REAL (KIND=JPRB), ALLOCATABLE :: ZGPBUFL (:)
INTEGER (KIND=JPIM) :: IH_WIDTH, IGPTOT, MYPROC, NPROC
TYPE (REGION_t) :: YLMYREGION
REAL(KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK ('DEMO_HALO',0,ZHOOK_HANDLE)

MYPROC = MPL_MYRANK ()
NPROC  = MPL_NUMPROC

IGPTOT = YDDIST%NGPTOTL (MYPROC)

ALLOCATE (ZGPBUFL (IGPTOT))

ZGPBUFL = MYPROC

IF (LDPRINT) THEN
CALL GMSH (ZGPBUFL, IGPTOT, "proc.msh", YDGRID, YDDIST)
CALL WFA (ZGPBUFL, IGPTOT, 1_JPIM, "HALO.fa", ["SURF"], &
        & [0_JPIM], ["PROC"], YDGRID, YDDIST)
ENDIF

CALL GET_MYREGION (YLMYREGION, YDDIST, YDGRID)

IF (LDPRINT) THEN
CALL REGION_PRINT (YLMYREGION, YDGRID)
WRITE (*, *)
ENDIF

DO IH_WIDTH = 1, 5
  CALL DEMO_HALO1 (YDGRID, YDDIST, YLMYREGION, IH_WIDTH, LDPRINT)
ENDDO

IF (LHOOK) CALL DR_HOOK ('DEMO_HALO',1,ZHOOK_HANDLE)

END SUBROUTINE 


SUBROUTINE DEMO_HALO1 (YDGRID, YDDIST, YDMYREG, KH_WIDTH, LDPRINT)

USE MPL_MODULE, ONLY : MPL_MYRANK, MPL_NUMPROC

TYPE (GRID_t),       INTENT (IN) :: YDGRID
TYPE (DIST_t),       INTENT (IN) :: YDDIST
TYPE (REGION_t),     INTENT (IN) :: YDMYREG
INTEGER (KIND=JPIM), INTENT (IN) :: KH_WIDTH
LOGICAL,             INTENT (IN) :: LDPRINT

REAL (KIND=JPRB), ALLOCATABLE :: ZGPBUFL (:), ZGPBUFL_H (:, :)
INTEGER (KIND=JPIM) :: IGPTOT, MYPROC, NPROC, IPROC
INTEGER (KIND=JPIM) :: II, JJ, IH, IC, IND
CHARACTER (LEN=64) :: CLFILENAME

TYPE (HALO_t) :: YLHALO
REAL(KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK ('DEMO_HALO1',0,ZHOOK_HANDLE)

MYPROC = MPL_MYRANK ()
NPROC  = MPL_NUMPROC

IGPTOT = YDDIST%NGPTOTL (MYPROC)

ALLOCATE (ZGPBUFL (IGPTOT))

IF (LDPRINT) &
WRITE (*, *)

CALL CREATE_HALO (YDGRID, YDDIST, KH_WIDTH, YLHALO, YDMYREG)

IF (LDPRINT) THEN
DO IPROC = 1, NPROC

  ZGPBUFL = IPROC
  
! Display points which will be sent to IPROC

  DO II = 1, SIZE (YLHALO%YL_SEND)
    IF (YLHALO%YL_SEND (II)%IPROC == IPROC) THEN
      DO JJ = 1, SIZE (YLHALO%YL_SEND (II)%IINDEX)
        ZGPBUFL (YLHALO%YL_SEND (II)%IINDEX (JJ))  = MYPROC
      ENDDO
    ENDIF
  ENDDO
  
  WRITE (CLFILENAME, '("O.",I3.3,".",I3.3)') IPROC, KH_WIDTH
  CALL GMSH (ZGPBUFL, IGPTOT, TRIM (CLFILENAME)//".msh", YDGRID, YDDIST)
  CALL WFA (ZGPBUFL, IGPTOT, 1_JPIM, "HALO.fa", ["SURF"], &
          & [0_JPIM], [TRIM (CLFILENAME)], YDGRID, YDDIST)

! Display points IPROC will send to others

  ZGPBUFL = 0

  IF (IPROC == MYPROC) THEN
    DO II = 1, SIZE (YLHALO%YL_SEND)
      DO JJ = 1, SIZE (YLHALO%YL_SEND (II)%IINDEX)
        ZGPBUFL (YLHALO%YL_SEND (II)%IINDEX (JJ)) = 1
      ENDDO
    ENDDO
  ENDIF

  WRITE (CLFILENAME, '("I.",I3.3,".",I3.3)') IPROC, KH_WIDTH
  CALL GMSH (ZGPBUFL, IGPTOT, TRIM (CLFILENAME)//".msh", YDGRID, YDDIST)
  CALL WFA (ZGPBUFL, IGPTOT, 1_JPIM, "HALO.fa", ["SURF"], &
          & [0_JPIM], [TRIM (CLFILENAME)], YDGRID, YDDIST)

ENDDO
ENDIF





ALLOCATE (ZGPBUFL_H (YLHALO%ISIZE+YLHALO%IH_SIZE,6))

ZGPBUFL_H (1:YLHALO%ISIZE,1) = MYPROC
ZGPBUFL_H (YLHALO%ISIZE+1:YLHALO%ISIZE+YLHALO%IH_SIZE,1) = 0._JPRB

CALL DO_HALO (YLHALO, YDDIST, ZGPBUFL_H)

! Sanity check

IF (ANY (ZGPBUFL_H (1:YLHALO%ISIZE,1) /= MYPROC)) THEN
  WRITE (0, *) __FILE__, ':', __LINE__ 
  STOP
ENDIF

IF (ANY (ZGPBUFL_H (YLHALO%ISIZE+1:YLHALO%ISIZE+YLHALO%IH_SIZE,1) == 0._JPRB)) THEN
  WRITE (0, *) __FILE__, ':', __LINE__ 
  STOP
ENDIF


BLOCK
  TYPE (REGION_t) :: YLMYREGION
  INTEGER (KIND=JPIM) :: ILOC, JLAT, JLON

  CALL GET_MYREGION (YLMYREGION, YDDIST, YDGRID)
  
  ILOC = 1
  DO JLAT = YLMYREGION%NLAN, YLMYREGION%NLAS
    DO JLON = YLMYREGION%NLOW (JLAT), YLMYREGION%NLOE (JLAT)
      IF (JLAT /= YLHALO%JLAT (ILOC) .OR. JLON /= YLHALO%JLON (ILOC)) THEN
        WRITE (0, *) " JLAT, JLON = ", JLAT, JLON, &
                   & YLHALO%JLAT (ILOC), YLHALO%JLON (ILOC)
      ENDIF
      ILOC = ILOC + 1
    ENDDO
  ENDDO

ENDBLOCK

BLOCK

! Display neighbours

  CHARACTER (LEN=2),   PARAMETER :: CLXX (6) = [    '_W',    '_E',    'NW',    'NE',    'SW',    'SE']
  INTEGER (KIND=JPIM), PARAMETER :: IIDX (6) = [JIDX__W, JIDX__E, JIDX_NW, JIDX_NE, JIDX_SW, JIDX_SE]
  INTEGER (KIND=JPIM), PARAMETER :: IINV (6) = [JIDX__E, JIDX__W, JIDX_SE, JIDX_SW, JIDX_NE, JIDX_NW]
  LOGICAL :: LLNORTHDIR (9), LISNORTHLAT
  LOGICAL :: LLSOUTHDIR (9), LISSOUTHLAT
  INTEGER (KIND=JPIM) :: II, JJ, IDIR, IIND, JNORTHLAT, JSOUTHLAT, JA, JB, JLON, JLAT
  TYPE (NEIGHBOURS1_t) :: YLN1

  JNORTHLAT = 1; JSOUTHLAT = YDGRID%NDGLG

  LLNORTHDIR (JIDX__W) = .FALSE.;   LLSOUTHDIR (JIDX__W) = .FALSE. 
  LLNORTHDIR (JIDX__E) = .FALSE.;   LLSOUTHDIR (JIDX__E) = .FALSE.
  LLNORTHDIR (JIDX_NW) = .TRUE. ;   LLSOUTHDIR (JIDX_NW) = .FALSE. 
  LLNORTHDIR (JIDX_NE) = .TRUE. ;   LLSOUTHDIR (JIDX_NE) = .FALSE.
  LLNORTHDIR (JIDX_SW) = .FALSE.;   LLSOUTHDIR (JIDX_SW) = .TRUE. 
  LLNORTHDIR (JIDX_SE) = .FALSE.;   LLSOUTHDIR (JIDX_SE) = .TRUE.
  LLNORTHDIR (JIDX_N_) = .TRUE. ;   LLSOUTHDIR (JIDX_N_) = .FALSE. 
  LLNORTHDIR (JIDX_S_) = .FALSE.;   LLSOUTHDIR (JIDX_S_) = .TRUE.
  LLNORTHDIR (JIDX___) = .FALSE.;   LLSOUTHDIR (JIDX___) = .FALSE.

  DO JJ = 1, 6

!$OMP PARALLEL DO PRIVATE (II, IDIR, IIND, IH)
    DO II = 1, YLHALO%ISIZE
      IDIR = IIDX (JJ)
      IIND = II
      DO IH = 1, KH_WIDTH

        IF (YLHALO%JNEIGHBOURS (IDIR, IIND) == 0) THEN
          WRITE (0, *) II, CLXX (JJ)
          WRITE (0, *)  " JLAT = ", YLHALO%JLAT (IIND), " JLON = ", YLHALO%JLON (IIND)
          CALL ABOR1 ('DEMO_HALO1: INDEX OUT OF BOUNDS')
        ENDIF

        IIND = YLHALO%JNEIGHBOURS (IDIR, IIND)

        ! Cross the pole region: change orientation
        IF (YLHALO%JLAT (IIND) == JNORTHLAT .AND. LLNORTHDIR (IDIR)) THEN
          IDIR = IINV (IDIR)
        ELSEIF (YLHALO%JLAT (IIND) == JSOUTHLAT .AND. LLSOUTHDIR (IDIR)) THEN
          IDIR = IINV (IDIR)
        ENDIF

      ENDDO
      ZGPBUFL (II) = ZGPBUFL_H (IIND, 1)
    ENDDO
!$OMP END PARALLEL DO

    IF (LDPRINT) THEN
      WRITE (CLFILENAME, '(A2,".",I3.3)') CLXX (JJ), KH_WIDTH
      CALL GMSH (ZGPBUFL, IGPTOT, TRIM (CLFILENAME)//".msh", YDGRID, YDDIST)
      CALL WFA (ZGPBUFL, IGPTOT, 1_JPIM, "HALO.fa", ["SURF"], &
              & [0_JPIM], [TRIM (CLFILENAME)], YDGRID, YDDIST)
    ENDIF

  ENDDO

ENDBLOCK

IF (LHOOK) CALL DR_HOOK ('DEMO_HALO1',1,ZHOOK_HANDLE)

END SUBROUTINE

SUBROUTINE CREATE_HALO (YDGRID, YDDIST, KSIZE, YDHALO, YDREG)

TYPE (GRID_t),       INTENT (IN)  :: YDGRID
TYPE (DIST_t),       INTENT (IN)  :: YDDIST
INTEGER (KIND=JPIM), INTENT (IN)  :: KSIZE
TYPE (HALO_t),       INTENT (OUT) :: YDHALO
TYPE (REGION_t),     INTENT (IN), OPTIONAL, TARGET :: YDREG

TYPE (REGION_t), ALLOCATABLE :: YLREG_H (:)
INTEGER (KIND=JPIM) :: ISIZE
TYPE (REGION_t), TARGET :: YLMYREGION
TYPE (REGION_t), POINTER :: YLREG
REAL(KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK ('CREATE_HALO',0,ZHOOK_HANDLE)

IF (PRESENT (YDREG)) THEN
  YLREG => YDREG
ELSE
  CALL GET_MYREGION (YLMYREGION, YDDIST, YDGRID)
  YLREG => YLMYREGION
ENDIF

ALLOCATE (YLREG_H (KSIZE))

CALL HALO_FROM_REGION (YLREG, YDGRID, YDDIST, YLREG_H (1))

DO ISIZE = 2, KSIZE
  CALL HALO_FROM_REGION (YLREG_H (ISIZE-1), YDGRID, YDDIST, YLREG_H (ISIZE))
ENDDO

CALL HALO_BUILD_INDEX (YLREG, YLREG_H (KSIZE), YDGRID, YDDIST, YDHALO)

IF (LHOOK) CALL DR_HOOK ('CREATE_HALO',1,ZHOOK_HANDLE)

END SUBROUTINE


SUBROUTINE GET_MYREGION (YDREG, YDDIST, YDGRID)

USE MPL_MODULE,        ONLY : MPL_MYRANK, MPL_NUMPROC

TYPE (REGION_t), INTENT (OUT) :: YDREG
TYPE (DIST_t),   INTENT (IN)  :: YDDIST
TYPE (GRID_t),   INTENT (IN)  :: YDGRID

#include "abor1.intfb.h"

INTEGER (KIND=JPIM) :: JA, JB, JLAT, IGL, MYPROC
REAL(KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK ('GET_MYREGION',0,ZHOOK_HANDLE)

MYPROC = MPL_MYRANK ()
JA = YDDIST%NGPPE2SET (1, MYPROC)
JB = YDDIST%NGPPE2SET (2, MYPROC)

YDREG%NLAN = 0
YDREG%NLAS = 0

DO JLAT = YDDIST%NFRSTLAT(JA), YDDIST%NLSTLAT(JA)
  IGL = YDDIST%NPTRFRSTLAT(JA)+JLAT-YDDIST%NFRSTLAT(JA)

  IF (YDREG%NLAN == 0 .AND. YDDIST%NSTA (IGL, JB) >= 1 .AND. YDDIST%NONL (IGL, JB) >= 1) THEN
    YDREG%NLAN = JLAT
  ENDIF

  IF (YDDIST%NSTA (IGL, JB) >= 1 .AND. YDDIST%NONL (IGL, JB) >= 1) THEN
    YDREG%NLAS = JLAT
  ENDIF  

ENDDO

ALLOCATE (YDREG%NLOW (YDREG%NLAN:YDREG%NLAS), &
        & YDREG%NLOE (YDREG%NLAN:YDREG%NLAS))


DO JLAT = YDREG%NLAN, YDREG%NLAS
  IGL = YDDIST%NPTRFRSTLAT(JA)+JLAT-YDDIST%NFRSTLAT(JA)
  YDREG%NLOW (JLAT) = YDDIST%NSTA (IGL, JB)
  YDREG%NLOE (JLAT) = YDREG%NLOW (JLAT) + YDDIST%NONL (IGL, JB) - 1
ENDDO



IF (ANY (YDREG%NLOE (YDREG%NLAN:YDREG%NLAS) > YDGRID%NLOEN (YDREG%NLAN:YDREG%NLAS))) &
  & CALL ABOR1 ('GET_MYREGION:')

IF (LHOOK) CALL DR_HOOK ('GET_MYREGION',1,ZHOOK_HANDLE)

END SUBROUTINE

SUBROUTINE CREATE_GRID_DIST_FA (YDGRID, YDDIST, CDFILENAME, YDGROPT)

USE FA_MOD, ONLY : FA_COM_DEFAULT, &
                 & NEW_FA_DEFAULT, FACADR

TYPE (GRID_t),         INTENT (OUT) :: YDGRID
TYPE (DIST_t),         INTENT (OUT) :: YDDIST
CHARACTER (LEN=*),     INTENT (IN)  :: CDFILENAME
TYPE (GRID_OPTIONS_t), INTENT (IN), OPTIONAL :: YDGROPT


#include "abor1.intfb.h"

TYPE (GRID_OPTIONS_t) :: YLGROPT
CHARACTER (LEN=*), PARAMETER :: CLNOMC = 'c'
INTEGER (KIND=JPIM)   :: ILUN, IREP, INBARP, INBARI


IF (PRESENT (YDGROPT)) THEN
  YLGROPT = YDGROPT
ENDIF

ILUN = 77_JPIM
CALL FAITOU (IREP, ILUN, .TRUE., TRIM (CDFILENAME), 'OLD', &
           & .TRUE., .TRUE., 2_JPIM, INBARP, INBARI, CLNOMC)

BLOCK
  INTEGER (KIND=JPIM) :: IRANGC
  TYPE (FACADR), POINTER :: YLCADR 
  CALL FANUCA (CLNOMC, IRANGC, .FALSE.)
  YLCADR => FA_COM_DEFAULT%CADRE (IRANGC)

  YLGROPT%NDGLG = YLCADR%NLATIT
  YLGROPT%NSMAX = YLCADR%MTRONC

  IF (MODULO (YLGROPT%NDGLG, 2) == 0) THEN
    YLGROPT%NLOEN (1:YLGROPT%NDGLG/2) = YLCADR%NLOPAR (1:YLGROPT%NDGLG)
    YLGROPT%NLOEN (YLGROPT%NDGLG/2+1:YLGROPT%NDGLG) = YLGROPT%NLOEN (YLGROPT%NDGLG/2:1:-1)
  ELSE
    CALL ABOR1 ('UNEXPECTED ODD NUMBER OF LATITUDES')
  ENDIF

  IF (YLCADR%NTYPTR == 2) THEN
    YLGROPT%LROTATED = .TRUE.
    YLGROPT%LSTRETCH = .TRUE.
    YLGROPT%RSTRETCH = YLCADR%SCODIL
    YLGROPT%RLATCENT = RAD2DEG * ASIN (YLCADR%SSLAPO)
    YLGROPT%RLONCENT = RAD2DEG * ATAN2 (YLCADR%SSLOPO, YLCADR%SCLOPO)
  ENDIF

ENDBLOCK

CALL FAIRME (IREP, ILUN, 'KEEP')

CALL NEW_GRID_DIST (YDGRID, YDDIST, YLGROPT)

END SUBROUTINE


SUBROUTINE prepareDist(YDGRID,YDDIST,nglobalproc)

TYPE (GRID_t),         INTENT (IN) :: YDGRID
TYPE (DIST_t),         INTENT (IN) :: YDDIST
INTEGER (KIND=JPIM),DIMENSION(YDGRID%NGPTOTG),INTENT(INOUT) :: nglobalproc


INTEGER (KIND=JPIM) :: JA, JB,JLON, JLAT,IPT
IPT=1
DO JLAT=1,YDGRID%NDGLG
 DO JLON=1,YDGRID%NLOEN(JLAT)
  CALL JLONJLAT_TO_JAJB (JLON, JLAT, YDDIST, JA, JB)
  nglobalproc(IPT)=YDDIST%NGPSET2PE (JA, JB)
  IPT=IPT+1
 ENDDO
ENDDO


END SUBROUTINE
SUBROUTINE CREATE_GRID_DIST (YDGRID, YDDIST, YDGROPT)

TYPE (GRID_t),         INTENT (OUT) :: YDGRID
TYPE (DIST_t),         INTENT (OUT) :: YDDIST
TYPE (GRID_OPTIONS_t), INTENT (IN)  :: YDGROPT
IF (YDGROPT%LATLON) THEN
  CALL NEW_GRID_DIST_LATLON (YDGRID, YDDIST, YDGROPT)
ELSE
  CALL NEW_GRID_DIST (YDGRID, YDDIST, YDGROPT)
ENDIF

END SUBROUTINE

SUBROUTINE NEW_GRID_DIST_LATLON (YDGRID, YDDIST, YDGROPT)

USE MPL_MODULE, ONLY : MPL_NUMPROC

TYPE (GRID_t),         INTENT (OUT) :: YDGRID
TYPE (DIST_t),         INTENT (OUT) :: YDDIST
TYPE (GRID_OPTIONS_t), INTENT (IN)  :: YDGROPT

INTEGER (KIND=JPIM) :: JA, JB, IPROC, IGPTOT
INTEGER (KIND=JPIM) :: JLON, JLAT, JLON1, JLAT1, JLON2, JLAT2
INTEGER (KIND=JPIM) :: JLAT_NORTH, JLAT_CANCE, JLAT_CAPRI, JLAT_SOUTH
REAL(KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK ('NEW_GRID_DIST_LATLON',0,ZHOOK_HANDLE)

YDDIST%LEQ_REGIONS = .FALSE.

YDGRID%NDGLG = YDGROPT%NDGLG
YDGRID%NGPTOTG = YDGROPT%NDLON * YDGRID%NDGLG
YDGRID%RLONOFF = YDGROPT%RLONOFF * DEG2RAD



IF (YDGROPT%LSHIFTLON) THEN
  YDGRID%RLONOFF = YDGRID%RLONOFF + RPI / YDGROPT%NDLON
ENDIF

ALLOCATE (YDGRID%RMU (YDGRID%NDGLG), YDGRID%NLOEN (YDGRID%NDGLG))

YDGRID%NLOEN = YDGROPT%NDLON

YDGRID%RMU = [(SIN (RPI / 2._JPRB - REAL (JLAT-1, JPRB) * RPI / REAL (YDGROPT%NDGLG - 1, JPRB)), &
               & JLAT = 1, YDGROPT%NDGLG)]


YDDIST%NPROC = MPL_NUMPROC 

YDDIST%LEQ_REGIONS = .TRUE.

IF (YDDIST%LEQ_REGIONS .AND. (YDDIST%NPROC > 2)) THEN

  IGPTOT = YDGRID%NGPTOTG / YDDIST%NPROC


  IF (YDGROPT%LZONAL) THEN

    YDDIST%N_REGIONS_NS = YDDIST%NPROC
    YDDIST%N_REGIONS_EW = 1

  ELSE

    JA = INT (SQRT (REAL (((YDDIST%NPROC-2) * YDGROPT%NDLON) / YDGRID%NDGLG, JPRB))) + 1
    
    DO
      JB = (YDDIST%NPROC-2) / JA
      IF (JA * JB == (YDDIST%NPROC-2)) EXIT
      JA = JA - 1
    ENDDO
   
    YDDIST%N_REGIONS_NS = JA + 2
    YDDIST%N_REGIONS_EW = JB

  ENDIF
  
  
  ALLOCATE (YDDIST%N_REGIONS (YDDIST%N_REGIONS_NS))

  YDDIST%N_REGIONS  = [1, (YDDIST%N_REGIONS_EW, JA = 2, YDDIST%N_REGIONS_NS-1), 1]
  
  
  ALLOCATE (YDDIST%NGPTOTL (YDDIST%NPROC))
  
  ALLOCATE (YDDIST%NGPSET2PE (YDDIST%N_REGIONS_NS, YDDIST%N_REGIONS_EW), &
          & YDDIST%NGPPE2SET (2, YDDIST%NPROC))
  
  ALLOCATE (YDDIST%NFRSTLAT (YDDIST%N_REGIONS_NS), YDDIST%NLSTLAT (YDDIST%N_REGIONS_NS), &
          & YDDIST%NPTRFRSTLAT (YDDIST%N_REGIONS_NS))
  ALLOCATE (YDDIST%NSTA (YDGRID%NDGLG+YDDIST%N_REGIONS_NS,YDDIST%N_REGIONS_EW), &
          & YDDIST%NONL (YDGRID%NDGLG+YDDIST%N_REGIONS_NS,YDDIST%N_REGIONS_EW))
  
  JLAT_NORTH = 1 
  JLAT_CANCE = IGPTOT / YDGROPT%NDLON 
  JLAT_CAPRI = YDGRID%NDGLG - IGPTOT / YDGROPT%NDLON + 1 
  JLAT_SOUTH = YDGRID%NDGLG

  IPROC = 1; JA = 1; JB = 1

  JLAT1 = JLAT_NORTH; JLAT2 = JLAT_CANCE; JLON1 = 1; JLON2 = YDGROPT%NDLON

  YDDIST%NFRSTLAT (JA) = JLAT1
  YDDIST%NLSTLAT  (JA) = JLAT2
  YDDIST%NPTRFRSTLAT (JA) = 1
  YDDIST%NGPSET2PE (JA, JB) = IPROC
  YDDIST%NGPPE2SET (1:2, IPROC) = [JA, JB]
  YDDIST%NGPTOTL (IPROC) = (JLAT2 - JLAT1 + 1) * (JLON2 - JLON1 + 1)
  
  YDDIST%NSTA (JLAT1:JLAT2, JB) = JLON1
  YDDIST%NONL (JLAT1:JLAT2, JB) = JLON2 - JLON1 + 1
  
  IPROC = IPROC + 1

  DO JA = 2, YDDIST%N_REGIONS_NS-1
    JLAT1 = JLAT_CANCE + 1 + 0 + ((JA - 2) * (JLAT_CAPRI - 1 - JLAT_CANCE - 1 + 1)) / (YDDIST%N_REGIONS_NS-2)
    JLAT2 = JLAT_CANCE + 1 - 1 + ((JA - 1) * (JLAT_CAPRI - 1 - JLAT_CANCE - 1 + 1)) / (YDDIST%N_REGIONS_NS-2)
    
    YDDIST%NFRSTLAT (JA) = JLAT1
    YDDIST%NLSTLAT  (JA) = JLAT2
    YDDIST%NPTRFRSTLAT (JA) = JLAT1
  
    DO JB = 1, YDDIST%N_REGIONS_EW

      JLON1 = 1 + ((JB - 1) * YDGROPT%NDLON) / YDDIST%N_REGIONS_EW
      JLON2 =     ((JB + 0) * YDGROPT%NDLON) / YDDIST%N_REGIONS_EW

      YDDIST%NGPSET2PE (JA, JB) = IPROC
      YDDIST%NGPPE2SET (1:2, IPROC) = [JA, JB]
      YDDIST%NGPTOTL (IPROC) = (JLAT2 - JLAT1 + 1) * (JLON2 - JLON1 + 1)
  
      YDDIST%NSTA (JLAT1:JLAT2, JB) = JLON1
      YDDIST%NONL (JLAT1:JLAT2, JB) = JLON2 - JLON1 + 1
  
      IPROC = IPROC + 1
    ENDDO
  ENDDO

  JLAT1 = JLAT_CAPRI; JLAT2 = JLAT_SOUTH; JLON1 = 1; JLON2 = YDGROPT%NDLON
  IPROC = YDDIST%NPROC; JA = YDDIST%N_REGIONS_NS; JB = 1

  YDDIST%NFRSTLAT (JA) = JLAT1
  YDDIST%NLSTLAT  (JA) = JLAT2
  YDDIST%NPTRFRSTLAT (JA) = 1
  YDDIST%NGPSET2PE (JA, JB) = IPROC
  YDDIST%NGPPE2SET (1:2, IPROC) = [JA, JB]
  YDDIST%NGPTOTL (IPROC) = (JLAT2 - JLAT1 + 1) * (JLON2 - JLON1 + 1)
  
  YDDIST%NSTA (JLAT1:JLAT2, JB) = JLON1
  YDDIST%NONL (JLAT1:JLAT2, JB) = JLON2 - JLON1 + 1

  

ELSE
  YDDIST%LEQ_REGIONS = .FALSE.


  JA = INT (SQRT (REAL ((YDDIST%NPROC * YDGROPT%NDLON) / YDGRID%NDGLG, JPRB))) + 1
  DO
    JB = YDDIST%NPROC / JA
    IF (JA * JB == YDDIST%NPROC) EXIT
    JA = JA - 1
  ENDDO
  
  
  YDDIST%N_REGIONS_NS = JA
  YDDIST%N_REGIONS_EW = JB
  
  
  ALLOCATE (YDDIST%N_REGIONS (YDDIST%N_REGIONS_NS))
  
  YDDIST%N_REGIONS = YDDIST%N_REGIONS_EW
  
  ALLOCATE (YDDIST%NGPTOTL (YDDIST%NPROC))
  
  ALLOCATE (YDDIST%NGPSET2PE (YDDIST%N_REGIONS_NS, YDDIST%N_REGIONS_EW), &
          & YDDIST%NGPPE2SET (2, YDDIST%NPROC))
  
  ALLOCATE (YDDIST%NFRSTLAT (YDDIST%N_REGIONS_NS), YDDIST%NLSTLAT (YDDIST%N_REGIONS_NS), &
          & YDDIST%NPTRFRSTLAT (YDDIST%N_REGIONS_NS))
  ALLOCATE (YDDIST%NSTA (YDGRID%NDGLG+YDDIST%N_REGIONS_NS,YDDIST%N_REGIONS_EW), &
          & YDDIST%NONL (YDGRID%NDGLG+YDDIST%N_REGIONS_NS,YDDIST%N_REGIONS_EW))
  
  IPROC = 1
  DO JA = 1, YDDIST%N_REGIONS_NS
    JLAT1 = 1 + ((JA - 1) * YDGRID%NDGLG) / YDDIST%N_REGIONS_NS
    JLAT2 =     ((JA + 0) * YDGRID%NDGLG) / YDDIST%N_REGIONS_NS
  
    YDDIST%NFRSTLAT (JA) = JLAT1
    YDDIST%NLSTLAT  (JA) = JLAT2
    YDDIST%NPTRFRSTLAT (JA) = 1
  
    DO JB = 1, YDDIST%N_REGIONS_EW
      JLON1 = 1 + ((JB - 1) * YDGROPT%NDLON) / YDDIST%N_REGIONS_EW
      JLON2 =     ((JB + 0) * YDGROPT%NDLON) / YDDIST%N_REGIONS_EW
      YDDIST%NGPSET2PE (JA, JB) = IPROC
      YDDIST%NGPPE2SET (1:2, IPROC) = [JA, JB]
      YDDIST%NGPTOTL (IPROC) = (JLAT2 - JLAT1 + 1) * (JLON2 - JLON1 + 1)
  
      YDDIST%NSTA (1:YDGRID%NDGLG, JB) = JLON1
      YDDIST%NONL (1:YDGRID%NDGLG, JB) = JLON2 - JLON1 + 1
  
      IPROC = IPROC + 1
    ENDDO
  ENDDO

ENDIF

IF (LHOOK) CALL DR_HOOK ('NEW_GRID_DIST_LATLON',1,ZHOOK_HANDLE)

END SUBROUTINE

SUBROUTINE NEW_GRID_DIST (YDGRID, YDDIST, YDGROPT)

USE MPL_ALLGATHERV_MOD, ONLY : MPL_ALLGATHERV
USE MPL_MODULE,         ONLY : MPL_NUMPROC, MPL_MYRANK
USE SET2PE_MOD,         ONLY : SET2PE
USE TPM_DISTR,          ONLY : LEQ_REGIONS

TYPE (GRID_t),         INTENT (OUT) :: YDGRID
TYPE (DIST_t),         INTENT (OUT) :: YDDIST
TYPE (GRID_OPTIONS_t), INTENT (IN)  :: YDGROPT

INTEGER (KIND=JPIM) :: JA, JB, IPROC, MYPROC
INTEGER (KIND=JPIM), ALLOCATABLE :: IGPTOTL (:,:)

#include "setup_trans.h"
#include "trans_inq.h"

REAL(KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK ('NEW_GRID_DIST',0,ZHOOK_HANDLE)

MYPROC = MPL_MYRANK ()

YDGRID%RLONOFF = YDGROPT%RLONOFF * DEG2RAD
CALL SETUP_TRANS (KSMAX=YDGROPT%NSMAX, KDGL=YDGROPT%NDGLG,      &
                & KLOEN=YDGROPT%NLOEN (1:YDGROPT%NDGLG),        &
                & LDSPLIT=YDGROPT%LSPLIT, KRESOL=YDDIST%NRESOL, &
                & LDGRIDONLY=YDGROPT%LGRIDONLY)

YDDIST%LEQ_REGIONS = LEQ_REGIONS
YDDIST%NPROC       = MPL_NUMPROC
CALL TRANS_INQ (K_REGIONS_NS=YDDIST%N_REGIONS_NS, KRESOL=YDDIST%NRESOL)
ALLOCATE (YDDIST%N_REGIONS (YDDIST%N_REGIONS_NS))
CALL TRANS_INQ (K_REGIONS=YDDIST%N_REGIONS, KRESOL=YDDIST%NRESOL)
CALL TRANS_INQ (K_REGIONS_EW=YDDIST%N_REGIONS_EW, KRESOL=YDDIST%NRESOL)

ALLOCATE (IGPTOTL (YDDIST%N_REGIONS_NS, YDDIST%N_REGIONS_EW))
CALL TRANS_INQ (KGPTOTL=IGPTOTL, KRESOL=YDDIST%NRESOL)

ALLOCATE (YDDIST%NGPTOTL (YDDIST%NPROC))

ALLOCATE (YDDIST%NGPSET2PE (YDDIST%N_REGIONS_NS, YDDIST%N_REGIONS_EW), &
        & YDDIST%NGPPE2SET (2, YDDIST%NPROC))

DO JA =1, YDDIST%N_REGIONS_NS
  DO JB = 1, YDDIST%N_REGIONS (JA)
    CALL SET2PE (YDDIST%NGPSET2PE (JA, JB), JA, JB, 0, 0)
    YDDIST%NGPPE2SET (1:2, YDDIST%NGPSET2PE (JA, JB)) = [JA, JB]
    YDDIST%NGPTOTL (YDDIST%NGPSET2PE (JA, JB)) = IGPTOTL (JA, JB)
  ENDDO
  DO JB = YDDIST%N_REGIONS (JA) + 1, YDDIST%N_REGIONS_EW
    YDDIST%NGPSET2PE (JA, JB) = 0
  ENDDO
ENDDO

CALL TRANS_INQ (KGPTOTG=YDGRID%NGPTOTG, KRESOL=YDDIST%NRESOL)

YDGRID%NDGLG = YDGROPT%NDGLG
YDGRID%NSMAX = YDGROPT%NSMAX

ALLOCATE (YDDIST%NFRSTLAT (YDDIST%N_REGIONS_NS), YDDIST%NLSTLAT (YDDIST%N_REGIONS_NS), &
        & YDDIST%NPTRFRSTLAT (YDDIST%N_REGIONS_NS))
ALLOCATE (YDDIST%NSTA (YDGRID%NDGLG+YDDIST%N_REGIONS_NS,YDDIST%N_REGIONS_EW), &
        & YDDIST%NONL (YDGRID%NDGLG+YDDIST%N_REGIONS_NS,YDDIST%N_REGIONS_EW))
ALLOCATE (YDGRID%RMU (YDGRID%NDGLG), YDGRID%NLOEN (YDGRID%NDGLG))

CALL TRANS_INQ (PMU=YDGRID%RMU, KRESOL=YDDIST%NRESOL)
CALL TRANS_INQ (KFRSTLAT=YDDIST%NFRSTLAT, KRESOL=YDDIST%NRESOL)
CALL TRANS_INQ (KLSTLAT=YDDIST%NLSTLAT, KRESOL=YDDIST%NRESOL)
CALL TRANS_INQ (KPTRFRSTLAT=YDDIST%NPTRFRSTLAT, KRESOL=YDDIST%NRESOL)
CALL TRANS_INQ (KSTA=YDDIST%NSTA, KRESOL=YDDIST%NRESOL)
CALL TRANS_INQ (KONL=YDDIST%NONL, KRESOL=YDDIST%NRESOL)
CALL TRANS_INQ (KLOEN=YDGRID%NLOEN, KRESOL=YDDIST%NRESOL)


IF (.NOT. YDGROPT%LGRIDONLY) THEN
  ALLOCATE (YDDIST%NSPEC2L (YDDIST%NPROC))
  CALL TRANS_INQ (KSPEC2=YDDIST%NSPEC2L (MYPROC), KSPEC2G=YDGRID%NSPEC2G, KRESOL=YDDIST%NRESOL)
  CALL MPL_ALLGATHERV ([YDDIST%NSPEC2L (MYPROC)], YDDIST%NSPEC2L, [(1, IPROC = 1, YDDIST%NPROC)], &
                     & CDSTRING='NEW_GRID_DIST')
ENDIF

YDGRID%LROTATED = YDGROPT%LROTATED
YDGRID%LSTRETCH = YDGROPT%LSTRETCH
YDGRID%RSTRETCH = YDGROPT%RSTRETCH
YDGRID%RLONCENT = YDGROPT%RLONCENT * DEG2RAD
YDGRID%RLATCENT = YDGROPT%RLATCENT * DEG2RAD

CALL INIT_ROTATED_STRETCH (YDGRID)

IF (LHOOK) CALL DR_HOOK ('NEW_GRID_DIST',1,ZHOOK_HANDLE)

END SUBROUTINE

SUBROUTINE INIT_ROTATED_STRETCH (YDGRID)

TYPE (GRID_t), INTENT (INOUT) :: YDGRID

YDGRID%ZOMC2 = 1.0_JPRB - 1.0_JPRB / (YDGRID%RSTRETCH * YDGRID%RSTRETCH)
YDGRID%ZOPC2 = 1.0_JPRB + 1.0_JPRB / (YDGRID%RSTRETCH * YDGRID%RSTRETCH)

IF (YDGRID%LROTATED) THEN
  BLOCK
  REAL (KIND=JPRB) :: ZROT1 (3, 3)
  REAL (KIND=JPRB) :: ZROT2 (3, 3)

! Direct

  ZROT1 = ROTATE (+RPI / 2._JPRB - YDGRID%RLATCENT, (/ -SIN (YDGRID%RLONCENT), &
                & +COS (YDGRID%RLONCENT), 0.0_JPRB /))
  ZROT2 = ROTATE (+RPI + YDGRID%RLONCENT, (/ 0.0_JPRB, 0.0_JPRB, 1.0_JPRB /))

  YDGRID%ZROTD = MATMUL (ZROT1, ZROT2)

! Inverse

  ZROT1 = ROTATE (-RPI / 2._JPRB + YDGRID%RLATCENT, (/ -SIN (YDGRID%RLONCENT), &
                & +COS (YDGRID%RLONCENT), 0.0_JPRB /))
  ZROT2 = ROTATE (-RPI - YDGRID%RLONCENT, (/ 0.0_JPRB, 0.0_JPRB, 1.0_JPRB /))
   
  YDGRID%ZROTI = MATMUL (ZROT2, ZROT1)

  BLOCK
   REAL (KIND=JPRB) :: ZCOSLON, ZSINLON, ZCOSLAT, ZSINLAT

   ZSINLON = SIN (YDGRID%RLONCENT); ZCOSLON = COS (YDGRID%RLONCENT)
   ZSINLAT = SIN (YDGRID%RLATCENT); ZCOSLAT = COS (YDGRID%RLATCENT)

  ENDBLOCK

  END BLOCK
ELSE
  YDGRID%ZROTD (1:3,1) = (/ 1._JPRB, 0._JPRB, 0._JPRB /)
  YDGRID%ZROTD (1:3,2) = (/ 0._JPRB, 1._JPRB, 0._JPRB /)
  YDGRID%ZROTD (1:3,3) = (/ 0._JPRB, 0._JPRB, 1._JPRB /)
  YDGRID%ZROTI = YDGRID%ZROTD
ENDIF

END SUBROUTINE

SUBROUTINE JLONJLAT_TO_JAJB (KLON, KLAT, YDDIST, KA, KB)

INTEGER (KIND=JPIM), INTENT (IN)    :: KLON, KLAT
TYPE (DIST_t),       INTENT (IN)    :: YDDIST
INTEGER (KIND=JPIM), INTENT (INOUT) :: KA, KB

INTEGER (KIND=JPIM) :: JA, JB, IGL, JGL, JL

#include "abor1.intfb.h"

JA = KA; JB = KB; KA = -1; KB = -1

IF ((1 <= JA) .AND. (JA <= YDDIST%N_REGIONS_NS)) THEN
  IF ((YDDIST%NFRSTLAT (JA) <= KLAT) .AND. (KLAT <= YDDIST%NLSTLAT (JA))) THEN
    IGL = YDDIST%NPTRFRSTLAT (JA) + KLAT - YDDIST%NFRSTLAT (JA)
    IF ((1 <= JB) .AND. (JB <= YDDIST%N_REGIONS_EW)) THEN
      IF ((YDDIST%NSTA (IGL, JB) <= KLON) .AND. (KLON <= YDDIST%NSTA (IGL, JB) + YDDIST%NONL (IGL, JB) - 1)) GOTO 222
    ENDIF
  ENDIF
ENDIF

DO JA = 1, YDDIST%N_REGIONS_NS
  IF ((YDDIST%NFRSTLAT (JA) <= KLAT) .AND. (KLAT <= YDDIST%NLSTLAT (JA))) GOTO 111
ENDDO

GOTO 999

111 CONTINUE

DO 

  IGL = YDDIST%NPTRFRSTLAT (JA) + KLAT - YDDIST%NFRSTLAT (JA)

  DO JB = 1, YDDIST%N_REGIONS_EW
    IF ((YDDIST%NSTA (IGL, JB) <= KLON) .AND. (KLON <= YDDIST%NSTA (IGL, JB) + YDDIST%NONL (IGL, JB) - 1)) GOTO 222
  ENDDO

  IF (KLAT == YDDIST%NLSTLAT (JA)) THEN
    JA = JA + 1
  ELSE
    EXIT
  ENDIF

ENDDO

GOTO 999

222 CONTINUE

KA = JA
KB = JB

999 CONTINUE

IF (KA == -1 .OR. KB == -1) THEN
  CALL ABOR1 ('JLONJLAT_TO_JAJB: UNKNOWN JLON/JLAT')
ENDIF

END SUBROUTINE 

INTEGER (KIND=JPIM) FUNCTION REGION_SIZE (YDREG, YDGRID)

TYPE (REGION_t),     INTENT (IN) :: YDREG
TYPE (GRID_t),       INTENT (IN) :: YDGRID

INTEGER (KIND=JPIM) :: JLAT, ISIZE
REAL(KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK ('REGION_SIZE',0,ZHOOK_HANDLE)

ISIZE = 0

DO JLAT = YDREG%NLAN, YDREG%NLAS
  ISIZE = ISIZE + 1 + MODULO (YDREG%NLOE (JLAT) - YDREG%NLOW (JLAT), YDGRID%NLOEN (JLAT))
ENDDO

REGION_SIZE = ISIZE

IF (LHOOK) CALL DR_HOOK ('REGION_SIZE',1,ZHOOK_HANDLE)

END FUNCTION


SUBROUTINE DO_HALO (YDHALO, YDDIST, PGPBUFL)

USE MPL_MODULE,        ONLY : MPL_MYRANK, MPL_NUMPROC
USE MPL_DATA_MODULE,   ONLY : JP_NON_BLOCKING_STANDARD
USE MPL_MPIF,          ONLY : MPI_UNDEFINED
USE MPL_BARRIER_MOD,   ONLY : MPL_BARRIER
USE MPL_SEND_MOD,      ONLY : MPL_SEND
USE MPL_RECV_MOD,      ONLY : MPL_RECV
USE MPL_WAIT_MOD,      ONLY : MPL_WAIT
USE MPL_WAITANY_MOD,   ONLY : MPL_WAITANY

TYPE (HALO_t),    INTENT (IN)    :: YDHALO
TYPE (DIST_t),    INTENT (IN)    :: YDDIST
REAL (KIND=JPRB), INTENT (INOUT) :: PGPBUFL (:, :)

INTEGER (KIND=JPIM) :: IREQS (SIZE (YDHALO%YL_SEND))
INTEGER (KIND=JPIM) :: IREQR (SIZE (YDHALO%YL_RECV))
REAL (KIND=JPRB), ALLOCATABLE :: ZBUF (:)
INTEGER (KIND=JPIM) :: IR, IS, IOFFSET, ILENGTH, IGPTOT, MYPROC, JJ
INTEGER (KIND=JPIM) :: ISIZR, ISIZS, IOFFR, IOFFS, INFLD, JFLD
REAL(KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK ('DO_HALO',0,ZHOOK_HANDLE)

MYPROC = MPL_MYRANK ()
IGPTOT = YDDIST%NGPTOTL (MYPROC)

INFLD = SIZE (PGPBUFL, 2)

ISIZR = 0
DO IR = 1, SIZE (IREQR)
  ISIZR = ISIZR + YDHALO%YL_RECV (IR)%ILENGTH
ENDDO

ISIZS = 0
DO IS = 1, SIZE (IREQS)
  ISIZS = ISIZS + SIZE (YDHALO%YL_SEND (IS)%IINDEX)
ENDDO

ALLOCATE (ZBUF (INFLD * (ISIZR + ISIZS)))

IOFFR = 0
DO IR = 1, SIZE (IREQR)
  IOFFSET = IGPTOT + YDHALO%YL_RECV (IR)%IOFFSET
  ILENGTH = YDHALO%YL_RECV (IR)%ILENGTH
  CALL MPL_RECV (PBUF=ZBUF (IOFFR*INFLD+1:(IOFFR+ILENGTH)*INFLD), KSOURCE=YDHALO%YL_RECV (IR)%IPROC, &
               & KMP_TYPE=JP_NON_BLOCKING_STANDARD, KREQUEST=IREQR (IR), KTAG=103, CDSTRING='DO_HALO')
  IOFFR = IOFFR + ILENGTH
ENDDO

CALL MPL_BARRIER (CDSTRING='DO_HALO')

IOFFS = ISIZR
DO IS = 1, SIZE (IREQS)
  ILENGTH = SIZE (YDHALO%YL_SEND (IS)%IINDEX)
!$OMP PARALLEL DO PRIVATE (JFLD, JJ) COLLAPSE (2)
  DO JFLD = 1, INFLD
    DO JJ = 1, ILENGTH
      ZBUF (IOFFS*INFLD+ILENGTH*(JFLD-1)+JJ) = PGPBUFL (YDHALO%YL_SEND (IS)%IINDEX (JJ), JFLD)
    ENDDO
  ENDDO
!$OMP END PARALLEL DO
  CALL MPL_SEND (PBUF=ZBUF (IOFFS*INFLD+1:(IOFFS+ILENGTH)*INFLD), KDEST=YDHALO%YL_SEND (IS)%IPROC,   &
               & KMP_TYPE=JP_NON_BLOCKING_STANDARD, KREQUEST=IREQS (IS), KTAG=103, CDSTRING='DO_HALO')
  IOFFS = IOFFS + ILENGTH
ENDDO

CALL MPL_WAIT (KREQUEST=IREQS, CDSTRING='DO_HALO')

DO 
  CALL MPL_WAITANY (KREQUEST=IREQR, KINDEX=IR, CDSTRING='DO_HALO')

  IF (IR == MPI_UNDEFINED) EXIT
  
  IOFFR = SUM (YDHALO%YL_RECV (1:IR-1)%ILENGTH)

  IOFFSET = IGPTOT + YDHALO%YL_RECV (IR)%IOFFSET
  ILENGTH = YDHALO%YL_RECV (IR)%ILENGTH

!$OMP PARALLEL DO PRIVATE (JFLD, JJ) COLLAPSE (2)
  DO JFLD = 1, INFLD
    DO JJ = 1, ILENGTH
      PGPBUFL (IOFFSET+JJ,JFLD) = ZBUF (IOFFR*INFLD+ILENGTH*(JFLD-1)+JJ)
    ENDDO
  ENDDO
!$OMP END PARALLEL DO

ENDDO

IF (LHOOK) CALL DR_HOOK ('DO_HALO',1,ZHOOK_HANDLE)

END SUBROUTINE


SUBROUTINE HALO_BUILD_INDEX (YDREG, YDREG_H, YDGRID, YDDIST, YDHALO)

USE MPL_ALLTOALLV_MOD, ONLY : MPL_ALLTOALLV
USE MPL_MODULE,        ONLY : MPL_MYRANK, MPL_NUMPROC
USE MPL_DATA_MODULE,   ONLY : JP_NON_BLOCKING_STANDARD
USE MPL_BARRIER_MOD,   ONLY : MPL_BARRIER
USE MPL_SEND_MOD,      ONLY : MPL_SEND
USE MPL_RECV_MOD,      ONLY : MPL_RECV
USE MPL_WAIT_MOD,      ONLY : MPL_WAIT

TYPE (REGION_t),     INTENT (IN)  :: YDREG, YDREG_H
TYPE (GRID_t),       INTENT (IN)  :: YDGRID
TYPE (DIST_t),       INTENT (IN)  :: YDDIST
TYPE (HALO_t),       INTENT (OUT) :: YDHALO

INTEGER (KIND=JPIM) :: IH_SIZE, ISIZE, ISIZE_H
INTEGER (KIND=JPIM) :: JLON, JLAT
INTEGER (KIND=JPIM) :: INREG, INALL, INHAL
INTEGER (KIND=JPIM) :: JA, JB, II, IC, IPROC
INTEGER (KIND=JPIM) :: IRECV, ISEND, INREQ
INTEGER (KIND=JPIM) :: IOFFSET, ILENGTH, MYPROC
LOGICAL :: LLINREG
INTEGER (KIND=JPIM), ALLOCATABLE :: IINDEX_B2H (:), IINDEX_H2B (:)
INTEGER (KIND=JPIM), ALLOCATABLE :: ILOCOFF_H (:), ILOCOFF (:)
INTEGER (KIND=JPIM), ALLOCATABLE :: JH_LONLAT (:,:), IH_PRC (:)
INTEGER (KIND=JPIM), ALLOCATABLE :: IH_PRC_RECV (:), IH_PRC_SEND (:)
INTEGER (KIND=JPIM), ALLOCATABLE :: IORD (:)
INTEGER (KIND=JPIM), ALLOCATABLE :: IREQ (:)
TYPE (NEIGHBOURS1_t), ALLOCATABLE :: YLNGBR1 (:)

TYPE JLONLAT_t
  INTEGER (KIND=JPIM), ALLOCATABLE :: JLONLAT (:,:)
END TYPE JLONLAT_t

TYPE (JLONLAT_t), ALLOCATABLE :: YLJLONLAT (:)

LOGICAL :: LINBA
INTEGER (KIND=JPIM) :: JNEXT
INTEGER (KIND=JPIM) :: KLO, KLOEN, KLOW, KLOE
REAL(KIND=JPRB) :: ZHOOK_HANDLE, ZHOOK_HANDLE_1, ZHOOK_HANDLE_2

JNEXT (KLO, KLOEN) = 1 + MODULO (KLO, KLOEN)                                  ! Next longitude
LINBA (KLO, KLOW, KLOE, KLOEN) = ((KLOW <= KLO) .AND. (KLO <= KLOE)) &        ! Longitude index belongs to current band
      &  .OR. ((((1 <= KLO) .AND. (KLO <= KLOE)) &
      &  .OR. ((KLOW <= KLO) .AND. (KLO <= KLOEN))) .AND. (KLOE < KLOW))

IF (LHOOK) CALL DR_HOOK ('HALO_BUILD_INDEX',0,ZHOOK_HANDLE)

MYPROC = MPL_MYRANK ()

ISIZE   = REGION_SIZE (YDREG, YDGRID)
ISIZE_H = REGION_SIZE (YDREG_H, YDGRID)
IH_SIZE = ISIZE_H - ISIZE

YDHALO%IH_SIZE = IH_SIZE
YDHALO%ISIZE   = ISIZE


! Find JLON, JLAT, IPROC, and index in halo buffer for all points

INREG = 0
INHAL = 0
INALL = 0

ALLOCATE (IINDEX_B2H (ISIZE_H), IINDEX_H2B (ISIZE_H), &
        & JH_LONLAT (2,IH_SIZE), IH_PRC (IH_SIZE))

JA = -1; JB = -1

IF (LHOOK) CALL DR_HOOK ('HALO_BUILD_INDEX:1',0,ZHOOK_HANDLE_1)

DO JLAT = YDREG_H%NLAN, YDREG_H%NLAS
  JLON = YDREG_H%NLOW (JLAT)
  DO

    LLINREG = .FALSE.
    IF ((YDREG%NLAN <= JLAT) .AND. (JLAT <= YDREG%NLAS)) THEN
      IF (LINBA (JLON, YDREG%NLOW (JLAT), YDREG%NLOE (JLAT), YDGRID%NLOEN (JLAT))) THEN
        LLINREG = .TRUE.
      ENDIF
    ENDIF

    INALL = INALL + 1

    IF (LLINREG) THEN
      INREG = INREG + 1
      IINDEX_B2H (INREG) = INALL
    ELSE
      INHAL = INHAL + 1
      IINDEX_B2H (ISIZE + INHAL) = INALL
      JH_LONLAT (1,INHAL) = JLON
      JH_LONLAT (2,INHAL) = JLAT
      CALL JLONJLAT_TO_JAJB (JLON, JLAT, YDDIST, JA, JB)
      IH_PRC (INHAL) = YDDIST%NGPSET2PE (JA, JB)
    ENDIF

    IF (JLON == YDREG_H%NLOE (JLAT)) EXIT

    JLON = JNEXT (JLON, YDGRID%NLOEN (JLAT))
    
  ENDDO

ENDDO

CALL MPL_BARRIER (CDSTRING='HALO_BUILD_INDEX')

IF (LHOOK) CALL DR_HOOK ('HALO_BUILD_INDEX:1',1,ZHOOK_HANDLE_1)
IF (LHOOK) CALL DR_HOOK ('HALO_BUILD_INDEX:2',0,ZHOOK_HANDLE_1)
! Sort buffer indices by MPI task

ALLOCATE (IORD (IH_SIZE))

CALL QSORTI4 (IH_SIZE, IORD, IH_PRC)

IH_PRC (1:IH_SIZE)                 = IH_PRC (IORD)
JH_LONLAT (1:2,1:IH_SIZE)          = JH_LONLAT (1:2,IORD)
IINDEX_B2H (ISIZE+1:ISIZE+IH_SIZE) = IINDEX_B2H (ISIZE+IORD)

DO II = 1, ISIZE_H
  IINDEX_H2B (IINDEX_B2H (II)) = II
ENDDO

DEALLOCATE (IORD)

CALL MPL_BARRIER (CDSTRING='HALO_BUILD_INDEX')

IF (LHOOK) CALL DR_HOOK ('HALO_BUILD_INDEX:2',1,ZHOOK_HANDLE_1)
IF (LHOOK) CALL DR_HOOK ('HALO_BUILD_INDEX:3',0,ZHOOK_HANDLE_1)
! Transform neighbours JLON/JLAT in indices in halo buffer

ALLOCATE (ILOCOFF_H (YDREG_H%NLAN:YDREG_H%NLAS))

IF (LHOOK) CALL DR_HOOK ('HALO_BUILD_INDEX:3.0',0,ZHOOK_HANDLE_2)
ILOCOFF_H (YDREG_H%NLAN) = 0
DO JLAT = YDREG_H%NLAN+1, YDREG_H%NLAS
  ILOCOFF_H (JLAT) = ILOCOFF_H (JLAT-1) + 1 + &
     & MODULO (YDREG_H%NLOE (JLAT-1) - YDREG_H%NLOW (JLAT-1), YDGRID%NLOEN (JLAT-1))
ENDDO
IF (LHOOK) CALL DR_HOOK ('HALO_BUILD_INDEX:3.0',1,ZHOOK_HANDLE_2)

CALL FIND_NEIGHBOURS (YDREG_H, YDGRID, YLNGBR1)
ALLOCATE (YDHALO%JNEIGHBOURS (9,ISIZE_H))
ALLOCATE (YDHALO%JLON (ISIZE_H), YDHALO%JLAT (ISIZE_H))

IF (LHOOK) CALL DR_HOOK ('HALO_BUILD_INDEX:3.1',0,ZHOOK_HANDLE_2)
YDHALO%JNEIGHBOURS = 0_JPIM
IF (LHOOK) CALL DR_HOOK ('HALO_BUILD_INDEX:3.1',1,ZHOOK_HANDLE_2)

IF (LHOOK) CALL DR_HOOK ('HALO_BUILD_INDEX:3.2',0,ZHOOK_HANDLE_2)

!$OMP PARALLEL DO PRIVATE (II, IC, INALL, JLON, JLAT)

DO II = 1, SIZE (YLNGBR1)

  YDHALO%JLON (IINDEX_H2B (II)) = YLNGBR1 (II)%JLON (JIDX___)
  YDHALO%JLAT (IINDEX_H2B (II)) = YLNGBR1 (II)%JLAT (JIDX___)

  DO IC = 1, 9

    JLON = YLNGBR1 (II)%JLON (IC); JLAT = YLNGBR1 (II)%JLAT (IC)

    IF (JLON == 0) CYCLE

    IF ((YDREG_H%NLAN <= JLAT) .AND. (JLAT <= YDREG_H%NLAS)) THEN
      IF (LINBA (JLON, YDREG_H%NLOW (JLAT), YDREG_H%NLOE (JLAT), YDGRID%NLOEN (JLAT))) THEN
        INALL = ILOCOFF_H (JLAT) + 1 + MODULO (JLON-YDREG_H%NLOW (JLAT), YDGRID%NLOEN (JLAT))
        YDHALO%JNEIGHBOURS (IC, IINDEX_H2B (II)) = IINDEX_H2B (INALL)
      ENDIF
    ENDIF

  ENDDO

ENDDO

!$OMP END PARALLEL DO

IF (LHOOK) CALL DR_HOOK ('HALO_BUILD_INDEX:3.2',1,ZHOOK_HANDLE_2)

DEALLOCATE (ILOCOFF_H)

IF (LHOOK) CALL DR_HOOK ('HALO_BUILD_INDEX:3.3',0,ZHOOK_HANDLE_2)
CALL MPL_BARRIER (CDSTRING='HALO_BUILD_INDEX')
IF (LHOOK) CALL DR_HOOK ('HALO_BUILD_INDEX:3.3',1,ZHOOK_HANDLE_2)

IF (LHOOK) CALL DR_HOOK ('HALO_BUILD_INDEX:3',1,ZHOOK_HANDLE_1)
IF (LHOOK) CALL DR_HOOK ('HALO_BUILD_INDEX:4',0,ZHOOK_HANDLE_1)
! Exchange send/recv counts, indices

ALLOCATE (IH_PRC_RECV (YDDIST%NPROC), IH_PRC_SEND (YDDIST%NPROC))

DO IPROC = 1, YDDIST%NPROC
  IH_PRC_RECV (IPROC) = COUNT (IPROC == IH_PRC)
ENDDO

! Exchange counts

CALL MPL_ALLTOALLV (KSENDBUF=IH_PRC_RECV, KRECVBUF=IH_PRC_SEND, &
                  & KSENDCOUNTS=[(1,II=1,YDDIST%NPROC)], KRECVCOUNTS=[(1,II=1,YDDIST%NPROC)], &
                  & CDSTRING='HALO_BUILD_INDEX')

IRECV = COUNT (IH_PRC_RECV /= 0) ! Number of tasks current processor will receive data from
ISEND = COUNT (IH_PRC_SEND /= 0) ! Number of tasks current processor will send data to     

IF (LHOOK) CALL DR_HOOK ('HALO_BUILD_INDEX:4',1,ZHOOK_HANDLE_1)
IF (LHOOK) CALL DR_HOOK ('HALO_BUILD_INDEX:5',0,ZHOOK_HANDLE_1)

ALLOCATE (YDHALO%YL_SEND (ISEND), YDHALO%YL_RECV (IRECV), &
        & IREQ (ISEND+IRECV))

ALLOCATE (YLJLONLAT (ISEND))

IREQ = 0

ISEND = 1; IRECV = 1; IOFFSET = 0; INREQ = 0
DO IPROC = 1, YDDIST%NPROC
  IF (IH_PRC_RECV (IPROC) /= 0) THEN
! Receive struct
    YDHALO%YL_RECV (IRECV)%IPROC   = IPROC
    YDHALO%YL_RECV (IRECV)%ILENGTH = IH_PRC_RECV (IPROC)
    YDHALO%YL_RECV (IRECV)%IOFFSET = IOFFSET
    IOFFSET = IOFFSET + IH_PRC_RECV (IPROC)
    IRECV = IRECV + 1
  ENDIF
  IF (IH_PRC_SEND (IPROC) /= 0) THEN
! Send struct
    YDHALO%YL_SEND (ISEND)%IPROC = IPROC
    ALLOCATE (YLJLONLAT (ISEND)%JLONLAT (2,IH_PRC_SEND (IPROC)))
    INREQ = INREQ + 1
    CALL MPL_RECV (KBUF=YLJLONLAT (ISEND)%JLONLAT, KTAG=104, &
                 & KSOURCE=IPROC, KREQUEST=IREQ (INREQ),     &
                 & KMP_TYPE=JP_NON_BLOCKING_STANDARD,        &
                 & CDSTRING='HALO_BUILD_INDEX')
    ISEND = ISEND + 1
  ENDIF
ENDDO

CALL MPL_BARRIER ()

IF (LHOOK) CALL DR_HOOK ('HALO_BUILD_INDEX:5',1,ZHOOK_HANDLE_1)
IF (LHOOK) CALL DR_HOOK ('HALO_BUILD_INDEX:6',0,ZHOOK_HANDLE_1)

! Send lat/lon indices

IOFFSET = 0
DO IRECV = 1, SIZE (YDHALO%YL_RECV)
  IPROC = YDHALO%YL_RECV (IRECV)%IPROC
  ILENGTH = YDHALO%YL_RECV (IRECV)%ILENGTH
  IOFFSET = YDHALO%YL_RECV (IRECV)%IOFFSET
  INREQ = INREQ + 1
  CALL MPL_SEND (KBUF=JH_LONLAT (1:2,IOFFSET+1:IOFFSET+ILENGTH), KDEST=IPROC,   &
               & KMP_TYPE=JP_NON_BLOCKING_STANDARD, KREQUEST=IREQ (INREQ),      &
               & KTAG=104, CDSTRING='HALO_BUILD_INDEX')
ENDDO

! Should be replaced by a WAITANY

CALL MPL_WAIT (KREQUEST=IREQ (1:INREQ), CDSTRING='HALO_BUILD_INDEX')

ALLOCATE (ILOCOFF (YDREG%NLAN:YDREG%NLAS))

ILOCOFF (YDREG%NLAN) = 0
DO JLAT = YDREG%NLAN+1, YDREG%NLAS
  ILOCOFF (JLAT) = ILOCOFF (JLAT-1) + 1 + &
     & MODULO (YDREG%NLOE (JLAT-1) - YDREG%NLOW (JLAT-1), YDGRID%NLOEN (JLAT-1))
ENDDO

DO ISEND = 1, SIZE (YDHALO%YL_SEND)
  IPROC = YDHALO%YL_SEND (ISEND)%IPROC

  ISIZE = SIZE (YLJLONLAT (ISEND)%JLONLAT, 2)

  ALLOCATE (YDHALO%YL_SEND (ISEND)%IINDEX (ISIZE))

  DO II = 1, ISIZE
    JLON = YLJLONLAT (ISEND)%JLONLAT (1, II)
    JLAT = YLJLONLAT (ISEND)%JLONLAT (2, II)
    YDHALO%YL_SEND (ISEND)%IINDEX (II) = &
    & ILOCOFF (JLAT) + 1 + MODULO (JLON-YDREG%NLOW (JLAT), YDGRID%NLOEN (JLAT))
  ENDDO

  DEALLOCATE (YLJLONLAT (ISEND)%JLONLAT)

ENDDO

DEALLOCATE (ILOCOFF)

CALL MPL_BARRIER (CDSTRING='HALO_BUILD_INDEX')

IF (LHOOK) CALL DR_HOOK ('HALO_BUILD_INDEX:6',1,ZHOOK_HANDLE_1)

IF (LHOOK) CALL DR_HOOK ('HALO_BUILD_INDEX',1,ZHOOK_HANDLE)

END SUBROUTINE


SUBROUTINE HALO_FROM_REGION (YDREG, YDGRID, YDDIST, YDREG_H)

TYPE (REGION_t),     INTENT (IN)  :: YDREG
TYPE (GRID_t),       INTENT (IN)  :: YDGRID
TYPE (DIST_t),       INTENT (IN)  :: YDDIST
TYPE (REGION_t),     INTENT (OUT) :: YDREG_H

INTEGER (KIND=JPIM) :: JLAT

TYPE (NEIGHBOURS1_t) :: YLN1, YLN2

INTEGER (KIND=JPIM) :: KLO, KDLON1, KDLON2, KLOEN1, KLOEN2, IINCL
REAL(KIND=JPRB) :: ZHOOK_HANDLE

IINCL (KDLON1, KDLON2, KLOEN1, KLOEN2) = MODULO (KDLON2, KLOEN2) * KLOEN1 & !  Test if KDLON2 is wider than KDLON1 (KDLON1 < KDLON2, LINCL > 0)
                                     & - MODULO (KDLON1, KLOEN1) * KLOEN2


IF (LHOOK) CALL DR_HOOK ('HALO_FROM_REGION',0,ZHOOK_HANDLE)

YDREG_H%NLAN = MAX (YDREG%NLAN-1, 1)
YDREG_H%NLAS = MIN (YDREG%NLAS+1, YDGRID%NDGLG)

ALLOCATE (YDREG_H%NLOW (YDREG_H%NLAN:YDREG_H%NLAS), &
        & YDREG_H%NLOE (YDREG_H%NLAN:YDREG_H%NLAS))

! Northern row

IF (YDREG%NLAN > 1) THEN
  JLAT = YDREG_H%NLAN

  CALL FIND_NEIGHBOURS1 (JLAT+1, YDREG%NLOW (JLAT+1), YDGRID, YLN1)
  CALL FIND_NEIGHBOURS1 (JLAT+1, YDREG%NLOE (JLAT+1), YDGRID, YLN2)
  YDREG_H%NLOW (JLAT) = YLN1%JLON (JIDX_NE); YDREG_H%NLOE (JLAT) = YLN2%JLON (JIDX_NE)
  
  IF (IINCL (YDREG%NLOE (JLAT+1)-YDREG%NLOW (JLAT+1), &
    & YLN2%JLON (JIDX_NE)-YLN1%JLON (JIDX_NW), YDGRID%NLOEN (JLAT+1), YDGRID%NLOEN (JLAT)) > 0) THEN
    CALL GROW_ZONAL_BAND (JLAT, &
                        & YDGRID%NLOEN (JLAT), YDREG_H%NLOW (JLAT), YDREG_H%NLOE (JLAT), &
                        & YDGRID%NLOEN (JLAT), YLN1%JLON (JIDX_NW), YLN2%JLON (JIDX_NE))
  ELSE
    CALL FULL_ZONAL_BAND (JLAT, YDGRID, YDREG_H)
  ENDIF
ENDIF

! Southern row

IF (YDREG%NLAS < YDGRID%NDGLG) THEN
  JLAT = YDREG_H%NLAS

  CALL FIND_NEIGHBOURS1 (JLAT-1, YDREG%NLOW (JLAT-1), YDGRID, YLN1)
  CALL FIND_NEIGHBOURS1 (JLAT-1, YDREG%NLOE (JLAT-1), YDGRID, YLN2)
  YDREG_H%NLOW (JLAT) = YLN1%JLON (JIDX_SE); YDREG_H%NLOE (JLAT) = YLN2%JLON (JIDX_SE)

  IF (IINCL (YDREG%NLOE (JLAT-1)-YDREG%NLOW (JLAT-1), &
    & YLN2%JLON (JIDX_SE)-YLN1%JLON (JIDX_SW), YDGRID%NLOEN (JLAT-1), YDGRID%NLOEN (JLAT)) > 0) THEN
    CALL GROW_ZONAL_BAND (JLAT, &
                        & YDGRID%NLOEN (JLAT), YDREG_H%NLOW (JLAT), YDREG_H%NLOE (JLAT), &
                        & YDGRID%NLOEN (JLAT), YLN1%JLON (JIDX_SW), YLN2%JLON (JIDX_SE))
  ELSE
    CALL FULL_ZONAL_BAND (JLAT, YDGRID, YDREG_H)
  ENDIF
ENDIF

! Other rows

DO JLAT = YDREG%NLAN, YDREG%NLAS
  YDREG_H%NLOW (JLAT) = YDREG%NLOW (JLAT); YDREG_H%NLOE (JLAT) = YDREG%NLOE (JLAT)
  CALL FIND_NEIGHBOURS1 (JLAT, YDREG%NLOW (JLAT), YDGRID, YLN1); CALL FIND_NEIGHBOURS1 (JLAT, YDREG%NLOE (JLAT), YDGRID, YLN2)
  IF (IINCL (YDREG%NLOE (JLAT)-YDREG%NLOW (JLAT), &
    & YLN2%JLON (JIDX__E)-YLN1%JLON (JIDX__W), YDGRID%NLOEN (JLAT), YDGRID%NLOEN (JLAT)) > 0) THEN
    CALL GROW_ZONAL_BAND (JLAT, &
                        & YDGRID%NLOEN (JLAT), YDREG_H%NLOW (JLAT), YDREG_H%NLOE (JLAT), &
                        & YDGRID%NLOEN (JLAT), YLN1%JLON (JIDX__W), YLN2%JLON (JIDX__E))
  ELSE
    CALL FULL_ZONAL_BAND (JLAT, YDGRID, YDREG_H)
  ENDIF
ENDDO

! Second pass : see whether rows before/after current row require an extension

DO JLAT = YDREG%NLAN, YDREG%NLAS

  CALL FIND_NEIGHBOURS1 (JLAT, YDREG%NLOW (JLAT), YDGRID, YLN1); CALL FIND_NEIGHBOURS1 (JLAT, YDREG%NLOE (JLAT), YDGRID, YLN2)

  IF (JLAT > 1) THEN
    IF (IINCL (YDREG%NLOE (JLAT)-YDREG%NLOW (JLAT), &
      & YLN2%JLON (JIDX_NE)-YLN1%JLON (JIDX_NW), YDGRID%NLOEN (JLAT), YDGRID%NLOEN (JLAT-1)) > 0) THEN
      CALL GROW_ZONAL_BAND (JLAT-1, &
                          & YDGRID%NLOEN (JLAT-1), YDREG_H%NLOW (JLAT-1), YDREG_H%NLOE (JLAT-1), &
                          & YDGRID%NLOEN (JLAT-1), YLN1%JLON (JIDX_NW), YLN2%JLON (JIDX_NE))
    ELSE
      CALL FULL_ZONAL_BAND (JLAT-1, YDGRID, YDREG_H)
    ENDIF
  ENDIF

  IF (JLAT < YDGRID%NDGLG) THEN
    IF (IINCL (YDREG%NLOE (JLAT)-YDREG%NLOW (JLAT), &
      & YLN2%JLON (JIDX_SE)-YLN1%JLON (JIDX_SW), YDGRID%NLOEN (JLAT), YDGRID%NLOEN (JLAT+1)) > 0) THEN
      CALL GROW_ZONAL_BAND (JLAT+1, &
                          & YDGRID%NLOEN (JLAT+1), YDREG_H%NLOW (JLAT+1), YDREG_H%NLOE (JLAT+1), &
                          & YDGRID%NLOEN (JLAT+1), YLN1%JLON (JIDX_SW), YLN2%JLON (JIDX_SE))
    ELSE
      CALL FULL_ZONAL_BAND (JLAT+1, YDGRID, YDREG_H)
    ENDIF
  ENDIF

ENDDO

IF (.NOT. YDDIST%LEQ_REGIONS) THEN
  IF (YDREG%NLAN ==            1) CALL FULL_ZONAL_BAND (YDREG%NLAN, YDGRID, YDREG_H)
  IF (YDREG%NLAS == YDGRID%NDGLG) CALL FULL_ZONAL_BAND (YDREG%NLAS, YDGRID, YDREG_H)
ENDIF

IF (LHOOK) CALL DR_HOOK ('HALO_FROM_REGION',1,ZHOOK_HANDLE)

END SUBROUTINE HALO_FROM_REGION

SUBROUTINE FULL_ZONAL_BAND (KLAT, YDGRID, YDREG)

INTEGER (KIND=JPIM), INTENT (IN)    :: KLAT
TYPE (GRID_t),       INTENT (IN)    :: YDGRID
TYPE (REGION_t),     INTENT (INOUT) :: YDREG

YDREG%NLOW (KLAT) = 1
YDREG%NLOE (KLAT) = YDGRID%NLOEN (KLAT)

END SUBROUTINE FULL_ZONAL_BAND

SUBROUTINE GROW_ZONAL_BAND (KLAT, KLOEN, KLOW, KLOE, KLOEN_NEW, KLOW_NEW, KLOE_NEW)

INTEGER (KIND=JPIM) :: KLAT, KLOEN, KLOW, KLOE, KLOEN_NEW, KLOW_NEW, KLOE_NEW

INTEGER (KIND=JPIM) :: II

LOGICAL :: LFULL, LINBA
INTEGER (KIND=JPIM) :: INORM, KLO
LFULL () = MODULO (KLOE - KLOW, KLOEN) == (KLOEN - 1)    ! Current latitude band is full

INORM (KLO) = 1 + MODULO (KLO-1, KLOEN)                  ! Normalize

LINBA (KLO) = ((KLOW <= KLO) .AND. (KLO <= KLOE)) &      ! Longitude index belongs to current band
      &  .OR. ((((1 <= KLO) .AND. (KLO <= KLOE)) &
      &  .OR. ((KLOW <= KLO) .AND. (KLO <= KLOEN))) .AND. (KLOE < KLOW))

IF (LFULL ()) GOTO 999

IF (.NOT. LINBA (KLOW_NEW)) THEN
  KLOW = INORM (KLOW_NEW)
  IF (LFULL ()) GOTO 999
ENDIF

IF (.NOT. LINBA (KLOE_NEW)) THEN
  KLOE = INORM (KLOE_NEW)
  IF (LFULL ()) GOTO 999
ENDIF

GOTO 888

RETURN

999 CONTINUE

KLOW = 1
KLOE = KLOEN 

888 CONTINUE

END SUBROUTINE GROW_ZONAL_BAND

SUBROUTINE HALO_FROM_NEIGHBOURS (YDNGBRS, YDGRID, YDREG_H)

TYPE (NEIGHBOURS1_t), INTENT (IN)  :: YDNGBRS (:)
TYPE (GRID_t),        INTENT (IN)  :: YDGRID
TYPE (REGION_t),      INTENT (OUT) :: YDREG_H

INTEGER (KIND=JPIM), ALLOCATABLE :: JLONLAT (:,:), IORD (:)
INTEGER (KIND=JPIM) :: ISIZE, IL1, IL2, IL, JL, IC
INTEGER (KIND=JPIM) :: JLAT, JLON
LOGICAL :: LLEQ
REAL(KIND=JPRB) :: ZHOOK_HANDLE

LOGICAL :: LFULL
INTEGER (KIND=JPIM) :: KLO1, KLO2, KLOEN
LFULL (KLO1, KLO2, KLOEN) = MODULO (KLO2 - KLO1, KLOEN) == (KLOEN - 1)

IF (LHOOK) CALL DR_HOOK ('HALO_FROM_NEIGHBOURS',0,ZHOOK_HANDLE)

! 

ISIZE = 0
DO IL = 1, SIZE (YDNGBRS)
  ISIZE = ISIZE + COUNT (YDNGBRS (IL)%JLON /= 0)
ENDDO

ALLOCATE (JLONLAT (2, ISIZE), IORD (ISIZE))

JL = 1
DO IL = 1, SIZE (YDNGBRS)
  DO IC = 1, 9
    IF (YDNGBRS (IL)%JLON (IC) == 0) CYCLE
    JLONLAT (1, JL) = YDNGBRS (IL)%JLON (IC)
    JLONLAT (2, JL) = YDNGBRS (IL)%JLAT (IC)
    JL = JL + 1
  ENDDO
ENDDO

CALL QSORTI4 (ISIZE, IORD, JLONLAT (2,:))

JLONLAT (1:2, :) = JLONLAT (1:2, IORD)

IL1 = 1
IL2 = 1
DO IL = 1, ISIZE

  LLEQ = JLONLAT (2, IL1) == JLONLAT (2, IL)

  IF (LLEQ) IL2 = IL

  IF ((.NOT. LLEQ) .OR. (IL == ISIZE)) THEN
    CALL QSORTI4 (IL2-IL1+1, IORD (IL1:IL2), JLONLAT (1, IL1:IL2))
    IORD (IL1:IL2) = IORD (IL1:IL2) + IL1-1
    JLONLAT (1:2, IL1:IL2) = JLONLAT (1:2, IORD (IL1:IL2))
  ENDIF

  IF (.NOT. LLEQ) THEN
    IL1 = IL
    IL2 = IL
  ENDIF

ENDDO

!

YDREG_H%NLAN = JLONLAT (2, 1)
YDREG_H%NLAS = JLONLAT (2, ISIZE)

ALLOCATE (YDREG_H%NLOW (YDREG_H%NLAN:YDREG_H%NLAS), &
        & YDREG_H%NLOE (YDREG_H%NLAN:YDREG_H%NLAS))

YDREG_H%NLOW = 0
YDREG_H%NLOE = 0

!

JLON = -1; JLAT = -1

IL = 1
DO WHILE (IL <= ISIZE)

  IF (JLON == JLONLAT (1,IL) .AND. JLAT == JLONLAT (2,IL)) GOTO 100

  JLON = JLONLAT (1,IL); JLAT = JLONLAT (2,IL)

  IF (YDREG_H%NLOW (JLAT) == 0) THEN
    YDREG_H%NLOW (JLAT) = JLON
    YDREG_H%NLOE (JLAT) = JLON
    CYCLE
  ENDIF

  IF (LFULL (YDREG_H%NLOW (JLAT), YDREG_H%NLOE (JLAT), YDGRID%NLOEN (JLAT))) CYCLE

  IF (JLON == YDREG_H%NLOE (JLAT) + 1) THEN
    YDREG_H%NLOE (JLAT) = JLON
  ELSEIF (1 == YDREG_H%NLOW (JLAT)) THEN
    YDREG_H%NLOW (JLAT) = JLON

    DO WHILE (IL <= ISIZE)
      IF (JLON == JLONLAT (1,IL) .AND. JLAT == JLONLAT (2,IL)) GOTO 200

      IF (JLONLAT (2, IL) /= JLAT) EXIT
      IF (JLONLAT (1, IL) /= JLON + 1) THEN
        WRITE (0, *) __FILE__, ':', __LINE__ 
        STOP
      ENDIF

      JLON = JLONLAT (1,IL); JLAT = JLONLAT (2,IL)
     

200 CONTINUE

      IL = IL + 1
    ENDDO

    IL = IL - 1
    JLON = JLONLAT (1,IL); JLAT = JLONLAT (2,IL)

  ENDIF

  IF (LFULL (YDREG_H%NLOW (JLAT), YDREG_H%NLOE (JLAT), YDGRID%NLOEN (JLAT))) THEN
    YDREG_H%NLOW (JLAT) = 1
    YDREG_H%NLOE (JLAT) = YDGRID%NLOEN (JLAT)
  ENDIF
  

100 CONTINUE
  IL = IL + 1
 
ENDDO

IF (LHOOK) CALL DR_HOOK ('HALO_FROM_NEIGHBOURS',1,ZHOOK_HANDLE)

END SUBROUTINE HALO_FROM_NEIGHBOURS

SUBROUTINE FIND_NEIGHBOURS (YDREG, YDGRID, YDNGBRS)

TYPE (REGION_t),                   INTENT (IN)  :: YDREG
TYPE (GRID_t),                     INTENT (IN)  :: YDGRID
TYPE (NEIGHBOURS1_t), ALLOCATABLE, INTENT (OUT) :: YDNGBRS (:)

INTEGER (KIND=JPIM) :: JLAT,  JLON
INTEGER (KIND=JPIM) :: ILOCAL, II

TYPE (NEIGHBOURS1_t) :: YLN1
REAL(KIND=JPRB) :: ZHOOK_HANDLE

INTEGER (KIND=JPIM), ALLOCATABLE :: ILOCAL_OFF (:)
INTEGER (KIND=JPIM) :: ISIZE
INTEGER (KIND=JPIM) :: INORM, KLO, KLOEN
INORM (KLO, KLOEN) = 1 + MODULO (KLO-1, KLOEN)

IF (LHOOK) CALL DR_HOOK ('FIND_NEIGHBOURS',0,ZHOOK_HANDLE)

ISIZE = REGION_SIZE (YDREG, YDGRID)

ALLOCATE (YDNGBRS (ISIZE))

ALLOCATE (ILOCAL_OFF (YDREG%NLAN:YDREG%NLAS))

ILOCAL_OFF (YDREG%NLAN) = 0
DO JLAT = YDREG%NLAN+1, YDREG%NLAS
  ILOCAL_OFF (JLAT) = ILOCAL_OFF (JLAT-1) + 1 + MODULO (YDREG%NLOE (JLAT-1) - YDREG%NLOW (JLAT-1), YDGRID%NLOEN (JLAT-1))
ENDDO

!$OMP PARALLEL DO PRIVATE (JLAT, JLON, ILOCAL, II)

DO JLAT = YDREG%NLAN, YDREG%NLAS
 
  JLON = YDREG%NLOW (JLAT)
  
  II = 0

  DO 
    II = II + 1
    ILOCAL = ILOCAL_OFF (JLAT) + II
    CALL FIND_NEIGHBOURS1 (JLAT, JLON, YDGRID, YDNGBRS (ILOCAL))

    IF (JLON == YDREG%NLOE (JLAT)) EXIT

    JLON = INORM (JLON + 1, YDGRID%NLOEN (JLAT))

  ENDDO

ENDDO

!$OMP END PARALLEL DO

IF (LHOOK) CALL DR_HOOK ('FIND_NEIGHBOURS',1,ZHOOK_HANDLE)

END SUBROUTINE FIND_NEIGHBOURS

SUBROUTINE FIND_NEIGHBOURS1 (JLAT, JLON, YDGRID, YDN1)

INTEGER (KIND=JPIM),  INTENT (IN)  :: JLAT, JLON
TYPE (GRID_t),        INTENT (IN)  :: YDGRID
TYPE (NEIGHBOURS1_t), INTENT (OUT) :: YDN1

INTEGER (KIND=JPIM) :: IR, IQ, ILOEN, ILOEN1, ILOEN2
INTEGER (KIND=JPIM) :: INUM, IDEN
INTEGER (KIND=JPIM) :: JLAT1, JLON1, JLAT2, JLON2

INTEGER (KIND=JPIM) :: INORM, KLO, KLOEN
INORM (KLO, KLOEN) = 1 + MODULO (KLO-1, KLOEN)


YDN1%JLON (JIDX___) = INORM (JLON+0, YDGRID%NLOEN (JLAT)); YDN1%JLAT (JIDX___) = JLAT
YDN1%JLON (JIDX__W) = INORM (JLON-1, YDGRID%NLOEN (JLAT)); YDN1%JLAT (JIDX__W) = JLAT
YDN1%JLON (JIDX__E) = INORM (JLON+1, YDGRID%NLOEN (JLAT)); YDN1%JLAT (JIDX__E) = JLAT

IF (JLAT == 1) THEN
  ILOEN = YDGRID%NLOEN (JLAT)
  IQ = JLON + ILOEN / 2; IR = MODULO (ILOEN, 2)
  IF (IR == 0) THEN
    YDN1%JLON (JIDX_NW) = INORM (IQ+1, ILOEN ); YDN1%JLAT (JIDX_NW) = JLAT
    YDN1%JLON (JIDX_N_) = INORM (IQ+0, ILOEN ); YDN1%JLAT (JIDX_N_) = JLAT
    YDN1%JLON (JIDX_NE) = INORM (IQ-1, ILOEN ); YDN1%JLAT (JIDX_NE) = JLAT
  ELSE
    YDN1%JLON (JIDX_NW) = INORM (IQ+1, ILOEN ); YDN1%JLAT (JIDX_NW) = JLAT 
    YDN1%JLON (JIDX_NE) = INORM (IQ+0, ILOEN ); YDN1%JLAT (JIDX_NE) = JLAT 
  ENDIF
ELSE
  JLON1 = JLON
  JLAT1 = JLAT     ; ILOEN1 = YDGRID%NLOEN (JLAT1)
  JLAT2 = JLAT - 1 ; ILOEN2 = YDGRID%NLOEN (JLAT2)
  INUM = ILOEN1 - ILOEN2 + JLON1 * ILOEN2; IDEN = ILOEN1
  IQ   = INUM / IDEN; IR = (IQ - 1) * ILOEN1 - (JLON1 - 1) * ILOEN2
  IF (IR == 0) THEN
    YDN1%JLON (JIDX_NW) = INORM (IQ-1, ILOEN2); YDN1%JLAT (JIDX_NW) = JLAT2
    YDN1%JLON (JIDX_N_) = INORM (IQ+0, ILOEN2); YDN1%JLAT (JIDX_N_) = JLAT2
    YDN1%JLON (JIDX_NE) = INORM (IQ+1, ILOEN2); YDN1%JLAT (JIDX_NE) = JLAT2
  ELSE
    YDN1%JLON (JIDX_NW) = INORM (IQ+0, ILOEN2); YDN1%JLAT (JIDX_NW) = JLAT2
    YDN1%JLON (JIDX_NE) = INORM (IQ+1, ILOEN2); YDN1%JLAT (JIDX_NE) = JLAT2
  ENDIF
ENDIF

IF (JLAT == YDGRID%NDGLG) THEN
  ILOEN = YDGRID%NLOEN (JLAT)
  IQ = JLON + ILOEN / 2; IR = MODULO (ILOEN, 2)
  IF (IR == 0) THEN
    YDN1%JLON (JIDX_SW) = INORM (IQ+1, ILOEN ); YDN1%JLAT (JIDX_SW) = JLAT
    YDN1%JLON (JIDX_S_) = INORM (IQ+0, ILOEN ); YDN1%JLAT (JIDX_S_) = JLAT
    YDN1%JLON (JIDX_SE) = INORM (IQ-1, ILOEN ); YDN1%JLAT (JIDX_SE) = JLAT
  ELSE
    YDN1%JLON (JIDX_SW) = INORM (IQ+1, ILOEN ); YDN1%JLAT (JIDX_SW) = JLAT 
    YDN1%JLON (JIDX_SE) = INORM (IQ+0, ILOEN ); YDN1%JLAT (JIDX_SE) = JLAT 
  ENDIF
ELSE
  JLON1 = JLON
  JLAT1 = JLAT     ; ILOEN1 = YDGRID%NLOEN (JLAT1)
  JLAT2 = JLAT + 1 ; ILOEN2 = YDGRID%NLOEN (JLAT2)
  INUM = ILOEN1 - ILOEN2 + JLON1 * ILOEN2; IDEN = ILOEN1
  IQ   = INUM / IDEN; IR = (IQ - 1) * ILOEN1 - (JLON1 - 1) * ILOEN2
  IF (IR == 0) THEN
    YDN1%JLON (JIDX_SW) = INORM (IQ-1, ILOEN2); YDN1%JLAT (JIDX_SW) = JLAT2
    YDN1%JLON (JIDX_S_) = INORM (IQ+0, ILOEN2); YDN1%JLAT (JIDX_S_) = JLAT2
    YDN1%JLON (JIDX_SE) = INORM (IQ+1, ILOEN2); YDN1%JLAT (JIDX_SE) = JLAT2
  ELSE
    YDN1%JLON (JIDX_SW) = INORM (IQ+0, ILOEN2); YDN1%JLAT (JIDX_SW) = JLAT2
    YDN1%JLON (JIDX_SE) = INORM (IQ+1, ILOEN2); YDN1%JLAT (JIDX_SE) = JLAT2
  ENDIF
ENDIF

END SUBROUTINE FIND_NEIGHBOURS1

SUBROUTINE REGION_PRINT_DIFF (YDREG1, YDREG2, YDGRID)

TYPE (REGION_t), INTENT (IN)  :: YDREG1, YDREG2
TYPE (GRID_t),   INTENT (IN)  :: YDGRID

INTEGER (KIND=JPIM) :: JLAT, JLON, ILOEN
LOGICAL :: LL1, LL2
REAL(KIND=JPRB) :: ZHOOK_HANDLE


IF (LHOOK) CALL DR_HOOK ('REGION_PRINT_DIFF',0,ZHOOK_HANDLE)

DO JLAT = MIN (YDREG1%NLAN, YDREG2%NLAN), MAX (YDREG1%NLAS, YDREG2%NLAS)

  LL1 = YDREG1%NLAN <= JLAT .AND. JLAT <= YDREG1%NLAS
  LL2 = YDREG2%NLAN <= JLAT .AND. JLAT <= YDREG2%NLAS
  ILOEN = YDGRID%NLOEN (JLAT)

  WRITE (*, '(" JLAT = ",I3," ",F7.3," | ")', ADVANCE="NO") JLAT, 360._JPRB / REAL (ILOEN, JPRB)

  IF (LL1) THEN
    WRITE (*, '(I3," ",F6.2," ... ",I3," ",F6.2," (",I3,"/",I3,",",L1,")")', ADVANCE="NO") &
         & YDREG1%NLOW (JLAT), REAL (YDREG1%NLOW (JLAT) - 1, JPRB) * 360._JPRB / REAL (ILOEN, JPRB), &
         & YDREG1%NLOE (JLAT), REAL (YDREG1%NLOE (JLAT) - 1, JPRB) * 360._JPRB / REAL (ILOEN, JPRB), &
         & 1 + MODULO (YDREG1%NLOE (JLAT) - YDREG1%NLOW (JLAT), ILOEN), &
         & ILOEN, &
         & MODULO (YDREG1%NLOE (JLAT) - YDREG1%NLOW (JLAT), ILOEN) == (ILOEN - 1)
  ELSE
    WRITE (*, '(37X)', ADVANCE="NO")
  ENDIF

  WRITE (*, '(" ")', ADVANCE="NO")

  IF (LL2) THEN
    WRITE (*, '(I3," ",F6.2," ... ",I3," ",F6.2," (",I3,"/",I3,",",L1,")")', ADVANCE="NO") &
         & YDREG2%NLOW (JLAT), REAL (YDREG2%NLOW (JLAT) - 1, JPRB) * 360._JPRB / REAL (ILOEN, JPRB), &
         & YDREG2%NLOE (JLAT), REAL (YDREG2%NLOE (JLAT) - 1, JPRB) * 360._JPRB / REAL (ILOEN, JPRB), &
         & 1 + MODULO (YDREG2%NLOE (JLAT) - YDREG2%NLOW (JLAT), ILOEN), &
         & ILOEN, &
         & MODULO (YDREG2%NLOE (JLAT) - YDREG2%NLOW (JLAT), ILOEN) == (ILOEN - 1)
  ELSE
    WRITE (*, '(37X)', ADVANCE="NO")
  ENDIF

  WRITE (*, '(" ")', ADVANCE="NO")

  IF (LL1 .AND. LL2) THEN
    WRITE (*, '(I3," ",I3)', ADVANCE="NO") &
                           & MODULO (YDREG1%NLOW (JLAT) - YDREG2%NLOW (JLAT), ILOEN), &
                           & MODULO (YDREG2%NLOE (JLAT) - YDREG1%NLOE (JLAT), ILOEN)
  ENDIF

  WRITE (*, *)

ENDDO

IF (LHOOK) CALL DR_HOOK ('REGION_PRINT_DIFF',1,ZHOOK_HANDLE)

END SUBROUTINE REGION_PRINT_DIFF

SUBROUTINE REGION_PRINT (YDREG, YDGRID)

TYPE (REGION_t), INTENT (IN)  :: YDREG
TYPE (GRID_t),   INTENT (IN)  :: YDGRID

INTEGER (KIND=JPIM) :: JLAT, JLON
REAL(KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK ('REGION_PRINT',0,ZHOOK_HANDLE)

DO JLAT = YDREG%NLAN, YDREG%NLAS
  WRITE (*, '(" JLAT = ",I3,"| ",I3," ... ",I3," (",I3,"/",I3,",",L1,")")') JLAT, YDREG%NLOW (JLAT), &
       & YDREG%NLOE (JLAT), &
       & 1 + MODULO (YDREG%NLOE (JLAT) - YDREG%NLOW (JLAT), YDGRID%NLOEN (JLAT)), &
       & YDGRID%NLOEN (JLAT), &
       & MODULO (YDREG%NLOE (JLAT) - YDREG%NLOW (JLAT), YDGRID%NLOEN (JLAT)) == (YDGRID%NLOEN (JLAT) - 1)
ENDDO

IF (LHOOK) CALL DR_HOOK ('REGION_PRINT',1,ZHOOK_HANDLE)

END SUBROUTINE REGION_PRINT

SUBROUTINE OFA (KLUN, CDFILENAME, YDGRID)

INTEGER (KIND=JPIM), INTENT (IN) :: KLUN
CHARACTER (LEN=*),   INTENT (IN) :: CDFILENAME
TYPE (GRID_t),       INTENT (IN) :: YDGRID

CHARACTER (LEN=*), PARAMETER :: CLNOMC = 'c'

INTEGER (KIND=JPIM) :: IREP
LOGICAL :: LLEXIST

INQUIRE (FILE = CDFILENAME, EXIST=LLEXIST)

IF (LLEXIST) THEN
  BLOCK
  INTEGER (KIND=JPIM) :: INBARP, INBARI
  INBARP = 0
  INBARI = 0
  CALL FAITOU (IREP, KLUN, .TRUE., TRIM (CDFILENAME), 'OLD', &
             & .TRUE., .TRUE., 2_JPIM, INBARP, INBARI, CLNOMC)
  CALL FACAGE (CLNOMC, .FALSE.)
  RETURN
  ENDBLOCK
ENDIF

BLOCK
  REAL (KIND=JPRB) :: ZAHYBR (2), ZBHYBR (2), ZSLAPO, ZCLOPO, ZSLOPO, ZCODIL, ZREFER
  INTEGER (KIND=JPIM) :: INIVER, ITYPTR, ITRONC, INLATI, INXLON, INOZPA (YDGRID%NDGLG)
  
  INIVER = 1_JPIM
  ZAHYBR = 0._JPRB
  ZBHYBR = 0._JPRB
  IF (YDGRID%LROTATED .OR. YDGRID%LSTRETCH) THEN
    ITYPTR = 2_JPIM
  ELSE
    ITYPTR = 1_JPIM
  ENDIF
  IF (YDGRID%LROTATED .OR. YDGRID%LSTRETCH) THEN
    ZCODIL = YDGRID%RSTRETCH
    ZSLAPO = SIN (YDGRID%RLATCENT)
    ZCLOPO = COS (YDGRID%RLONCENT)
    ZSLOPO = SIN (YDGRID%RLONCENT) 
  ELSE
    ZCODIL = 1._JPRB
    ZSLAPO = 1._JPRB 
    ZCLOPO = COS (YDGRID%RLONOFF)
    ZSLOPO = SIN (YDGRID%RLONOFF) 
  ENDIF
  ITRONC = YDGRID%NSMAX
  INLATI = YDGRID%NDGLG
  INXLON = MAXVAL (YDGRID%NLOEN)
  INOZPA = MIN (YDGRID%NSMAX, YDGRID%NLOEN/2_JPIM-1_JPIM)
  ZREFER = 1._JPRB
  CALL FACADE (CLNOMC, ITYPTR, ZSLAPO, ZCLOPO, ZSLOPO,        &
  &            ZCODIL, ITRONC, INLATI, INXLON, YDGRID%NLOEN,  &
  &            INOZPA, YDGRID%RMU, INIVER, ZREFER, ZAHYBR,    &
  &            ZBHYBR, .FALSE.)
ENDBLOCK

BLOCK
  INTEGER (KIND=JPIM) :: INBARP, INBARI
  INBARP = 0; INBARI = 0
  CALL FAITOU (IREP, KLUN, .TRUE., TRIM (CDFILENAME), 'NEW', &
             & .TRUE., .TRUE., 2_JPIM, INBARP, INBARI, CLNOMC)
  CALL FACAGE (CLNOMC, .FALSE.)
  CALL FAUTIF (IREP, KLUN, 'ARP')
ENDBLOCK


BLOCK
  INTEGER (KIND=JPIM) :: IDATEF (11)
  IDATEF = [1990,  2, 15, 12,  0,   1,  0, 24,   1, 0, 0]
  CALL FANDAR (IREP, KLUN, IDATEF)
ENDBLOCK

END SUBROUTINE

SUBROUTINE RFA (PFLDL, KGPTOT, KFIELDL, CDFILENAME, CDPREF, &
              & KNIVAU, CDSUFF, YDGRID, YDDIST, PUNDEF, LDREQ)

USE MPL_MODULE, ONLY : MPL_MYRANK, MPL_NUMPROC

REAL (KIND=JPRB),   INTENT (OUT) :: PFLDL (KGPTOT,KFIELDL,1)
INTEGER (KIND=JPIM),INTENT (IN)  :: KGPTOT, KFIELDL
CHARACTER (LEN=*),  INTENT (IN)  :: CDFILENAME, CDPREF (:), CDSUFF (:)
INTEGER (KIND=JPIM),INTENT (IN)  :: KNIVAU (:)
TYPE (GRID_t),      INTENT (IN)  :: YDGRID
TYPE (DIST_t),      INTENT (IN)  :: YDDIST
REAL (KIND=JPRB),   INTENT (IN), OPTIONAL :: PUNDEF
LOGICAL,            INTENT (IN), OPTIONAL :: LDREQ (:)

REAL (KIND=JPRB), ALLOCATABLE :: ZFLDG (:,:)
REAL (KIND=JPRB) :: ZUNDEF

INTEGER (KIND=JPIM) :: IFROM (KFIELDL)
INTEGER (KIND=JPIM) :: MYPROC, NPROC, IPROC, JFLD1, JFLD2
INTEGER (KIND=JPIM) :: IREP, JFLDL, JFLDG, INFLDG

LOGICAL :: LLREQ (KFIELDL)
LOGICAL :: LLUNDEF
REAL(KIND=JPRB) :: ZHOOK_HANDLE

#include "abor1.intfb.h"
#include "facilo.h"

IF (LHOOK) CALL DR_HOOK ('RFA',0,ZHOOK_HANDLE)

IF (PRESENT (LDREQ)) THEN
  LLREQ = LDREQ
ELSE
  LLREQ = .TRUE.
ENDIF

NPROC = MPL_NUMPROC 
MYPROC = MPL_MYRANK ()

DO IPROC = 1, NPROC
  JFLD1 = 1 + ((IPROC-1) * KFIELDL) / NPROC
  JFLD2 = 0 + ((IPROC+0) * KFIELDL) / NPROC
  IFROM (JFLD1:JFLD2) = IPROC
ENDDO

INFLDG = COUNT (IFROM == MYPROC)

IF (INFLDG > 0) THEN
  CALL OFA (77, CDFILENAME, YDGRID)
  ALLOCATE (ZFLDG (YDGRID%NGPTOTG, INFLDG))
ENDIF

BLOCK
  INTEGER (KIND=JPIM) :: ILNOMA, ILONGD, IPOSEX
  CHARACTER (LEN=16) :: CLNOMA
  JFLDG = 1
  DO JFLDL = 1, KFIELDL
    IF (IFROM (JFLDL) == MYPROC) THEN
      CALL FANFAN (IREP, 77, CDPREF (JFLDL), KNIVAU (JFLDL), CDSUFF (JFLDL), CLNOMA, ILNOMA)
      CALL LFINFO (IREP, 77, CLNOMA (1:ILNOMA), ILONGD, IPOSEX)
      IF (ILONGD == 0) THEN
        IF (LLREQ (JFLDL)) THEN
          CALL ABOR1 ('FIELD '//CLNOMA (1:ILNOMA)//' WAS NOT FOUND IN '//TRIM (CDFILENAME))
        ELSEIF (PRESENT (PUNDEF)) THEN
          ZFLDG (:, JFLDG) = PUNDEF
        ELSE
          ZFLDG (:, JFLDG) = 0._JPRB
        ENDIF
      ELSE
        LLUNDEF = PRESENT (PUNDEF)
        IF (LLUNDEF) ZUNDEF = PUNDEF
        CALL FACILO (IREP, 77, CDPREF (JFLDL), KNIVAU (JFLDL), CDSUFF (JFLDL), &
                   & ZFLDG (:, JFLDG), .FALSE., LDUNDF=LLUNDEF, PUNDF=ZUNDEF)
      ENDIF
      JFLDG = JFLDG + 1
    ENDIF
  ENDDO
ENDBLOCK

IF (INFLDG > 0) THEN
  CALL FAIRME (IREP, 77, 'KEEP')
  CALL GRID_DIST (PGPG=ZFLDG (:,:), &
                & KFIELDG=KFIELDL, KFLD2PROC=IFROM, YDGRID=YDGRID, &
                & YDDIST=YDDIST, PGP=PFLDL (:,:,1))
ELSE
  CALL GRID_DIST (KFIELDG=KFIELDL, KFLD2PROC=IFROM, YDGRID=YDGRID, &
                & YDDIST=YDDIST, PGP=PFLDL (:,:,1))
ENDIF

IF (LHOOK) CALL DR_HOOK ('RFA',1,ZHOOK_HANDLE)

END SUBROUTINE

SUBROUTINE WFA (PFLDL, KGPTOT, KFIELDL, CDFILENAME, CDPREF, &
              & KNIVAU, CDSUFF, YDGRID, YDDIST, PUNDEF, LDMASK)

USE MPL_MODULE, ONLY : MPL_MYRANK, MPL_NUMPROC

REAL (KIND=JPRB),   INTENT (IN) :: PFLDL (KGPTOT,KFIELDL,1)
INTEGER (KIND=JPIM),INTENT (IN) :: KGPTOT, KFIELDL
CHARACTER (LEN=*),  INTENT (IN) :: CDFILENAME, CDPREF (:), CDSUFF (:)
INTEGER (KIND=JPIM),INTENT (IN) :: KNIVAU (:)
TYPE (GRID_t),      INTENT (IN) :: YDGRID
TYPE (DIST_t),      INTENT (IN) :: YDDIST
REAL (KIND=JPRB),   INTENT (IN), OPTIONAL :: PUNDEF
LOGICAL,            INTENT (IN), OPTIONAL :: LDMASK (:)

REAL (KIND=JPRB), ALLOCATABLE :: ZFLDG (:,:)

INTEGER (KIND=JPIM) :: ITO (KFIELDL)
INTEGER (KIND=JPIM) :: MYPROC, NPROC, IPROC, JFLD1, JFLD2
INTEGER (KIND=JPIM) :: IREP, JFLDL, JFLDG, INFLDG
CHARACTER (LEN=64) :: CLFILENAME, CLPROC
LOGICAL :: LLUNDEF
LOGICAL :: LLMASK (KFIELDL)
REAL(KIND=JPRB) :: ZHOOK_HANDLE

#include "abor1.intfb.h"
#include "faieno.h"

IF (LHOOK) CALL DR_HOOK ('WFA',0,ZHOOK_HANDLE)

NPROC = MPL_NUMPROC 
MYPROC = MPL_MYRANK ()

LLUNDEF = PRESENT (PUNDEF)
LLMASK = .FALSE.

IF (PRESENT (LDMASK)) LLMASK = LDMASK

DO IPROC = 1, NPROC
  JFLD1 = 1 + ((IPROC-1) * KFIELDL) / NPROC
  JFLD2 = 0 + ((IPROC+0) * KFIELDL) / NPROC
  ITO (JFLD1:JFLD2) = IPROC
ENDDO

INFLDG = COUNT (ITO == MYPROC)

IF (INFLDG > 0) THEN
  ALLOCATE (ZFLDG (YDGRID%NGPTOTG, INFLDG))
  CALL GRID_GATH (PGPG=ZFLDG (:,:), &
                & KFIELDG=KFIELDL, KFLD2PROC=ITO, YDGRID=YDGRID, &
                & YDDIST=YDDIST, PGP=PFLDL (:,:,1))
ELSE
  CALL GRID_GATH (KFIELDG=KFIELDL, KFLD2PROC=ITO, YDGRID=YDGRID, &
                & YDDIST=YDDIST, PGP=PFLDL (:,:,1))
  GOTO 999
ENDIF

WRITE (CLPROC, '(".",I8.8)') MYPROC
CLFILENAME = TRIM (CDFILENAME) // TRIM (CLPROC)

CALL OFA (77, CLFILENAME, YDGRID)

BLOCK
  INTEGER (KIND=JPIM) :: INGRIB, INARG1, INARG2, INARG3, INARG4, INARG5
  CALL FAVEUR (IREP, 77, INGRIB, INARG1, INARG2, INARG3, INARG4, INARG5)
  INGRIB = 123_JPIM
  CALL FAGOTE (IREP, 77, INGRIB, INARG1, INARG2, INARG3, INARG4, INARG5)
ENDBLOCK

BLOCK
  JFLDG = 1
  DO JFLDL = 1, KFIELDL
    IF (ITO (JFLDL) == MYPROC) THEN
      IF (.NOT. LLMASK (JFLDL)) THEN
        CALL FAIENO (IREP, 77, CDPREF (JFLDL), KNIVAU (JFLDL), CDSUFF (JFLDL), &
                   & ZFLDG (:, JFLDG), .FALSE., LDUNDF=LLUNDEF, PUNDF=PUNDEF)
      ENDIF
      JFLDG = JFLDG + 1
    ENDIF
  ENDDO
ENDBLOCK

CALL FAIRME (IREP, 77, 'KEEP')

999 CONTINUE

IF (LHOOK) CALL DR_HOOK ('WFA',1,ZHOOK_HANDLE)

END SUBROUTINE

SUBROUTINE NC (PFLDL, KGPTOT, CDFILENAME, YDGRID, YDDIST, PUNDEF)

USE MPL_MODULE, ONLY : MPL_MYRANK

REAL (KIND=JPRB),   INTENT (IN) :: PFLDL (KGPTOT,1,1)
INTEGER (KIND=JPIM),INTENT (IN) :: KGPTOT
CHARACTER (LEN=*),  INTENT (IN) :: CDFILENAME
TYPE (GRID_t),      INTENT (IN) :: YDGRID
TYPE (DIST_t),      INTENT (IN) :: YDDIST
REAL (KIND=JPRB),   INTENT (IN), OPTIONAL :: PUNDEF


REAL (KIND=JPRB), ALLOCATABLE :: ZFLDG (:,:)

INTEGER (KIND=JPIM) :: ITO (1)
INTEGER (KIND=JPIM) :: MYPROC
REAL (KIND=JPRB) :: ZUNDEF, ZMAX, ZMIN
LOGICAL :: LLUNDEF
REAL(KIND=JPRB) :: ZHOOK_HANDLE

#include "abor1.intfb.h"

IF (LHOOK) CALL DR_HOOK ('NC',0,ZHOOK_HANDLE)

LLUNDEF = PRESENT (PUNDEF)
IF (LLUNDEF) ZUNDEF = PUNDEF

ITO = 1

MYPROC = MPL_MYRANK ()

IF (MYPROC == 1) THEN
  ALLOCATE (ZFLDG (YDGRID%NGPTOTG, 1))
  CALL GRID_GATH (PGPG=ZFLDG (:,:), KFIELDG=1_JPIM, KFLD2PROC=ITO, YDGRID=YDGRID, &
                & YDDIST=YDDIST, PGP=PFLDL (:,:,1))
ELSE
  CALL GRID_GATH (KFIELDG=1_JPIM, KFLD2PROC=ITO, YDGRID=YDGRID, YDDIST=YDDIST, &
                & PGP=PFLDL (:,:,1))
  GOTO 999
ENDIF

IF (LLUNDEF) THEN
  ZMIN = MINVAL (ZFLDG, MASK=ZFLDG/=ZUNDEF)
  ZMAX = MAXVAL (ZFLDG, MASK=ZFLDG/=ZUNDEF)
  WHERE (ZFLDG == ZUNDEF)
!   ZFLDG = ZMIN - (ZMAX - ZMIN)
    ZFLDG = 0.
  END WHERE
ENDIF

IF (ANY (YDGRID%NLOEN /= YDGRID%NLOEN (1))) THEN
  CALL ABOR1 ('NC: GRID IS NOT LATLON')
ENDIF

BLOCK
  USE NETCDF
  
  INTEGER :: NCID, VARID
  INTEGER :: X_DIMID, Y_DIMID
  INTEGER :: IERR
  INTEGER (KIND=JPIM) :: JLAT
  REAL (KIND=JPRB) :: ZDATA (YDGRID%NLOEN (1), YDGRID%NDGLG)
  
  IERR = NF90_CREATE (TRIM (CDFILENAME), NF90_CLOBBER, NCID)

  DO JLAT = 1, YDGRID%NDGLG
    ZDATA (:, JLAT) = ZFLDG (1+(JLAT-1)*YDGRID%NLOEN (1):JLAT*YDGRID%NLOEN (1), 1)
  ENDDO

  IERR = NF90_DEF_DIM (NCID, "X", YDGRID%NLOEN (1), X_DIMID)
  IERR = NF90_DEF_DIM (NCID, "Y", YDGRID%NDGLG, Y_DIMID)
  IERR = NF90_DEF_VAR (NCID, "DATA", NF90_DOUBLE, [X_DIMID, Y_DIMID], VARID)
  IERR = NF90_ENDDEF (NCID)
  IERR = NF90_PUT_VAR (NCID, VARID, ZDATA)
  IERR = NF90_CLOSE (NCID)

ENDBLOCK

999 CONTINUE

IF (LHOOK) CALL DR_HOOK ('NC',1,ZHOOK_HANDLE)

END SUBROUTINE


SUBROUTINE GMSH (PFLDL, KGPTOT, CDFILENAME, YDGRID, YDDIST, PUNDEF)

USE MPL_MODULE, ONLY : MPL_MYRANK

REAL (KIND=JPRB),   INTENT (IN) :: PFLDL (KGPTOT,1,1)
INTEGER (KIND=JPIM),INTENT (IN) :: KGPTOT
CHARACTER (LEN=*),  INTENT (IN) :: CDFILENAME
TYPE (GRID_t),      INTENT (IN) :: YDGRID
TYPE (DIST_t),      INTENT (IN) :: YDDIST
REAL (KIND=JPRB),   INTENT (IN), OPTIONAL :: PUNDEF


REAL (KIND=JPRB), ALLOCATABLE :: ZFLDG (:,:)

INTEGER (KIND=JPIM) :: ITO (1)
INTEGER (KIND=JPIM) :: JGLOBAL, JELT
INTEGER (KIND=JPIM) :: JLAT,  JLON,  ILOEN,  JGLOOFF
INTEGER (KIND=JPIM) :: JLAT1, JLON1, ILOEN1, JGLOOFF1
INTEGER (KIND=JPIM) :: JLAT2, JLON2, ILOEN2, JGLOOFF2
INTEGER (KIND=JPIM) :: ICA, ICB, ICC
INTEGER (KIND=JPIM) :: IDLONC, IDLONN
INTEGER (KIND=JPIM) :: MYPROC
INTEGER (KIND=JPIM) :: JSTEP
INTEGER (KIND=JPIM) :: JPROC
LOGICAL :: LLPRINT
REAL (KIND=JPRB) :: ZLON, ZLAT, ZXYZ (3)
REAL (KIND=JPRB) :: ZCOSLON, ZSINLON, ZCOSLAT, ZSINLAT
REAL (KIND=JPRB) :: ZUNDEF, ZMAX, ZMIN
LOGICAL :: LLUNDEF
CHARACTER (LEN=64) :: CLFILENAME
REAL(KIND=JPRB) :: ZHOOK_HANDLE

#include "abor1.intfb.h"

INTEGER (KIND=JPIM) :: JDLON, JNEXT

JDLON (JLON1, JLON2) = MODULO (JLON1 - 1, ILOEN1) * ILOEN2 - MODULO (JLON2 - 1, ILOEN2) * ILOEN1
JNEXT (JLON, ILOEN) = 1 + MODULO (JLON, ILOEN)

IF (LHOOK) CALL DR_HOOK ('GMSH',0,ZHOOK_HANDLE)

LLUNDEF = PRESENT (PUNDEF)
IF (LLUNDEF) ZUNDEF = PUNDEF

ITO = 1

MYPROC = MPL_MYRANK ()

IF (MYPROC == 1) THEN
  ALLOCATE (ZFLDG (YDGRID%NGPTOTG, 1))
  CALL GRID_GATH (PGPG=ZFLDG (:,:), KFIELDG=1_JPIM, KFLD2PROC=ITO, YDGRID=YDGRID, &
                & YDDIST=YDDIST, PGP=PFLDL (:,:,1))
ELSE
  CALL GRID_GATH (KFIELDG=1_JPIM, KFLD2PROC=ITO, YDGRID=YDGRID, YDDIST=YDDIST, &
                & PGP=PFLDL (:,:,1))
  GOTO 999
ENDIF

IF (LLUNDEF) THEN
  ZMIN = MINVAL (ZFLDG, MASK=ZFLDG/=ZUNDEF)
  ZMAX = MAXVAL (ZFLDG, MASK=ZFLDG/=ZUNDEF)
  WHERE (ZFLDG == ZUNDEF)
    ZFLDG = ZMIN - 0.2 * (ZMAX - ZMIN)
!   ZFLDG = 0.
  END WHERE
ENDIF


CLFILENAME = CDFILENAME
OPEN (77, FILE=TRIM (CLFILENAME), FORM="FORMATTED")

WRITE (77, '(A)') '$MeshFormat'
WRITE (77, '(A)') '2.2 0 8'
WRITE (77, '(A)') '$EndMeshFormat'

! Nodes

WRITE (77, '(A)') '$Nodes'
WRITE (77, '(I0)') YDGRID%NGPTOTG

JGLOBAL = 1
DO JLAT = 1, YDGRID%NDGLG

  ZLAT = ASIN ((YDGRID%ZOMC2 + YDGRID%RMU (JLAT) * YDGRID%ZOPC2) &
       &     / (YDGRID%ZOPC2 + YDGRID%RMU (JLAT) * YDGRID%ZOMC2))

  ZCOSLAT = COS (ZLAT); ZSINLAT = SIN (ZLAT)

  DO JLON = 1, YDGRID%NLOEN (JLAT)

    ZLON = YDGRID%RLONOFF + REAL (JLON - 1, JPRB) * 2._JPRB * RPI / YDGRID%NLOEN (JLAT)

    ZCOSLON = COS (ZLON); ZSINLON = SIN (ZLON)

    ZXYZ (1) = ZCOSLON * ZCOSLAT
    ZXYZ (2) = ZSINLON * ZCOSLAT
    ZXYZ (3) =           ZSINLAT

    ZXYZ = MATMUL (YDGRID%ZROTD, ZXYZ)

    WRITE (77, '(I0," ",3E18.8)') JGLOBAL, ZXYZ
 
    JGLOBAL = JGLOBAL + 1
  ENDDO
ENDDO

WRITE (77, '(A)') '$EndNodes'

! Elements


DO JSTEP = 1, 2

LLPRINT = JSTEP == 2

JGLOOFF = 0
JELT = 1
DO JLAT = 1, YDGRID%NDGLG-1

  ILOEN1 = YDGRID%NLOEN (JLAT + 0)
  ILOEN2 = YDGRID%NLOEN (JLAT + 1)
  JGLOOFF1 = JGLOOFF + 0
  JGLOOFF2 = JGLOOFF + ILOEN1

  IF (ILOEN1 == ILOEN2) THEN
    DO JLON1 = 1, ILOEN1
      JLON2 = JLON1
      IF (LLPRINT) &
      WRITE (77, '(I0," 3 4 1 1 1 0 ",I0," ",I0," ",I0," ",I0)') JELT, &
           & JGLOOFF1 + JLON1, &
           & JGLOOFF2 + JLON2, &
           & JGLOOFF2 + JNEXT (JLON2, ILOEN2), &
           & JGLOOFF1 + JNEXT (JLON1, ILOEN1)
      JELT = JELT + 1
    ENDDO
  ELSE
    JLON1 = 1
    JLON2 = 1
    DO 

      IDLONC = JDLON (JLON1, JLON2)
      IDLONN = JDLON (JNEXT (JLON1, ILOEN1), JNEXT (JLON2, ILOEN2))

      IF (IDLONC > 0 .OR. ((IDLONC == 0) .AND. IDLONN > 0)) THEN
        JLON = JNEXT (JLON2, ILOEN2)
        ICA = JGLOOFF1 + JLON1; ICB = JGLOOFF2 + JLON2; ICC = JGLOOFF2 + JLON
        JLON2 = JLON
      ELSEIF (IDLONC < 0 .OR. ((IDLONC == 0) .AND. IDLONN < 0)) THEN
        JLON = JNEXT (JLON1, ILOEN1)
        ICA = JGLOOFF1 + JLON1; ICB = JGLOOFF2 + JLON2; ICC = JGLOOFF1 + JLON
        JLON1 = JLON
      ELSE
        CALL ABOR1 ('GMSH:')
      ENDIF

      IF (LLPRINT) &
      WRITE (77, '(I0," 2 4 1 1 1 0 ",I0," ",I0," ",I0)') JELT, ICA, ICB, ICC
           
      JELT = JELT + 1

      IF ((JLON1 == 1) .AND. (JLON2 == ILOEN2)) THEN
        JLON = JNEXT (JLON2, ILOEN2)
        ICA = JGLOOFF1 + JLON1; ICB = JGLOOFF2 + JLON2; ICC = JGLOOFF2 + JLON
        IF (LLPRINT) &
          WRITE (77, '(I0," 2 4 1 1 1 0 ",I0," ",I0," ",I0)') JELT, ICA, ICB, ICC
        JELT = JELT + 1
      ELSEIF ((JLON1 == ILOEN1) .AND. (JLON2 == 1)) THEN
        JLON = JNEXT (JLON1, ILOEN1)
        ICA = JGLOOFF1 + JLON1; ICB = JGLOOFF2 + JLON2; ICC = JGLOOFF1 + JLON
        IF (LLPRINT) &
          WRITE (77, '(I0," 2 4 1 1 1 0 ",I0," ",I0," ",I0)') JELT, ICA, ICB, ICC
        JELT = JELT + 1
      ELSE
        CYCLE
      ENDIF

      EXIT

    ENDDO


  ENDIF
  JGLOOFF = JGLOOFF + YDGRID%NLOEN (JLAT)
ENDDO

  IF (JSTEP == 1) THEN
    WRITE (77, '(A)') '$Elements'
    WRITE (77, '(I0)') JELT-1
  ELSE
    WRITE (77, '(A)') '$EndElements'
  ENDIF

ENDDO


! Node data

WRITE (77, '(A)') '$NodeData'
WRITE (77, '(A)') '1'
WRITE (77, '(A)') '""'
WRITE (77, '(A)') '1'
WRITE (77, '(A)') '0'
WRITE (77, '(A)') '4'
WRITE (77, '(A)') '0'
WRITE (77, '(A)') '1'
WRITE (77, '(I0)') YDGRID%NGPTOTG
WRITE (77, '(I0)') 0

DO JGLOBAL = 1, YDGRID%NGPTOTG
  WRITE (77, '(I0," ",E18.8)') JGLOBAL, ZFLDG (JGLOBAL, 1)
ENDDO

WRITE (77, '(A)') '$EndNodeData'


CLOSE (77)

999 CONTINUE

IF (LHOOK) CALL DR_HOOK ('GMSH',1,ZHOOK_HANDLE)

END SUBROUTINE

SUBROUTINE GET_MY_JLATJLON (YDGRID, YDDIST, KLATLON)

USE MPL_MODULE,        ONLY : MPL_MYRANK, MPL_NUMPROC

TYPE (GRID_t),       INTENT (IN)  :: YDGRID
TYPE (DIST_t),       INTENT (IN)  :: YDDIST
INTEGER (KIND=JPIM), INTENT (OUT) :: KLATLON (:,:)

INTEGER (KIND=JPIM) :: JLAT, JLON, ILOC, JA, JB, IGL, MYPROC
REAL(KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK ('GET_MY_JLATJLON',0,ZHOOK_HANDLE)

MYPROC = MPL_MYRANK ()
JA = YDDIST%NGPPE2SET (1, MYPROC)
JB = YDDIST%NGPPE2SET (2, MYPROC)

ILOC = 1
DO JLAT = YDDIST%NFRSTLAT (JA), YDDIST%NLSTLAT (JA)
  IGL = YDDIST%NPTRFRSTLAT (JA) + JLAT - YDDIST%NFRSTLAT (JA)
  DO JLON = YDDIST%NSTA (IGL, JB), YDDIST%NSTA (IGL, JB) + YDDIST%NONL (IGL, JB)-1
    KLATLON (1,ILOC) = JLAT
    KLATLON (2,ILOC) = JLON
    ILOC = ILOC + 1
  ENDDO
ENDDO

IF (LHOOK) CALL DR_HOOK ('GET_MY_JLATJLON',1,ZHOOK_HANDLE)

END SUBROUTINE

SUBROUTINE GET_MY_XYZ (YDGRID, YDDIST, PXYZ)

USE MPL_MODULE,        ONLY : MPL_MYRANK, MPL_NUMPROC

TYPE (GRID_t),    INTENT (IN)  :: YDGRID
TYPE (DIST_t),    INTENT (IN)  :: YDDIST
REAL (KIND=JPRB), INTENT (OUT) :: PXYZ (:,:)

INTEGER (KIND=JPIM) :: JLAT, JLON, ILOC, JA, JB, IGL, MYPROC
REAL (KIND=JPRB) :: ZLON, ZLAT, ZCOSLON, ZSINLON, ZCOSLAT, ZSINLAT
REAL (KIND=JPRB) :: ZXYZ (3)
REAL(KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK ('GET_MY_XYZ',0,ZHOOK_HANDLE)

MYPROC = MPL_MYRANK ()
JA = YDDIST%NGPPE2SET (1, MYPROC)
JB = YDDIST%NGPPE2SET (2, MYPROC)

ILOC = 1
DO JLAT = YDDIST%NFRSTLAT (JA), YDDIST%NLSTLAT (JA)
  IGL = YDDIST%NPTRFRSTLAT (JA) + JLAT - YDDIST%NFRSTLAT (JA)

  ZLAT = ASIN ((YDGRID%ZOMC2 + YDGRID%RMU (JLAT) * YDGRID%ZOPC2) &
       &     / (YDGRID%ZOPC2 + YDGRID%RMU (JLAT) * YDGRID%ZOMC2))

  ZCOSLAT = COS (ZLAT); ZSINLAT = SIN (ZLAT)

  DO JLON = YDDIST%NSTA (IGL, JB), YDDIST%NSTA (IGL, JB) + YDDIST%NONL (IGL, JB)-1
    ZLON = YDGRID%RLONOFF + 2._JPRB * RPI * REAL (JLON - 1, JPRB) / REAL (YDGRID%NLOEN (JLAT), JPRB)
    ZCOSLON = COS (ZLON); ZSINLON = SIN (ZLON)

    ZXYZ (1) = ZCOSLON * ZCOSLAT
    ZXYZ (2) = ZSINLON * ZCOSLAT
    ZXYZ (3) =           ZSINLAT

    ZXYZ = MATMUL (YDGRID%ZROTD, ZXYZ)

    PXYZ (ILOC, :) = ZXYZ (:)

    ILOC = ILOC + 1
  ENDDO
ENDDO

IF (LHOOK) CALL DR_HOOK ('GET_MY_XYZ',1,ZHOOK_HANDLE)

END SUBROUTINE

SUBROUTINE GET_MY_FACTOR (YDGRID, YDDIST, PFACTOR)

USE MPL_MODULE,        ONLY : MPL_MYRANK, MPL_NUMPROC

TYPE (GRID_t),    INTENT (IN)  :: YDGRID
TYPE (DIST_t),    INTENT (IN)  :: YDDIST
REAL (KIND=JPRB), INTENT (OUT) :: PFACTOR (:)

INTEGER (KIND=JPIM) :: JLAT, JLON, ILOC, JA, JB, IGL, MYPROC
REAL (KIND=JPRB) :: ZLAT, ZSINLAT, ZFACTOR

REAL(KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK ('GET_MY_FACTOR',0,ZHOOK_HANDLE)

IF (YDGRID%LROTATED .OR. YDGRID%LSTRETCH) THEN

  MYPROC = MPL_MYRANK ()
  JA = YDDIST%NGPPE2SET (1, MYPROC)
  JB = YDDIST%NGPPE2SET (2, MYPROC)
  
  ILOC = 1
  DO JLAT = YDDIST%NFRSTLAT (JA), YDDIST%NLSTLAT (JA)
    IGL = YDDIST%NPTRFRSTLAT (JA) + JLAT - YDDIST%NFRSTLAT (JA)
    ZSINLAT = YDGRID%RMU (JLAT)
    ZFACTOR = SQRT ((YDGRID%ZOPC2 + ZSINLAT * YDGRID%ZOMC2) * (YDGRID%ZOPC2 + ZSINLAT * YDGRID%ZOMC2) &
            &     / (YDGRID%ZOPC2 * YDGRID%ZOPC2 - YDGRID%ZOMC2 * YDGRID%ZOMC2))
    DO JLON = YDDIST%NSTA (IGL, JB), YDDIST%NSTA (IGL, JB) + YDDIST%NONL (IGL, JB)-1
      PFACTOR (ILOC) = ZFACTOR
      ILOC = ILOC + 1
    ENDDO
  ENDDO

ELSE

  PFACTOR = 1._JPRB

ENDIF

IF (LHOOK) CALL DR_HOOK ('GET_MY_COORDYX',1,ZHOOK_HANDLE)

END SUBROUTINE

SUBROUTINE GET_MY_COORDYX (YDGRID, YDDIST, PCOORDYX)

USE MPL_MODULE,        ONLY : MPL_MYRANK, MPL_NUMPROC

TYPE (GRID_t),    INTENT (IN)  :: YDGRID
TYPE (DIST_t),    INTENT (IN)  :: YDDIST
REAL (KIND=JPRB), INTENT (OUT) :: PCOORDYX (:,:)

INTEGER (KIND=JPIM) :: JLAT, JLON, ILOC, JA, JB, IGL, MYPROC
REAL (KIND=JPRB) :: ZLAT, ZLON

REAL(KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK ('GET_MY_COORDYX',0,ZHOOK_HANDLE)

MYPROC = MPL_MYRANK ()
JA = YDDIST%NGPPE2SET (1, MYPROC)
JB = YDDIST%NGPPE2SET (2, MYPROC)

ILOC = 1
DO JLAT = YDDIST%NFRSTLAT (JA), YDDIST%NLSTLAT (JA)
  IGL = YDDIST%NPTRFRSTLAT (JA) + JLAT - YDDIST%NFRSTLAT (JA)

  ZLAT = ASIN (YDGRID%RMU (JLAT))

  DO JLON = YDDIST%NSTA (IGL, JB), YDDIST%NSTA (IGL, JB) + YDDIST%NONL (IGL, JB)-1
    ZLON = YDGRID%RLONOFF + R2PI * REAL (JLON - 1, JPRB) / REAL (YDGRID%NLOEN (JLAT), JPRB)

    PCOORDYX (ILOC,1) = ZLAT
    PCOORDYX (ILOC,2) = ZLON

    ILOC = ILOC + 1
  ENDDO
ENDDO

IF (LHOOK) CALL DR_HOOK ('GET_MY_COORDYX',1,ZHOOK_HANDLE)

END SUBROUTINE

SUBROUTINE GET_MY_LATLON (YDGRID, YDDIST, PLATLON)

USE MPL_MODULE,        ONLY : MPL_MYRANK, MPL_NUMPROC

TYPE (GRID_t),    INTENT (IN)  :: YDGRID
TYPE (DIST_t),    INTENT (IN)  :: YDDIST
REAL (KIND=JPRB), INTENT (OUT) :: PLATLON (:,:)

INTEGER (KIND=JPIM) :: JLAT, JLON, ILOC, JA, JB, IGL, MYPROC
REAL (KIND=JPRB) :: ZLAT, ZLON
REAL (KIND=JPRB) :: ZCOSLON, ZSINLON, ZCOSLAT, ZSINLAT
REAL (KIND=JPRB) :: ZXYZ (3)

REAL(KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK ('GET_MY_LATLON',0,ZHOOK_HANDLE)

MYPROC = MPL_MYRANK ()
JA = YDDIST%NGPPE2SET (1, MYPROC)
JB = YDDIST%NGPPE2SET (2, MYPROC)

ILOC = 1
DO JLAT = YDDIST%NFRSTLAT (JA), YDDIST%NLSTLAT (JA)
  IGL = YDDIST%NPTRFRSTLAT (JA) + JLAT - YDDIST%NFRSTLAT (JA)

  IF (YDGRID%LSTRETCH .OR. YDGRID%LROTATED) THEN
    ZLAT = ASIN ((YDGRID%ZOMC2 + YDGRID%RMU (JLAT) * YDGRID%ZOPC2) &
         &     / (YDGRID%ZOPC2 + YDGRID%RMU (JLAT) * YDGRID%ZOMC2))
    ZCOSLAT = COS (ZLAT); ZSINLAT = SIN (ZLAT)
  ELSE
    ZLAT = ASIN (YDGRID%RMU (JLAT))
  ENDIF


  DO JLON = YDDIST%NSTA (IGL, JB), YDDIST%NSTA (IGL, JB) + YDDIST%NONL (IGL, JB)-1
    ZLON = MODULO (YDGRID%RLONOFF + R2PI * REAL (JLON - 1, JPRB) / REAL (YDGRID%NLOEN (JLAT), JPRB), R2PI)

    IF (YDGRID%LSTRETCH .OR. YDGRID%LROTATED) THEN
      ZCOSLON = COS (ZLON); ZSINLON = SIN (ZLON)

      ZXYZ (1) = ZCOSLON * ZCOSLAT
      ZXYZ (2) = ZSINLON * ZCOSLAT
      ZXYZ (3) =           ZSINLAT

      ZXYZ = MATMUL (YDGRID%ZROTD, ZXYZ)

      ZLAT = ASIN (ZXYZ (3))
      ZLON = MODULO (ATAN2 (ZXYZ (2), ZXYZ (1)), R2PI)
    ENDIF

    PLATLON (ILOC,1) = ZLAT
    PLATLON (ILOC,2) = ZLON

    ILOC = ILOC + 1
  ENDDO
ENDDO

IF (LHOOK) CALL DR_HOOK ('GET_MY_LATLON',1,ZHOOK_HANDLE)

END SUBROUTINE

SUBROUTINE GET_MY_GLOBAL (YDGRID, YDDIST, KGLOBAL)

USE MPL_MODULE,        ONLY : MPL_MYRANK, MPL_NUMPROC

TYPE (GRID_t),       INTENT (IN)  :: YDGRID
TYPE (DIST_t),       INTENT (IN)  :: YDDIST
INTEGER (KIND=JPIM), INTENT (OUT) :: KGLOBAL (:)

INTEGER (KIND=JPIM) :: JLAT, JLON, ILOC, JA, JB, IGL, MYPROC, IGLOOFF
REAL(KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK ('GET_MY_GLOBAL',0,ZHOOK_HANDLE)

MYPROC = MPL_MYRANK ()
JA = YDDIST%NGPPE2SET (1, MYPROC)
JB = YDDIST%NGPPE2SET (2, MYPROC)

ILOC = 1
IGLOOFF = SUM (YDGRID%NLOEN (1:YDDIST%NFRSTLAT (JA)-1))
DO JLAT = YDDIST%NFRSTLAT (JA), YDDIST%NLSTLAT (JA)
  IGL = YDDIST%NPTRFRSTLAT (JA) + JLAT - YDDIST%NFRSTLAT (JA)
  DO JLON = YDDIST%NSTA (IGL, JB), YDDIST%NSTA (IGL, JB) + YDDIST%NONL (IGL, JB)-1
    KGLOBAL (ILOC) = IGLOOFF + JLON
    ILOC = ILOC + 1
  ENDDO
  IGLOOFF = IGLOOFF + YDGRID%NLOEN (JLAT)
ENDDO

IF (LHOOK) CALL DR_HOOK ('GET_MY_GLOBAL',1,ZHOOK_HANDLE)

END SUBROUTINE

ELEMENTAL LOGICAL FUNCTION ISINF (P)

REAL (KIND=JPRB), INTENT (IN) :: P

ISINF = ABS (P) > HUGE (P)

END FUNCTION

SUBROUTINE GET_MY_ANGLE (YDGRID, YDDIST, PXYZ, PANGLE)

USE MPL_MODULE,        ONLY : MPL_MYRANK, MPL_NUMPROC

TYPE (GRID_t),    INTENT (IN)  :: YDGRID
TYPE (DIST_t),    INTENT (IN)  :: YDDIST
REAL (KIND=JPRB), INTENT (IN)  :: PXYZ (:,:)
REAL (KIND=JPRB), INTENT (OUT) :: PANGLE (:)

INTEGER (KIND=JPIM) :: ILOC
REAL (KIND=JPRB) :: ZXYZ (3), ZCENTE (3), ZNORTH (3), U1 (3), U0 (3), V0 (3), U0U1, V0U1
REAL (KIND=JPRB) :: ZCOSLON0, ZSINLON0, ZCOSLAT0, ZSINLAT0

REAL(KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK ('GET_MY_ANGLE',0,ZHOOK_HANDLE)

IF (YDGRID%LROTATED .OR. YDGRID%LSTRETCH) THEN

  ZCOSLON0 = COS (YDGRID%RLONCENT); ZSINLON0 = SIN (YDGRID%RLONCENT)
  ZCOSLAT0 = COS (YDGRID%RLATCENT); ZSINLAT0 = SIN (YDGRID%RLATCENT)

  ZCENTE = [ZCOSLON0 * ZCOSLAT0, ZSINLON0 * ZCOSLAT0, ZSINLAT0]
  ZNORTH = [0._JPRB, 0._JPRB, 1._JPRB]

  DO ILOC = 1, SIZE (PXYZ, 1)
! Rotated
    U1 = NORMALIZE (CROSS (ZCENTE, PXYZ (ILOC, :))) 
! Unrotated 
    U0 = NORMALIZE (CROSS (ZNORTH, PXYZ (ILOC, :)))       
    V0 = NORMALIZE (CROSS (PXYZ (ILOC, :), U0))
    U0U1 = DOT_PRODUCT (U0, U1)
    V0U1 = DOT_PRODUCT (V0, U1)
    PANGLE (ILOC) = ATAN2 (V0U1, U0U1)
  ENDDO

ELSE
  PANGLE = 0._JPRB
ENDIF

IF (LHOOK) CALL DR_HOOK ('GET_MY_ANGLE',1,ZHOOK_HANDLE)

CONTAINS

FUNCTION NORMALIZE (PXYZ)

REAL (KIND=JPRB) :: NORMALIZE (3)
REAL (KIND=JPRB), INTENT (IN) :: PXYZ (3)

NORMALIZE = PXYZ / SQRT (DOT_PRODUCT (PXYZ, PXYZ))

END FUNCTION NORMALIZE

FUNCTION CROSS (PXYZ1, PXYZ2)

REAL (KIND=JPRB) :: CROSS (3)
REAL (KIND=JPRB), INTENT (IN) :: PXYZ1 (3), PXYZ2 (3)

CROSS = [ PXYZ1 (2) * PXYZ2 (3) - PXYZ2 (2) * PXYZ1 (3), &
          PXYZ1 (3) * PXYZ2 (1) - PXYZ2 (3) * PXYZ1 (1), &
          PXYZ1 (1) * PXYZ2 (2) - PXYZ2 (1) * PXYZ1 (2) ]

END FUNCTION CROSS

END SUBROUTINE

SUBROUTINE GET_MY_UV (YDGRID, YDDIST, PXYZ, PUV)

USE MPL_MODULE,        ONLY : MPL_MYRANK, MPL_NUMPROC

TYPE (GRID_t),    INTENT (IN)  :: YDGRID
TYPE (DIST_t),    INTENT (IN)  :: YDDIST
REAL (KIND=JPRB), INTENT (IN)  :: PXYZ (:,:)
REAL (KIND=JPRB), INTENT (OUT) :: PUV (:,:)

INTEGER (KIND=JPIM) :: ILOC
REAL (KIND=JPRB) :: ZXYZ (3), ZCENTE (3), ZNORTH (3), U1 (3), V1 (3), U0 (3), V0 (3)
REAL (KIND=JPRB) :: U0U1, V0U1, U0V1, V0V1
REAL (KIND=JPRB) :: ZCOSLON0, ZSINLON0, ZCOSLAT0, ZSINLAT0

REAL(KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK ('GET_MY_UV',0,ZHOOK_HANDLE)

IF (YDGRID%LROTATED .OR. YDGRID%LSTRETCH) THEN

  ZCOSLON0 = COS (YDGRID%RLONCENT); ZSINLON0 = SIN (YDGRID%RLONCENT)
  ZCOSLAT0 = COS (YDGRID%RLATCENT); ZSINLAT0 = SIN (YDGRID%RLATCENT)

  ZCENTE = [ZCOSLON0 * ZCOSLAT0, ZSINLON0 * ZCOSLAT0, ZSINLAT0]
  ZNORTH = [0._JPRB, 0._JPRB, 1._JPRB]

  DO ILOC = 1, SIZE (PXYZ, 1)
! Rotated frame
    U1 = NORMALIZE (CROSS (ZCENTE, PXYZ (ILOC, :))) 
    V1 = NORMALIZE (CROSS (PXYZ (ILOC, :), U1))
! Unrotated frame
    U0 = NORMALIZE (CROSS (ZNORTH, PXYZ (ILOC, :)))       
    V0 = NORMALIZE (CROSS (PXYZ (ILOC, :), U0))
    U0U1 = DOT_PRODUCT (U0, U1)
    V0U1 = DOT_PRODUCT (V0, U1)
    U0V1 = DOT_PRODUCT (U0, V1)
    V0V1 = DOT_PRODUCT (V0, V1)
! Coordinates of rotated frame in unrotated frame
    PUV (ILOC, 1) = U0U1
    PUV (ILOC, 2) = V0U1
    PUV (ILOC, 3) = U0V1
    PUV (ILOC, 4) = V0V1
  ENDDO

ELSE
  PUV (:, 1) = 1._JPRB
  PUV (:, 2) = 0._JPRB
  PUV (:, 3) = 0._JPRB
  PUV (:, 4) = 1._JPRB
ENDIF

IF (LHOOK) CALL DR_HOOK ('GET_MY_UV',1,ZHOOK_HANDLE)

CONTAINS

FUNCTION NORMALIZE (PXYZ)

REAL (KIND=JPRB) :: NORMALIZE (3)
REAL (KIND=JPRB), INTENT (IN) :: PXYZ (3)

NORMALIZE = PXYZ / SQRT (DOT_PRODUCT (PXYZ, PXYZ))

END FUNCTION NORMALIZE

FUNCTION CROSS (PXYZ1, PXYZ2)

REAL (KIND=JPRB) :: CROSS (3)
REAL (KIND=JPRB), INTENT (IN) :: PXYZ1 (3), PXYZ2 (3)

CROSS = [ PXYZ1 (2) * PXYZ2 (3) - PXYZ2 (2) * PXYZ1 (3), &
          PXYZ1 (3) * PXYZ2 (1) - PXYZ2 (3) * PXYZ1 (1), &
          PXYZ1 (1) * PXYZ2 (2) - PXYZ2 (1) * PXYZ1 (2) ]

END FUNCTION CROSS

END SUBROUTINE

END MODULE HADES

