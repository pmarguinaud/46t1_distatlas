MODULE MODGIBBS

USE PARKIND1, ONLY : JPIM, JPRB
USE YOMHOOK, ONLY : DR_HOOK, LHOOK

USE M1QN3MOD, ONLY : M1QN3CTX
USE HADES

IMPLICIT NONE

TYPE, EXTENDS (M1QN3CTX) :: MODGIBBSCTX
  REAL (KIND=JPRB), ALLOCATABLE :: ZORO0 (:)  ! Original grid-point orography
  REAL (KIND=JPRB), ALLOCATABLE :: ZWGHT (:)  ! Weights
  REAL (KIND=JPRB), ALLOCATABLE :: ZWONL (:)  ! Weight
  REAL (KIND=JPRB) :: HDIM = 1._JPRB
  INTEGER (KIND=JPIM) :: NRESOL, NGPTOT, MYSETW, MYSETV, NSMAX, NGPTOTG, NSPEC2G, NSPEC2
  LOGICAL :: LDEBUG = .FALSE.
  INTEGER (KIND=JPIM) :: NCALL = 0
  CONTAINS
    PROCEDURE :: SIMUL          => SIMUL
    PROCEDURE :: PROSCA         => PROSCA
    PROCEDURE :: INIT           => INIT   
    PROCEDURE :: DIRTRANS       => DIRTRANS
    PROCEDURE :: INVTRANS       => INVTRANS
    PROCEDURE :: INVTRANSAD     => INVTRANSAD
    PROCEDURE :: BOUTELOUP_FUNCTION => BOUTELOUP_FUNCTION
    PROCEDURE :: REDUCER        => REDUCER_SPEC
END TYPE

CONTAINS

SUBROUTINE INIT (YDCTX, YDGRID, YDDIST, POROG)

USE MPL_MODULE,         ONLY : MPL_MYRANK, MPL_NUMPROC
USE MPL_ALLGATHERV_MOD, ONLY : MPL_ALLGATHERV

CLASS (MODGIBBSCTX), INTENT (INOUT) :: YDCTX
TYPE (GRID_t),       INTENT (IN)    :: YDGRID
TYPE (DIST_t),       INTENT (IN)    :: YDDIST
REAL (KIND=JPRB),    INTENT (IN)    :: POROG (:) ! Grid-point orography

#include "trans_inq.h"

REAL (KIND=JPRB) :: ZMUA (YDGRID%NDGLG), ZGWA (YDGRID%NDGLG)
INTEGER (KIND=JPIM) :: IPROC

REAL (KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK ('MODGIBBS:INIT',0,ZHOOK_HANDLE)

YDCTX%MYPROC = MPL_MYRANK ()
YDCTX%NPROC  = MPL_NUMPROC 
YDCTX%NRESOL = YDDIST%NRESOL

ALLOCATE (YDCTX%N (YDCTX%NPROC))

CALL TRANS_INQ (KSPEC2=YDCTX%NSPEC2,   KGPTOT=YDCTX%NGPTOT,   &
              & KSMAX=YDCTX%NSMAX,     KMYSETW=YDCTX%MYSETW,  &
              & KMYSETV=YDCTX%MYSETV,  KSPEC2G=YDCTX%NSPEC2G, &
              & KGPTOTG=YDCTX%NGPTOTG, KRESOL=YDDIST%NRESOL)

CALL MPL_ALLGATHERV (KSENDBUF=[YDCTX%NSPEC2], KRECVBUF=YDCTX%N,  &
                   & KRECVCOUNTS=[(1, IPROC=1, YDCTX%NPROC)],    &
                   & CDSTRING='MODGIBBS:INIT:')

ALLOCATE (YDCTX%ZORO0 (YDCTX%NGPTOT), &
        & YDCTX%ZWGHT (YDCTX%NGPTOT), &
        & YDCTX%ZWONL (YDCTX%NGPTOT))

CALL TRANS_INQ (PGW=ZGWA, PMU=ZMUA, KSMAX=YDCTX%NSMAX, &
              & KRESOL=YDDIST%NRESOL)

YDCTX%ZORO0 = POROG

BLOCK ! Yves Bouteloup cost-function weights
  REAL (KIND=JPRB), PARAMETER :: RSTRET = 1._JPRB
  REAL (KIND=JPRB), PARAMETER :: QMIN = 2._JPRB, QMAX = 4._JPRB, HMIN = 150._JPRB, HDIM = 1._JPRB
  REAL (KIND=JPRB) :: ZC2P1, ZC2M1, ZC2, ZWONL, ZMU, ZFAK
  INTEGER (KIND=JPIM) :: ILOC, JLAT, JLON
  TYPE (REGION_t) :: YLMYREG

  YDCTX%HDIM = HDIM

  CALL GET_MYREGION (YLMYREG, YDDIST, YDGRID)

  ZC2P1 = RSTRET * RSTRET + 1.0_JPRB
  ZC2M1 = RSTRET * RSTRET - 1.0_JPRB
  ZC2  = ZC2M1 / ZC2P1

  ILOC = 1
  DO JLAT = YLMYREG%NLAN, YLMYREG%NLAS
    ZMU = (ZMUA (JLAT) - 1.0_JPRB) / (ZC2P1 + ZMUA (JLAT) * ZC2M1)
    ZFAK = 1.0_JPRB + ZC2 * ZMU
    ZWONL = ZGWA (JLAT) / YDGRID%NLOEN (JLAT)
    DO JLON = YLMYREG%NLOW (JLAT), YLMYREG%NLOE (JLAT)
      YDCTX%ZWONL (ILOC) = ZWONL
      YDCTX%ZWGHT (ILOC) = QMIN + (QMAX - QMIN) * ZFAK * EXP (-ABS (YDCTX%ZORO0 (ILOC)) / HMIN) * 1._JPRB ! *(1.0_JPRB + XINCOC * PSFRC (JI, JL))  ! Avoid sea fraction for now
      ILOC = ILOC + 1
    ENDDO
  ENDDO

ENDBLOCK

IF (LHOOK) CALL DR_HOOK ('MODGIBBS:INIT',1,ZHOOK_HANDLE)

END SUBROUTINE

SUBROUTINE INVTRANS (YDCTX, PSPEC, PGRID)

CLASS (MODGIBBSCTX), INTENT (INOUT) :: YDCTX
REAL (KIND=JPRB),    INTENT (IN)    :: PSPEC (:)
REAL (KIND=JPRB),    INTENT (OUT)   :: PGRID (:)
REAL (KIND=JPRB) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK ('MODGIBBS:INVTRANS',0,ZHOOK_HANDLE)
CALL DO_INVTRANS (PGRID, PSPEC, SIZE (PGRID), SIZE (PSPEC), YDCTX%NRESOL)
IF (LHOOK) CALL DR_HOOK ('MODGIBBS:INVTRANS',1,ZHOOK_HANDLE)
CONTAINS
SUBROUTINE DO_INVTRANS (PGRID, PSPEC, KGRIDL, KSPECL, KRESOL)
REAL (KIND=JPRB),    INTENT (OUT)   :: PGRID (KGRIDL, 1, 1)
REAL (KIND=JPRB),    INTENT (IN)    :: PSPEC (1, KSPECL)
INTEGER (KIND=JPIM), INTENT (IN)    :: KGRIDL
INTEGER (KIND=JPIM), INTENT (IN)    :: KSPECL
INTEGER (KIND=JPIM), INTENT (IN)    :: KRESOL
#include "inv_trans.h"
CALL INV_TRANS (PSPSCALAR=PSPEC, PGP=PGRID, KVSETSC=[1_JPIM], KRESOL=KRESOL)
END SUBROUTINE DO_INVTRANS

END SUBROUTINE INVTRANS

SUBROUTINE DIRTRANS (YDCTX, PGRID, PSPEC)
CLASS (MODGIBBSCTX),  INTENT (INOUT) :: YDCTX
REAL (KIND=JPRB),    INTENT (IN)    :: PGRID (:)
REAL (KIND=JPRB),    INTENT (OUT)   :: PSPEC (:)
REAL (KIND=JPRB) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK ('MODGIBBS:DIRTRANS',0,ZHOOK_HANDLE)
CALL DO_DIRTRANS (PGRID, PSPEC, SIZE (PGRID), SIZE (PSPEC), YDCTX%NRESOL)
IF (LHOOK) CALL DR_HOOK ('MODGIBBS:DIRTRANS',1,ZHOOK_HANDLE)
CONTAINS
SUBROUTINE DO_DIRTRANS (PGRID, PSPEC, KGRIDL, KSPECL, KRESOL)
REAL (KIND=JPRB),    INTENT (IN)    :: PGRID (KGRIDL, 1, 1)
REAL (KIND=JPRB),    INTENT (INOUT) :: PSPEC (1, KSPECL)
INTEGER (KIND=JPIM), INTENT (IN)    :: KGRIDL
INTEGER (KIND=JPIM), INTENT (IN)    :: KSPECL
INTEGER (KIND=JPIM), INTENT (IN)    :: KRESOL
#include "dir_trans.h"
CALL DIR_TRANS (PSPSCALAR=PSPEC, PGP=PGRID, KVSETSC=[1_JPIM], KRESOL=KRESOL)
END SUBROUTINE DO_DIRTRANS
END SUBROUTINE DIRTRANS

SUBROUTINE INVTRANSAD (YDCTX, PGRID, PSPEC)
CLASS (MODGIBBSCTX), INTENT (INOUT) :: YDCTX
REAL (KIND=JPRB),    INTENT (IN)    :: PGRID (:)
REAL (KIND=JPRB),    INTENT (OUT)   :: PSPEC (:)
REAL (KIND=JPRB) :: ZHOOK_HANDLE
IF (LHOOK) CALL DR_HOOK ('MODGIBBS:INVTRANSAD',0,ZHOOK_HANDLE)
CALL DO_INVTRANSAD (PGRID, PSPEC, SIZE (PGRID), SIZE (PSPEC), YDCTX%NRESOL)
IF (LHOOK) CALL DR_HOOK ('MODGIBBS:INVTRANSAD',1,ZHOOK_HANDLE)
CONTAINS
SUBROUTINE DO_INVTRANSAD (PGRID, PSPEC, KGRIDL, KSPECL, KRESOL)
REAL (KIND=JPRB),    INTENT (IN)    :: PGRID (KGRIDL, 1, 1)
REAL (KIND=JPRB),    INTENT (INOUT) :: PSPEC (1, KSPECL)
INTEGER (KIND=JPIM), INTENT (IN)    :: KGRIDL
INTEGER (KIND=JPIM), INTENT (IN)    :: KSPECL
INTEGER (KIND=JPIM), INTENT (IN)    :: KRESOL
#include "inv_transad.h"
CALL INV_TRANSAD (PSPSCALAR=PSPEC, PGP=PGRID, KVSETSC=[1_JPIM], KRESOL=KRESOL)
END SUBROUTINE DO_INVTRANSAD
END SUBROUTINE INVTRANSAD

SUBROUTINE BOUTELOUP_FUNCTION (YDCTX, PSPEC, PFUNC, PGRAD)

IMPLICIT NONE
CLASS (MODGIBBSCTX) :: YDCTX
REAL (KIND=JPRB), INTENT (IN)  :: PSPEC (:)
REAL (KIND=JPRB), INTENT (OUT) :: PFUNC (:)             ! Grid-point function
REAL (KIND=JPRB), INTENT (OUT), OPTIONAL :: PGRAD (:)   ! Grid-point gradient

INTEGER (KIND=JPIM) :: JLOC
REAL (KIND=JPRB) :: ZOROG (YDCTX%NGPTOT)
LOGICAL :: LLGRAD

REAL (KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK ('MODGIBBS:BOUTELOUP_FUNCTION',0,ZHOOK_HANDLE)

LLGRAD = PRESENT (PGRAD)

CALL YDCTX%INVTRANS (PSPEC, ZOROG) ! Go back to grid-point

DO JLOC = 1, YDCTX%NGPTOT

  PFUNC (JLOC) = (ABS (ZOROG (JLOC) - YDCTX%ZORO0 (JLOC)) / YDCTX%HDIM)**YDCTX%ZWGHT (JLOC)


  IF (LLGRAD) THEN
    PGRAD (JLOC) = YDCTX%ZWGHT (JLOC) *  (ZOROG (JLOC) - YDCTX%ZORO0 (JLOC)) * &
     & (ABS (ZOROG (JLOC) - YDCTX%ZORO0 (JLOC)) / YDCTX%HDIM) &
     & **(YDCTX%ZWGHT(JLOC) - 2.0_JPRB) / YDCTX%HDIM**2  
  ENDIF

ENDDO

IF (LHOOK) CALL DR_HOOK ('MODGIBBS:BOUTELOUP_FUNCTION',1,ZHOOK_HANDLE)

END SUBROUTINE

SUBROUTINE SIMUL (YDCTX, INDIC, N, X, F, G, LGRAD)

USE MPL_ALLREDUCE_MOD, ONLY : MPL_ALLREDUCE

IMPLICIT NONE
CLASS (MODGIBBSCTX) :: YDCTX
INTEGER (KIND=JPIM) :: INDIC, N
REAL (KIND=JPRB) :: X (N), F, G (N)
LOGICAL, OPTIONAL :: LGRAD
REAL (KIND=JPRB) :: ZGRAD (YDCTX%NGPTOT)
REAL (KIND=JPRB) :: ZOROG (YDCTX%NGPTOT)
REAL (KIND=JPRB) :: ZFUNC (YDCTX%NGPTOT)
INTEGER (KIND=JPIM) :: IPOS
LOGICAL :: LLGRAD

REAL (KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK ('MODGIBBS:SIMUL',0,ZHOOK_HANDLE)

LLGRAD = .TRUE.
IF (PRESENT (LGRAD)) LLGRAD = LGRAD

IF (INDIC.EQ.1) THEN
  WRITE (YDCTX%IOOUT, '(A)') "FREE CALL TO SIMUL"
  RETURN
ENDIF

CALL YDCTX%INVTRANS (X, ZOROG) ! Go back to grid-point

IF (LLGRAD) THEN
  CALL YDCTX%BOUTELOUP_FUNCTION (X, ZFUNC, ZGRAD)
  ZGRAD = ZGRAD * YDCTX%ZWONL

! Need to set G to zero because of adjoint code

  G = 0._JPRB
  CALL YDCTX%INVTRANSAD (ZGRAD, G)

! Force imaginary part of first coefficients to zero
  IF (YDCTX%MYSETW == 1) THEN
    IPOS = 2 * (YDCTX%NSMAX + 1)
    G (2:IPOS:2) = 0._JPRB
  ENDIF

ELSE
  CALL YDCTX%BOUTELOUP_FUNCTION (X, ZFUNC)
ENDIF

ZFUNC = ZFUNC * YDCTX%ZWONL

CALL DO_GPSUM (ZFUNC, F)

IF (YDCTX%LDEBUG) THEN

  BLOCK
    REAL (KIND=JPRB) :: ZNORM2, ZMINS, ZMAXS, ZMINW, ZMAXW
   
    ZNORM2 = SUM (YDCTX%ZWONL * (ZOROG-YDCTX%ZORO0)**2)
    CALL MPL_ALLREDUCE (PSENDBUF=ZNORM2, CDOPER='SUM',  &
                      & CDSTRING='MODGIBBS:SIMUL',      &
                      & LDREPROD=.FALSE.)
    ZNORM2 = SQRT (ZNORM2)
   
    ZMINW = MINVAL (ZOROG-YDCTX%ZORO0)
    ZMAXW = MAXVAL (ZOROG-YDCTX%ZORO0)
    ZMINS = MINVAL (ZOROG-YDCTX%ZORO0, MASK=ABS (YDCTX%ZORO0) < 0.01_JPRB)
    ZMAXS = MAXVAL (ZOROG-YDCTX%ZORO0, MASK=ABS (YDCTX%ZORO0) < 0.01_JPRB)

    CALL MPL_ALLREDUCE (PSENDBUF=ZMINS, CDOPER='MIN',  &
                      & CDSTRING='MODGIBBS:SIMUL',     &
                      & LDREPROD=.FALSE.)
   
    CALL MPL_ALLREDUCE (PSENDBUF=ZMINW, CDOPER='MIN',  &
                      & CDSTRING='MODGIBBS:SIMUL',     &
                      & LDREPROD=.FALSE.)
   
    CALL MPL_ALLREDUCE (PSENDBUF=ZMAXS, CDOPER='MAX',  &
                      & CDSTRING='MODGIBBS:SIMUL',     &
                      & LDREPROD=.FALSE.)
   
    CALL MPL_ALLREDUCE (PSENDBUF=ZMAXW, CDOPER='MAX',  &
                      & CDSTRING='MODGIBBS:SIMUL',     &
                      & LDREPROD=.FALSE.)
   
   
    IF (YDCTX%NCALL == 0) THEN
      WRITE (YDCTX%IOOUT, '("MODGIBBS: ",A15," ",A15," ",A15," ",A15," ",A15," ",A15," ",A15)') &
                         & "ITERATION", "MINVAL WORLD", "MAXVAL WORLD", "MINVAL SEA", "MAXVAL SEA", "NORM2", "BOUTELOUP"
    ENDIF
    YDCTX%NCALL = YDCTX%NCALL + 1

    WRITE (YDCTX%IOOUT, '("MODGIBBS: ",I15," ",F15.3," ",F15.3," ",F15.3," ",F15.3," ",F15.3," ",F15.3)')  &
                       & YDCTX%NCALL, ZMINW, ZMAXW, ZMINS, ZMAXS, ZNORM2, F
  ENDBLOCK

ENDIF

IF (LHOOK) CALL DR_HOOK ('MODGIBBS:SIMUL',1,ZHOOK_HANDLE)

CONTAINS

SUBROUTINE DO_GPSUM (PGP, PSUM)

USE MPL_BROADCAST_MOD, ONLY : MPL_BROADCAST

REAL (KIND=JPRB), INTENT (IN)  :: PGP (YDCTX%NGPTOT, 1, 1)
REAL (KIND=JPRB), INTENT (OUT) :: PSUM

#include "gath_grid.h"

REAL (KIND=JPRB), ALLOCATABLE :: ZGPG (:,:)

IF (YDCTX%LREPRO) THEN

  IF (YDCTX%MYPROC == 1) THEN
    ALLOCATE (ZGPG (YDCTX%NGPTOTG, 1))
    CALL GATH_GRID (KFGATHG=1_JPIM, KTO=[1_JPIM], KRESOL=YDCTX%NRESOL, PGP=PGP, PGPG=ZGPG)
    PSUM = SUM (ZGPG)
  ELSE
    CALL GATH_GRID (KFGATHG=1_JPIM, KTO=[1_JPIM], KRESOL=YDCTX%NRESOL, PGP=PGP)
  ENDIF

  CALL MPL_BROADCAST (PSUM, 0_JPIM, CDSTRING='MODGIBBS:SIMUL')

ELSE
  PSUM = SUM (PGP)
  CALL MPL_ALLREDUCE (PSENDBUF=PSUM, CDOPER='SUM', &
                    & CDSTRING='MODGIBBS:SIMUL',   &
                    & LDREPROD=.FALSE.)
ENDIF

END SUBROUTINE

END SUBROUTINE

SUBROUTINE PROSCA (YDCTX, N, X, Y, PS)

IMPLICIT NONE

CLASS (MODGIBBSCTX) :: YDCTX
INTEGER (KIND=JPIM) :: N, I
REAL (KIND=JPRB) :: X (N), Y (N), PS
REAL (KIND=JPRB) :: ZZ (N)
INTEGER (KIND=JPIM) :: IPOS

REAL (KIND=JPRB) :: ZHOOK_HANDLE

IF (LHOOK) CALL DR_HOOK ('MODGIBBS:PROSCA',0,ZHOOK_HANDLE)

! Scalar product in spectral space

IF (YDCTX%MYSETW == 1) THEN
  IPOS = 2 * (YDCTX%NSMAX + 1)
ELSE
  IPOS = 0
ENDIF

ZZ (1:IPOS)   =     X (1:IPOS)   * Y (1:IPOS)
ZZ (IPOS+1:N) = 2 * X (IPOS+1:N) * Y (IPOS+1:N)

CALL YDCTX%REDUCER (N, ZZ, 'SUM', PS)

IF (LHOOK) CALL DR_HOOK ('MODGIBBS:PROSCA',1,ZHOOK_HANDLE)

END SUBROUTINE PROSCA

SUBROUTINE REDUCER_SPEC (YDCTX, N, X, OP, V)
USE MPL_ALLREDUCE_MOD, ONLY : MPL_ALLREDUCE
IMPLICIT NONE

CLASS (MODGIBBSCTX) YDCTX
REAL (KIND=JPRB) X (N), V
CHARACTER (LEN=*) OP
INTEGER (KIND=JPIM) N

IF (N /= YDCTX%NSPEC2) THEN
  CALL ABORT
ENDIF

SELECT CASE (OP)
  CASE ('MAX')
    V = MAXVAL (X)
    CALL MPL_ALLREDUCE (V, 'MAX', CDSTRING='MODGIBBS:REDUCER_SPEC')
  CASE ('SUM')
    CALL DO_SPSUM (X, V)
  CASE ('AVG')
    CALL DO_SPSUM (X, V)
    V = V / SUM (YDCTX%N)
  CASE DEFAULT
    CALL ABORT
END SELECT

CONTAINS

SUBROUTINE DO_SPSUM (PSPEC, PSUM)

USE MPL_BROADCAST_MOD, ONLY : MPL_BROADCAST

REAL (KIND=JPRB), INTENT (IN)  :: PSPEC (YDCTX%NSPEC2,1)
REAL (KIND=JPRB), INTENT (OUT) :: PSUM


#include "gath_spec.h"

REAL (KIND=JPRB), ALLOCATABLE :: ZSPECG (:,:)

IF (YDCTX%LREPRO) THEN
  IF (YDCTX%MYPROC == 1) THEN
    ALLOCATE (ZSPECG (YDCTX%NSPEC2G,1))
    CALL GATH_SPEC (KFGATHG=1_JPIM, KTO=[1_JPIM], KVSET=[1_JPIM], LDZA0IP=.TRUE., &
                  & LDIM1_IS_FLD=.FALSE., KRESOL=YDCTX%NRESOL, PSPEC=PSPEC, PSPECG=ZSPECG)
    PSUM = SUM (ZSPECG)
  ELSE
    CALL GATH_SPEC (KFGATHG=1_JPIM, KTO=[1_JPIM], KVSET=[1_JPIM], LDZA0IP=.TRUE., &
                  & LDIM1_IS_FLD=.FALSE., KRESOL=YDCTX%NRESOL, PSPEC=PSPEC)
  ENDIF
  CALL MPL_BROADCAST (PSUM, 0_JPIM, CDSTRING='MODGIBBS:REDUCER_SPEC')
ELSE
  PSUM = SUM (PSPEC)
  CALL MPL_ALLREDUCE (PSUM, 'SUM', CDSTRING='MODGIBBS:REDUCER_SPEC', LDREPROD=.FALSE.)
ENDIF

END SUBROUTINE

END SUBROUTINE

END MODULE MODGIBBS

