PROGRAM TEST

USE MPL_END_MOD, ONLY : MPL_END
USE MPL_INIT_MOD, ONLY : MPL_INIT
USE PARKIND1, ONLY : JPIM, JPRB
USE MPL_MODULE, ONLY : MPL_MYRANK, MPL_GROUPS_CREATE, MPL_NUMPROC
USE MPL_BARRIER_MOD, ONLY : MPL_BARRIER
USE YOMHOOK, ONLY : DR_HOOK, LHOOK

USE HADES

USE MODGIBBS, ONLY : MODGIBBSCTX

IMPLICIT NONE

INTEGER(KIND=JPIM) :: NPRGPNS, NPRGPEW, NPRTRW, NPRTRV, NPRINTLEV
INTEGER(KIND=JPIM) :: MYPROC, NPROC

INTEGER (KIND=JPIM) :: IA, IB

TYPE (GRID_t) :: YLGRID
TYPE (DIST_t) :: YLDIST

TYPE (MODGIBBSCTX) :: YLCTX
CHARACTER (LEN=64) :: CLFILE
LOGICAL :: LREPRO, LDEBUG, LTAYLOR
REAL (KIND=JPRB), ALLOCATABLE :: ZZSL (:, :)
INTEGER (KIND=JPIM) :: NSPEC2, NGPTOT

#include "setup_trans0.h"
#include "posnam.intfb.h"

NAMELIST / NAMAAGIBBS / NPRINTLEV, CLFILE, LREPRO, LDEBUG, LTAYLOR

REAL (KIND=JPRB) :: ZHOOK_HANDLE

OPEN (4, FORM='FORMATTED')

NPRINTLEV = 0
LREPRO    = .FALSE.
LDEBUG    = .FALSE.
LTAYLOR   = .FALSE.

CALL POSNAM (4, 'NAMAAGIBBS')
READ (4, NAMAAGIBBS)

CALL MPL_INIT (LDENV = .FALSE.)

MYPROC = MPL_MYRANK ()
NPROC  = MPL_NUMPROC

CALL SQUARE (NPROC, IA, IB)

NPRGPNS = IA
NPRGPEW = IB
NPRTRW  = NPROC
NPRTRV  = 1

CALL MPL_GROUPS_CREATE (NPRTRW, NPRTRV)

CALL SETUP_TRANS0 (KOUT=0, KERR=0, KPRINTLEV=NPRINTLEV, KMAX_RESOL=3,  &
                 & KPRGPNS=NPRGPNS, KPRGPEW=NPRGPEW, KPRTRW=NPRTRW,    &
                 & LDEQ_REGIONS=.TRUE.)

CALL MPL_BARRIER()

IF (LHOOK) CALL DR_HOOK ('AAGIBBS',0,ZHOOK_HANDLE)

CALL CREATE_GRID_DIST_FA (YLGRID, YLDIST, CLFILE, &
                        & GRID_OPTIONS_t (LGRIDONLY=.FALSE.))

NGPTOT = YLDIST%NGPTOTL (MYPROC)
NSPEC2 = YLDIST%NSPEC2L (MYPROC)

ALLOCATE (ZZSL (NGPTOT, 1))

BLOCK
  CHARACTER (LEN=*), PARAMETER :: CLNOMC = 'c'
  INTEGER (KIND=JPIM) :: ILUN, IREP, INBARP, INBARI
  INTEGER (KIND=JPIM) :: IFLD2PROC (1)
  REAL (KIND=JPRB) :: ZZSG (YLGRID%NGPTOTG, 1)

  IFLD2PROC = 1

  IF (MYPROC == 1) THEN
    ILUN = 77_JPIM
    CALL FAITOU (IREP, ILUN, .TRUE., TRIM (CLFILE), 'OLD', &
               & .TRUE., .TRUE., 2_JPIM, INBARP, INBARI, CLNOMC)
    CALL FACILE (IREP, ILUN, "SFX.", 0_JPIM, "ZS", ZZSG, .FALSE.)
    CALL FAIRME (IREP, ILUN, 'KEEP')
    CALL GRID_DIST (PGPG=ZZSG, KFIELDG=1, KFLD2PROC=IFLD2PROC, &
                  & YDGRID=YLGRID, YDDIST=YLDIST, PGP=ZZSL)
  ELSE
    CALL GRID_DIST (KFIELDG=1, KFLD2PROC=IFLD2PROC, &
                  & YDGRID=YLGRID, YDDIST=YLDIST, PGP=ZZSL)
  ENDIF

ENDBLOCK

BLOCK
  REAL (KIND=JPRB) :: ZSPEC (NSPEC2)
  REAL (KIND=JPRB) :: ZGRAD (NSPEC2)
  REAL (KIND=JPRB) :: ZZSLF (NGPTOT)
  REAL (KIND=JPRB) :: ZDIFF (NGPTOT)
  REAL (KIND=JPRB) :: ZF

  CALL YLCTX%INIT (YLGRID, YLDIST, ZZSL (:, 1))

  IF (LTAYLOR) THEN
    CALL YLCTX%DIRTRANS (ZZSL (:, 1), ZSPEC)
    CALL YLCTX%DO_TEST_TAYLOR (ZSPEC, NSPEC2)
  ELSE

    YLCTX%LDEBUG = LDEBUG
    YLCTX%LREPRO = LREPRO

    CALL WFA (YLCTX%ZWONL, NGPTOT, 1_JPIM, "ZWONL.fa", ["SURF"], &
            & [0_JPIM], ["WONL"], YLGRID, YLDIST)
    
    CALL WFA (YLCTX%ZWGHT, NGPTOT, 1_JPIM, "ZWGHT.fa", ["SURF"], &
            & [0_JPIM], ["WGHT"], YLGRID, YLDIST)
    

    CALL YLCTX%DIRTRANS (ZZSL (:, 1), ZSPEC)
    CALL YLCTX%INVTRANS (ZSPEC, ZZSLF)

    CALL YLCTX%SIMUL (0_JPIM, NSPEC2, ZSPEC, ZF, ZGRAD)
    CALL WFA (ZZSLF, NGPTOT, 1_JPIM, "ZSFIT.fa", ["SFX."], &
            & [0_JPIM], ["ZS"], YLGRID, YLDIST)


    ZDIFF = ZZSLF - ZZSL (:, 1)
    WHERE (ABS (ZZSL (:, 1)) > 0.01_JPRB)
      ZDIFF = 0._JPRB
    ENDWHERE

    CALL WFA (ZDIFF, NGPTOT, 1_JPIM, "ZSDIFF1.fa", ["SFX."], &
            & [0_JPIM], ["ZSDIFF"], YLGRID, YLDIST)


    IF (LDEBUG) CALL PRINTSTAT (ZZSLF)

    BLOCK
      INTEGER (KIND=JPIM) :: IZ (5), NDZ, REVERSE, INDIC, ISIM, IERR, ITER
      REAL (KIND=JPRB) :: ZF1, ZXMIN
      REAL (KIND=JPRB), ALLOCATABLE :: DZ (:)

      NDZ = 6 * YLCTX%N (MYPROC) + 1000
      ALLOCATE (DZ (NDZ))

      ZF1 = ZF

      ITER    = 600_JPIM
      ISIM    = 2 * ITER
      REVERSE = 0_JPIM
      INDIC   = 4_JPIM
      ZXMIN   = 3.E-5_JPRB

      CALL YLCTX%M1QN3 (YLCTX%N (MYPROC), ZSPEC, ZF, ZGRAD, ZXMIN, ZF1, 1.E-6_JPRB,  &
                      & 'DFN', 5_JPIM, 6_JPIM, [1_JPIM, 0_JPIM, 0_JPIM], IERR, ITER, &
                      & ISIM, IZ, DZ, NDZ, REVERSE, INDIC)

    ENDBLOCK

    CALL YLCTX%INVTRANS (ZSPEC, ZZSLF)

    IF (LDEBUG) CALL PRINTSTAT (ZZSLF)

    CALL WFA (ZZSLF, NGPTOT, 1_JPIM, "ZGIBBS.fa", ["SFX."], &
            & [0_JPIM], ["ZS"], YLGRID, YLDIST)
  
    ZDIFF = ZZSLF - ZZSL (:, 1)
    WHERE (ABS (ZZSL (:, 1)) > 0.01_JPRB)
      ZDIFF = 0._JPRB
    ENDWHERE

    CALL WFA (ZDIFF, NGPTOT, 1_JPIM, "ZSDIFF2.fa", ["SFX."], &
            & [0_JPIM], ["ZSDIFF"], YLGRID, YLDIST)

  ENDIF

ENDBLOCK


IF (LHOOK) CALL DR_HOOK ('AAGIBBS',1,ZHOOK_HANDLE)

CALL MPL_END

CONTAINS

SUBROUTINE PRINTSTAT (PZSLF)

REAL (KIND=JPRB), INTENT (IN) :: PZSLF (:)

REAL (KIND=JPRB) :: ZLATLON (NGPTOT, 2)
REAL (KIND=JPRB) :: ZDIFF (NGPTOT)
INTEGER (KIND=JPIM) :: IORD (NGPTOT), JLOC, JJ, ICNT

WRITE (0, '(A15," ",A15," ",A15," ",A15)') "MINVAL LAND", "MAXVAL LAND", "MINVAL SEA", "MAXVAL SEA"
WRITE (0, '(F15.3," ",F15.3," ",F15.3," ",F15.3)')  &
                             & MINVAL (PZSLF-ZZSL (:,1)), MAXVAL (PZSLF-ZZSL (:,1)), &
                             & MINVAL (PZSLF-ZZSL (:,1), MASK=ABS (ZZSL (:, 1)) < 0.01_JPRB), &
                             & MAXVAL (PZSLF-ZZSL (:,1), MASK=ABS (ZZSL (:, 1)) < 0.01_JPRB)

ZDIFF = -ABS (PZSLF-ZZSL (:,1))

CALL QSORTR8 (NGPTOT, IORD, ZDIFF)

CALL GET_MY_LATLON (YLGRID, YLDIST, ZLATLON)

WRITE (0, *) "WORLD: HIGHEST DIFFERENCES"
WRITE (0, '(5A15)') "DIFFERENCE", "SPECTRAL FIT", "ORIGINAL", "LAT", "LON"
ICNT = 0
DO JJ = 1, NGPTOT
  JLOC = IORD (JJ)
  WRITE (0, '(5F15.3)') PZSLF (JLOC)-ZZSL (JLOC, 1), PZSLF (JLOC), ZZSL (JLOC, 1), ZLATLON (JLOC, :) * RAD2DEG
  ICNT = ICNT + 1
  IF (ICNT > 20) EXIT
ENDDO
WRITE (0, *)

WRITE (0, *) "SEA: HIGHEST DIFFERENCES"
WRITE (0, '(5A15)') "DIFFERENCE", "SPECTRAL FIT", "ORIGINAL", "LAT", "LON"
ICNT = 0
DO JJ = 1, NGPTOT
  JLOC = IORD (JJ)
  IF (ABS (ZZSL (JLOC, 1)) < 0.01_JPRB) THEN
    WRITE (0, '(5F15.3)') PZSLF (JLOC)-ZZSL (JLOC, 1), PZSLF (JLOC), ZZSL (JLOC, 1), ZLATLON (JLOC, :) * RAD2DEG
    ICNT = ICNT + 1
    IF (ICNT > 20) EXIT
  ENDIF
ENDDO
WRITE (0, *)

END SUBROUTINE

SUBROUTINE SQUARE (KN, KA, KB)

INTEGER (KIND=JPIM) :: KN, KA, KB

KB = INT (SQRT (REAL (KN))) + 1

DO
  KA = KN / KB
  IF (KA * KB == KN) EXIT
  KB = KB - 1
ENDDO

END SUBROUTINE SQUARE

END PROGRAM TEST

