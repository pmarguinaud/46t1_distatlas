PROGRAM TEST

USE MPL_END_MOD, ONLY : MPL_END
USE MPL_INIT_MOD, ONLY : MPL_INIT
USE PARKIND1, ONLY : JPIM, JPRB
USE MPL_MODULE, ONLY : MPL_MYRANK, MPL_GROUPS_CREATE, MPL_NUMPROC
USE MPL_BARRIER_MOD, ONLY : MPL_BARRIER
USE YOMHOOK, ONLY : DR_HOOK, LHOOK

USE HADES
USE atlas_module  , ONLY:atlas_griddistribution,atlas_structuredgrid,atlas_reducedgaussiangrid,atlas_structuredgrid

IMPLICIT NONE

#include "setup_trans0.h"
#include "trans_inq.h"
#include "dist_grid.h"
#include "gath_grid.h"
#include "dir_trans.h"
#include "inv_trans.h"
#include "posnam.intfb.h"
#include "abor1.intfb.h"

INTEGER(KIND=JPIM) :: NPRGPNS, NPRGPEW, NPRTRW, NPRTRV, NPRINTLEV
INTEGER(KIND=JPIM) :: MYPROC, NPROC

INTEGER (KIND=JPIM) :: IA, IB

TYPE (GRID_OPTIONS_t), TARGET :: YLGROPT2
TYPE (GRID_OPTIONS_t), POINTER :: YLGROPT
TYPE (GRID_t) :: YLGRID1, YLGRID2
TYPE (DIST_t) :: YLDIST1, YLDIST2

REAL (KIND=JPRB),    ALLOCATABLE :: ZFLD1 (:,:), ZFLD2 (:,:)
REAL (KIND=JPRB),    ALLOCATABLE :: ZUNDEF (:)
LOGICAL,             ALLOCATABLE :: LLUNDEF (:)
CHARACTER (LEN=16),  ALLOCATABLE :: CLPREF (:), CLSUFF (:)
INTEGER (KIND=JPIM), ALLOCATABLE :: INIVAU (:)

TYPE (SHUFFLE_t) :: YLSHFL12

INTEGER (KIND=JPIM) :: NGPTOT1, NGPTOT2

NAMELIST / NAMGRID / YLGROPT

REAL (KIND=JPRB) :: ZHOOK_HANDLE

type(atlas_structuredgrid):: dGrid
type(atlas_griddistribution):: dDist
type(atlas_structuredgrid):: eGrid
type(atlas_griddistribution):: eDist
type (SHUFFLE_t) :: ylshflatlas

OPEN (4, FORM='FORMATTED')

NPRINTLEV = 0

CALL POSNAM (4, 'NAMGRID')
YLGROPT => YLGROPT2
READ (4, NAMGRID)

NULLIFY (YLGROPT)

CALL MPL_INIT (LDENV = .FALSE.)

MYPROC = MPL_MYRANK ()
NPROC  = MPL_NUMPROC

CALL SQUARE (NPROC, IA, IB)

NPRGPNS = IA
NPRGPEW = IB
NPRTRW  = IA
NPRTRV  = IB

CALL MPL_GROUPS_CREATE (NPRTRW, NPRTRV)



CALL SETUP_TRANS0 (KOUT=0, KERR=0, KPRINTLEV=NPRINTLEV, KMAX_RESOL=3,  &
                 & KPRGPNS=NPRGPNS, KPRGPEW=NPRGPEW, KPRTRW=NPRTRW,    &
                 & LDEQ_REGIONS=.TRUE.)

CALL MPL_BARRIER()

IF (LHOOK) CALL DR_HOOK ('BBINTERP',0,ZHOOK_HANDLE)

CALL CREATE_GRID_DIST_FA (YLGRID1, YLDIST1, 'ZFLD1.fa', &
                        & GRID_OPTIONS_t (LGRIDONLY=.TRUE.))


CALL CREATE_GRID_DIST (YLGRID2, YLDIST2, YLGROPT2)

NGPTOT1 = YLDIST1%NGPTOTL (MYPROC)
NGPTOT2 = YLDIST2%NGPTOTL (MYPROC)

! Read input data

CALL READDATA (YLGRID1, YLDIST1, ZFLD1, 'ZFLD1.fa', LLUNDEF, &
             & ZUNDEF, CLPREF, INIVAU, CLSUFF)

ALLOCATE (ZFLD2 (NGPTOT2, SIZE (ZFLD1, 2)))

CALL CREATE_SHUFFLE (YLDIST1,dDist, YLGRID1,dGrid, YLDIST2,eDist, YLGRID2,eGrid, YLSHFL12,ylshflatlas)

! Interpolate fields

CALL DO_INTERPOLATION (YLDIST1, YLGRID1, YLDIST2, YLGRID2, ZFLD1, &
                     & ZFLD2, YDSHFL12=YLSHFL12, PUNDEF=ZUNDEF,   &
                     & LDUNDEF=LLUNDEF)


! Write fields

CALL WFA (ZFLD2, NGPTOT2, SIZE (ZFLD2, 2), "ZFLD2.fa",  &
        & CLPREF, INIVAU, CLSUFF, YLGRID2, YLDIST2)

IF (LHOOK) CALL DR_HOOK ('BBINTERP',1,ZHOOK_HANDLE)

CALL MPL_END

CONTAINS

SUBROUTINE READDATA (YDGRID, YDDIST, PGPL, CDFILE, LDUNDEF, &
                   & PUNDEF, CDPREF, KNIVAU, CDSUFF)

USE FA_MOD, ONLY : FA => FA_COM_DEFAULT
USE MPL_ALLGATHERV_MOD, ONLY : MPL_ALLGATHERV

TYPE (GRID_t),                   INTENT (IN)  :: YDGRID
TYPE (DIST_t),                   INTENT (IN)  :: YDDIST
CHARACTER (LEN=*),               INTENT (IN)  :: CDFILE
REAL (KIND=JPRB),   ALLOCATABLE, INTENT (OUT) :: PGPL (:,:)
REAL (KIND=JPRB),   ALLOCATABLE, INTENT (OUT) :: PUNDEF (:)
LOGICAL,            ALLOCATABLE, INTENT (OUT) :: LDUNDEF (:)
CHARACTER (LEN=16), ALLOCATABLE, INTENT (OUT) :: CDPREF (:)
INTEGER (KIND=JPIM),ALLOCATABLE, INTENT (OUT) :: KNIVAU (:)
CHARACTER (LEN=16), ALLOCATABLE, INTENT (OUT) :: CDSUFF (:)

#include "facilo.h"

INTEGER (KIND=JPIM) :: INFLD, MYPROC, NPROC, NGPTOT, NGPTOTG

MYPROC  = MPL_MYRANK ()
NPROC   = MPL_NUMPROC
NGPTOT  = YDDIST%NGPTOTL (MYPROC)
NGPTOTG = YDGRID%NGPTOTG

INFLD = 0

BLOCK
  INTEGER (KIND=JPIM) :: ILUN, IREP, INBARP, INBARI
  INTEGER (KIND=JPIM) :: INALDO, INTROU, INARES, INAMAX
  INTEGER (KIND=JPIM) :: IARTL, ILONGD, IPOSEX, JFLD
  CHARACTER (LEN=*), PARAMETER :: CLNOMC = 'c'
  CHARACTER (LEN=16) :: CLSKIP (8)
  CHARACTER (LEN=16) :: CLONLY (0)
  CHARACTER (LEN=16) :: CLIDEN
  CHARACTER (LEN=16), ALLOCATABLE :: CLNOMA (:)

  ILUN = 77_JPIM
  CALL FAITOU (IREP, ILUN, .TRUE., TRIM (CDFILE), 'OLD', &
             & .TRUE., .TRUE., 2_JPIM, INBARP, INBARI, CLNOMC)
  CALL FALSIF (IREP, ILUN, CLIDEN)
  CLSKIP = [CLIDEN, FA%CPCADI, FA%CPCAFS, FA%CPCARP, FA%CPCACH, FA%CPCASL, FA%CPDATE, FA%CPDATX]
! CLONLY = ['SFX.ZS          ', 'SFX.SAND        ', 'SFX.CLAY       ']
  CALL LFINAF (IREP, ILUN, INALDO, INTROU, INARES, INAMAX)

  CALL LFIPOS (IREP, ILUN)
  ALLOCATE (CLNOMA (INALDO))
  DO IARTL = 1, INALDO
    CALL LFICAS (IREP, ILUN, CLNOMA (IARTL), ILONGD, IPOSEX, .TRUE.)
    IF (ALL (CLSKIP /= CLNOMA (IARTL))) THEN
      IF (SIZE (CLONLY) == 0 .OR. ANY (CLONLY == CLNOMA (IARTL))) THEN
        INFLD = INFLD + 1
      ENDIF
    ENDIF
  ENDDO

  ALLOCATE (CDPREF (INFLD), KNIVAU (INFLD), CDSUFF (INFLD))

  JFLD = 1
  DO IARTL = 1, SIZE (CLNOMA)
    IF (ALL (CLSKIP /= CLNOMA (IARTL))) THEN
      IF (SIZE (CLONLY) == 0 .OR. ANY (CLONLY == CLNOMA (IARTL))) THEN
        CALL FAQUIN (IREP, ILUN, CDPREF (JFLD), KNIVAU (JFLD), CDSUFF (JFLD), &
                   & CLNOMA (IARTL), LEN_TRIM (CLNOMA (IARTL)))
        JFLD = JFLD + 1
      ENDIF
    ENDIF
  ENDDO
  CALL FAIRME (IREP, ILUN, 'KEEP')
ENDBLOCK

BLOCK
  CHARACTER (LEN=*), PARAMETER :: CLNOMC = 'c'
  INTEGER (KIND=JPIM) :: ILUN, IREP, INBARP, INBARI
  INTEGER (KIND=JPIM) :: IPROC, JFLD, JFLDG, INFLDG
  INTEGER (KIND=JPIM) :: JFLD1, JFLD2
  INTEGER (KIND=JPIM) :: IOFF (NPROC), ICNT (NPROC)
  INTEGER (KIND=JPIM) :: IFLD2PROC (INFLD)
  INTEGER (KIND=JPIM) :: IUNDEF (INFLD)
  REAL (KIND=JPRB), ALLOCATABLE :: ZGPBUFG (:,:)
  
  IOFF (1) = 0
  DO IPROC = 1, NPROC
    JFLD1 = 1 + (INFLD * (IPROC - 1)) / NPROC
    JFLD2 = 0 + (INFLD * (IPROC + 0)) / NPROC
    IFLD2PROC (JFLD1:JFLD2) = IPROC
    ICNT (IPROC) = JFLD2 - JFLD1 + 1
    IF (IPROC > 1) IOFF (IPROC) = IOFF (IPROC-1) + ICNT (IPROC-1)
  ENDDO

  INFLDG = ICNT (MYPROC)

  ALLOCATE (ZGPBUFG (NGPTOTG, INFLDG))
  ALLOCATE (PGPL (NGPTOT, INFLD), LDUNDEF (INFLD), PUNDEF (INFLD))

  LDUNDEF = .FALSE.

  IF (INFLDG > 0) THEN
    ILUN = 77_JPIM
    CALL FAITOU (IREP, ILUN, .TRUE., TRIM (CDFILE), 'OLD', &
               & .TRUE., .TRUE., 2_JPIM, INBARP, INBARI, CLNOMC)

    DO JFLDG = 1, INFLDG
      JFLD = IOFF (MYPROC) + JFLDG
      CALL FACILO (IREP, ILUN, CDPREF (JFLD), KNIVAU (JFLD), &
                 & CDSUFF (JFLD), ZGPBUFG (:, JFLDG), .FALSE., &
                 & LDUNDF=LDUNDEF (JFLD), PUNDF=PUNDEF (JFLD))
    ENDDO

    CALL FAIRME (IREP, ILUN, 'KEEP')
  ENDIF

  CALL GRID_DIST (ZGPBUFG, INFLD, IFLD2PROC, YDGRID, YDDIST, PGPL)

  CALL MPL_ALLGATHERV ([(PUNDEF (IOFF (MYPROC) + JFLDG), JFLDG=1, ICNT (MYPROC))], &
                     & PUNDEF, ICNT, CDSTRING='BBINTERP:READDATA')

  WHERE (LDUNDEF) 
    IUNDEF = 1
  ELSEWHERE
    IUNDEF = 0
  ENDWHERE

  CALL MPL_ALLGATHERV ([(IUNDEF (IOFF (MYPROC)+JFLDG), JFLDG = 1, ICNT (MYPROC))], &
                     & IUNDEF, ICNT, CDSTRING='BBINTERP:READDATA')

  LDUNDEF = IUNDEF > 0

ENDBLOCK

END SUBROUTINE 

SUBROUTINE SQUARE (KN, KA, KB)

INTEGER (KIND=JPIM) :: KN, KA, KB

KB = INT (SQRT (REAL (KN))) + 1

DO
  KA = KN / KB
  IF (KA * KB == KN) EXIT
  KB = KB - 1
ENDDO

END SUBROUTINE SQUARE

END PROGRAM TEST

