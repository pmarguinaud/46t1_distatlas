PROGRAM TEST

USE MPL_END_MOD, ONLY : MPL_END
USE MPL_INIT_MOD, ONLY : MPL_INIT
USE PARKIND1, ONLY : JPIM, JPRB
USE MPL_MODULE, ONLY : MPL_MYRANK, MPL_GROUPS_CREATE, MPL_NUMPROC
USE MPL_BARRIER_MOD, ONLY : MPL_BARRIER
USE YOMHOOK, ONLY : DR_HOOK, LHOOK

IMPLICIT NONE

INTEGER(KIND=JPIM) :: NPRGPNS, NPRGPEW, NPRTRW, NPRTRV, NPRINTLEV
INTEGER(KIND=JPIM) :: MYPROC, NPROC

#include "setup_trans0.h"
#include "trans_inq.h"
#include "dist_grid.h"
#include "gath_grid.h"
#include "dist_spec.h"
#include "gath_spec.h"
#include "dir_trans.h"
#include "inv_trans.h"
#include "posnam.intfb.h"
#include "faieno.h"


REAL (KIND=JPRB),   ALLOCATABLE         :: ZSPBUFL (:,:) 
REAL (KIND=JPRB),   ALLOCATABLE, TARGET :: ZGPBUFL (:,:,:) 


CHARACTER (LEN=64) :: CLFILENAME, CLARG
CHARACTER (LEN=64),  PARAMETER :: CLNOMC = 'c'
INTEGER (KIND=JPIM), PARAMETER :: ILUN = 77
INTEGER (KIND=JPIM) :: NITER, ITER
INTEGER (KIND=JPIM) :: INBARP, INBARI, IREP, INIMES, IVSET (1)
INTEGER (KIND=JPIM) :: NGPTOT, NSPEC2, NGPTOTG
INTEGER (KIND=JPIM) :: NDGLG, NSMAX
INTEGER (KIND=JPIM) :: IUSEFLT
INTEGER (KIND=JPIM) :: NLOEN (30000)
LOGICAL :: LUSEFLT

REAL (KIND=JPRB) :: ZHOOK_HANDLE

CALL GETARG (1, CLFILENAME)
CALL GETARG (2, CLARG) 
READ (CLARG, *) NITER
CALL GETARG (3, CLARG)
READ (CLARG, *) IUSEFLT

CALL MPL_INIT (LDENV = .FALSE.)

MYPROC = MPL_MYRANK ()
NPROC  = MPL_NUMPROC

NPRGPNS = NPROC
NPRGPEW = 1
NPRTRW  = NPROC
NPRTRV  = 1

CALL MPL_GROUPS_CREATE (NPRTRW, NPRTRV)

NPRINTLEV = 0

IF (MYPROC == 1) THEN
  NPRINTLEV = 1
ENDIF


CALL SETUP_TRANS0 (KOUT=0, KERR=0, KPRINTLEV=NPRINTLEV, KMAX_RESOL=3,  &
                 & KPRGPNS=NPRGPNS, KPRGPEW=NPRGPEW, KPRTRW=NPRTRW,    &
                 & LDEQ_REGIONS=.TRUE.)

CALL MPL_BARRIER()

IF (LHOOK) CALL DR_HOOK ('SPECSURFGEOPOTEN',0,ZHOOK_HANDLE)

CALL DFA (CLFILENAME)


ALLOCATE (ZGPBUFL (NGPTOT, 0:NITER, 1))
ALLOCATE (ZSPBUFL (1, NSPEC2))


#ifndef UNDEF
CALL RFA (ZGPBUFL (:, 0, 1), NGPTOT, 1_JPIM, CLFILENAME, ['SURF'], &
        & [0_JPIM], ['GEOPOTENTIEL'])
#else
CALL SFA (ZGPBUFL (:, 0, 1), NGPTOT, 1)
#endif

WRITE (CLFILENAME, '("SPEC2GRID.",I6.6,".fa")') 0
CALL WFA (ZGPBUFL (:, 0, 1), NGPTOT, 1_JPIM, CLFILENAME, ['SURF'], [0_JPIM], ['GEOPOTENTIEL'])


IVSET (1) = 1

DO ITER = 1, NITER

  CALL DIR_TRANS (PSPSCALAR=ZSPBUFL, PGP=ZGPBUFL (:, ITER-1:ITER-1, 1:1), KVSETSC=IVSET)
  CALL INV_TRANS (PSPSCALAR=ZSPBUFL, PGP=ZGPBUFL (:, ITER+0:ITER+0, 1:1), KVSETSC=IVSET)

  WRITE (CLFILENAME, '("SPEC2GRID.",I6.6,".fa")') ITER

  CALL WFA (ZGPBUFL (:, ITER, 1), NGPTOT, 1_JPIM, CLFILENAME, ['SURF'], [0_JPIM], ['GEOPOTENTIEL'])

  WRITE (*, '("==> ",I8," <==")') ITER


  BLOCK
    REAL (KIND=JPRB), PARAMETER :: XZSEPS = 1.E-2_JPRB
    INTEGER (KIND=JPIM) :: JGP, ICOUNT
    REAL (KIND=JPRB), POINTER :: Z1 (:), Z2 (:)
    
    Z1 => ZGPBUFL (:, ITER-1, 1)
    Z2 => ZGPBUFL (:, ITER+0, 1)

    WRITE (0, '(" MAX = ",E12.6," MIN = ",E12.6," AVG = ",E12.6)', ADVANCE='NO') &
         & MAXVAL (Z2), MINVAL (Z2), SUM (Z2) / SIZE (Z2)

    WRITE (0, '(" MAX = ",E12.6," MIN = ",E12.6," AVG = ",E12.6)') &
         & MAXVAL (Z2-Z1), MINVAL (Z2-Z1), SUM (ABS(Z2-Z1)) / SIZE (Z2)

    ICOUNT = 0

    DO JGP = 1, NGPTOT
      IF ((ABS (Z1 (JGP) - Z2 (JGP)) > MAX (XZSEPS * ABS (Z1 (JGP)), 10._JPRB * XZSEPS)) &
        & .AND. (Z1 (JGP) > 0._JPRB)) THEN
        WRITE (0, '("DIFF ",I6," | ",2E12.4)') JGP, Z1 (JGP), Z2 (JGP)
        ICOUNT = ICOUNT + 1
        IF (ICOUNT > 100) EXIT
      ENDIF
    ENDDO
  END BLOCK

ENDDO


IF (LHOOK) CALL DR_HOOK ('SPECSURFGEOPOTEN',1,ZHOOK_HANDLE)

CALL MPL_END

CONTAINS

SUBROUTINE RFA (PFLDL, KGPTOT, KFIELDL, CDFILENAME, CDPREF, &
              & KNIVAU, CDSUFF, PUNDEF, LDREQ)

USE MPL_MODULE, ONLY : MPL_MYRANK, MPL_NUMPROC

REAL (KIND=JPRB),   INTENT (OUT) :: PFLDL (KGPTOT,KFIELDL,1)
INTEGER (KIND=JPIM),INTENT (IN)  :: KGPTOT, KFIELDL
CHARACTER (LEN=*),  INTENT (IN)  :: CDFILENAME, CDPREF (:), CDSUFF (:)
INTEGER (KIND=JPIM),INTENT (IN)  :: KNIVAU (:)
REAL (KIND=JPRB),   INTENT (IN), OPTIONAL :: PUNDEF
LOGICAL,            INTENT (IN), OPTIONAL :: LDREQ (:)

REAL (KIND=JPRB), ALLOCATABLE :: ZFLDG (:,:)
REAL (KIND=JPRB) :: ZUNDEF

INTEGER (KIND=JPIM) :: IFROM (KFIELDL)
INTEGER (KIND=JPIM) :: MYPROC, NPROC, IPROC, JFLD1, JFLD2
INTEGER (KIND=JPIM) :: IREP, JFLDL, JFLDG, INFLDG

LOGICAL :: LLREQ (KFIELDL)
LOGICAL :: LLUNDEF
REAL(KIND=JPRB) :: ZHOOK_HANDLE

#include "abor1.intfb.h"
#include "dist_grid.h"
#include "trans_inq.h"
#include "facilo.h"

IF (LHOOK) CALL DR_HOOK ('RFA',0,ZHOOK_HANDLE)

CALL TRANS_INQ (KGPTOTG=NGPTOTG)

IF (PRESENT (LDREQ)) THEN
  LLREQ = LDREQ
ELSE
  LLREQ = .TRUE.
ENDIF

NPROC = MPL_NUMPROC 
MYPROC = MPL_MYRANK ()

DO IPROC = 1, NPROC
  JFLD1 = 1 + ((IPROC-1) * KFIELDL) / NPROC
  JFLD2 = 0 + ((IPROC+0) * KFIELDL) / NPROC
  IFROM (JFLD1:JFLD2) = IPROC
ENDDO

INFLDG = COUNT (IFROM == MYPROC)

IF (INFLDG > 0) THEN
  BLOCK
    INTEGER (KIND=JPIM) :: INBARP, INBARI
    CALL FAITOU (IREP, 77, .TRUE., TRIM (CDFILENAME), 'OLD', &
               & .TRUE., .TRUE., 2_JPIM, INBARP, INBARI, CLNOMC)
    CALL FACAGE (CLNOMC, .TRUE.)
  ENDBLOCK
  ALLOCATE (ZFLDG (NGPTOTG, INFLDG))
ENDIF

BLOCK
  INTEGER (KIND=JPIM) :: ILNOMA, ILONGD, IPOSEX
  CHARACTER (LEN=16) :: CLNOMA
  JFLDG = 1
  DO JFLDL = 1, KFIELDL
    IF (IFROM (JFLDL) == MYPROC) THEN
      CALL FANFAN (IREP, 77, CDPREF (JFLDL), KNIVAU (JFLDL), CDSUFF (JFLDL), CLNOMA, ILNOMA)
      CALL LFINFO (IREP, 77, CLNOMA (1:ILNOMA), ILONGD, IPOSEX)
      IF (ILONGD == 0) THEN
        IF (LLREQ (JFLDL)) THEN
          CALL ABOR1 ('FIELD '//CLNOMA (1:ILNOMA)//' WAS NOT FOUND IN '//TRIM (CDFILENAME))
        ELSEIF (PRESENT (PUNDEF)) THEN
          ZFLDG (:, JFLDG) = PUNDEF
        ELSE
          ZFLDG (:, JFLDG) = 0._JPRB
        ENDIF
      ELSE
        LLUNDEF = PRESENT (PUNDEF)
        IF (LLUNDEF) ZUNDEF = PUNDEF
        CALL FACILO (IREP, 77, CDPREF (JFLDL), KNIVAU (JFLDL), CDSUFF (JFLDL), &
                   & ZFLDG (:, JFLDG), .FALSE., LDUNDF=LLUNDEF, PUNDF=ZUNDEF)
      ENDIF
      JFLDG = JFLDG + 1
    ENDIF
  ENDDO
ENDBLOCK

IF (INFLDG > 0) THEN
  CALL FAIRME (IREP, 77, 'KEEP')
  CALL DIST_GRID (PGPG=ZFLDG (:,:), &
                & KFDISTG=KFIELDL, KFROM=IFROM, PGP=PFLDL (:,:,:))
ELSE
  CALL DIST_GRID (KFDISTG=KFIELDL, KFROM=IFROM, PGP=PFLDL (:,:,:))
ENDIF

IF (LHOOK) CALL DR_HOOK ('RFA',1,ZHOOK_HANDLE)

END SUBROUTINE

SUBROUTINE SFA (PFLDL, KGPTOT, KFIELDL)

USE MPL_MODULE, ONLY : MPL_MYRANK, MPL_NUMPROC

REAL (KIND=JPRB),    INTENT (OUT) :: PFLDL (KGPTOT,KFIELDL,1)
INTEGER (KIND=JPIM), INTENT (IN)  :: KGPTOT, KFIELDL

REAL (KIND=JPRB), ALLOCATABLE :: ZFLDG (:,:)

INTEGER (KIND=JPIM) :: IFROM (KFIELDL)
INTEGER (KIND=JPIM) :: MYPROC, NPROC, IPROC, JFLD1, JFLD2, NGPTOTG
INTEGER (KIND=JPIM) :: JFLDL, JFLDG, INFLDG, JGPG
INTEGER (KIND=JPIM) :: JLON, JLAT
REAL (KIND=JPRB) :: ZLON, ZLAT
REAL (KIND=JPRB), PARAMETER :: RPI = 2.0_JPRB * ASIN (1.0_JPRB)

REAL(KIND=JPRB) :: ZHOOK_HANDLE

#include "abor1.intfb.h"
#include "dist_grid.h"
#include "trans_inq.h"

IF (LHOOK) CALL DR_HOOK ('RFA',0,ZHOOK_HANDLE)

CALL TRANS_INQ (KGPTOTG=NGPTOTG)

NPROC = MPL_NUMPROC 
MYPROC = MPL_MYRANK ()

DO IPROC = 1, NPROC
  JFLD1 = 1 + ((IPROC-1) * KFIELDL) / NPROC
  JFLD2 = 0 + ((IPROC+0) * KFIELDL) / NPROC
  IFROM (JFLD1:JFLD2) = IPROC
ENDDO

INFLDG = COUNT (IFROM == MYPROC)

IF (INFLDG > 0) THEN
  ALLOCATE (ZFLDG (NGPTOTG, INFLDG))
ENDIF

BLOCK
  JFLDG = 1
  DO JFLDL = 1, KFIELDL
    IF (IFROM (JFLDL) == MYPROC) THEN
      JGPG = 1
      DO JLAT = 1, NDGLG
        ZLAT = RPI * (REAL (JLAT - NDGLG / 2, JPRB) - 0.5_JPRB) / NDGLG
        DO JLON = 1, NLOEN (JLAT)
          ZLON = 2._JPRB * RPI * REAL (JLON-1, JPRB) / REAL (NLOEN (JLAT), JPRB)
          ZFLDG (JGPG, JFLDG) = COS (4._JPRB * ZLAT) * SIN (10._JPRB * ZLON)
          JGPG = JGPG + 1
        ENDDO
      ENDDO
      JFLDG = JFLDG + 1
    ENDIF
  ENDDO
ENDBLOCK

IF (INFLDG > 0) THEN
  CALL DIST_GRID (PGPG=ZFLDG (:,:), &
                & KFDISTG=KFIELDL, KFROM=IFROM, PGP=PFLDL (:,:,:))
ELSE
  CALL DIST_GRID (KFDISTG=KFIELDL, KFROM=IFROM, PGP=PFLDL (:,:,:))
ENDIF

IF (LHOOK) CALL DR_HOOK ('RFA',1,ZHOOK_HANDLE)

END SUBROUTINE

SUBROUTINE DFA (CDFILENAME)

USE FA_MOD, ONLY : FA_COM_DEFAULT, &
                 & NEW_FA_DEFAULT, FACADR

CHARACTER (LEN=*), INTENT (IN)  :: CDFILENAME

#include "abor1.intfb.h"
#include "setup_trans.h"
#include "trans_inq.h"

CHARACTER (LEN=*), PARAMETER :: CLNOMC = 'c'
INTEGER (KIND=JPIM)   :: ILUN, IREP, INBARP, INBARI


ILUN = 77_JPIM
CALL FAITOU (IREP, ILUN, .TRUE., TRIM (CDFILENAME), 'OLD', &
           & .TRUE., .TRUE., 2_JPIM, INBARP, INBARI, CLNOMC)

BLOCK
  INTEGER (KIND=JPIM) :: IRANGC
  TYPE (FACADR), POINTER :: YLCADR 
  CALL FANUCA (CLNOMC, IRANGC, .FALSE.)
  YLCADR => FA_COM_DEFAULT%CADRE (IRANGC)

  NDGLG = YLCADR%NLATIT
  NSMAX = YLCADR%MTRONC

  IF (MODULO (NDGLG, 2) == 0) THEN
    NLOEN (1:NDGLG/2) = YLCADR%NLOPAR (1:NDGLG)
    NLOEN (NDGLG/2+1:NDGLG) = NLOEN (NDGLG/2:1:-1)
  ELSE
    CALL ABOR1 ('UNEXPECTED ODD NUMBER OF LATITUDES')
  ENDIF

ENDBLOCK

CALL FAIRME (IREP, ILUN, 'KEEP')

IF (MYPROC == 1) THEN
  WRITE (0, *) " NSMAX = ", NSMAX
  WRITE (0, *) " NDGLG = ", NDGLG
  WRITE (0, *) " NLOEN = ", NLOEN (1:NDGLG)
ENDIF

LUSEFLT = IUSEFLT > 0

CALL SETUP_TRANS (KSMAX=NSMAX, KDGL=NDGLG, KLOEN=NLOEN (1:NDGLG), LDSPLIT=.TRUE., LDUSEFLT=LUSEFLT)

CALL TRANS_INQ (KGPTOT=NGPTOT)
CALL TRANS_INQ (KSPEC2=NSPEC2)

END SUBROUTINE

SUBROUTINE WFA (PFLDL, KGPTOT, KFIELDL, CDFILENAME, CDPREF, KNIVAU, CDSUFF)

USE MPL_MODULE, ONLY : MPL_MYRANK, MPL_NUMPROC

REAL (KIND=JPRB),   INTENT (IN) :: PFLDL (KGPTOT,KFIELDL,1)
INTEGER (KIND=JPIM),INTENT (IN) :: KGPTOT, KFIELDL
CHARACTER (LEN=*),  INTENT (IN) :: CDFILENAME, CDPREF (:), CDSUFF (:)
INTEGER (KIND=JPIM),INTENT (IN) :: KNIVAU (:)

REAL (KIND=JPRB), ALLOCATABLE :: ZFLDG (:,:)

INTEGER (KIND=JPIM) :: ITO (KFIELDL)
INTEGER (KIND=JPIM) :: MYPROC, NPROC, IPROC, JFLD1, JFLD2
INTEGER (KIND=JPIM) :: IREP, JFLDL, JFLDG, INFLDG
CHARACTER (LEN=64) :: CLFILENAME, CLPROC
REAL(KIND=JPRB) :: ZHOOK_HANDLE

#include "abor1.intfb.h"
#include "gath_grid.h"
#include "faieno.h"

IF (LHOOK) CALL DR_HOOK ('WFA',0,ZHOOK_HANDLE)

NPROC = MPL_NUMPROC 
MYPROC = MPL_MYRANK ()

DO IPROC = 1, NPROC
  JFLD1 = 1 + ((IPROC-1) * KFIELDL) / NPROC
  JFLD2 = 0 + ((IPROC+0) * KFIELDL) / NPROC
  ITO (JFLD1:JFLD2) = IPROC
ENDDO

INFLDG = COUNT (ITO == MYPROC)

IF (INFLDG > 0) THEN
  ALLOCATE (ZFLDG (NGPTOTG, INFLDG))
  CALL GATH_GRID (PGPG=ZFLDG (:,:), &
                & KFGATHG=KFIELDL, KTO=ITO, PGP=PFLDL)
ELSE
  CALL GATH_GRID (KFGATHG=KFIELDL, KTO=ITO, PGP=PFLDL)
  GOTO 999
ENDIF

WRITE (CLPROC, '(".",I8.8)') MYPROC
CLFILENAME = TRIM (CDFILENAME) // TRIM (CLPROC)

BLOCK
  INTEGER (KIND=JPIM) :: IDATEF (11), INBARI, INBARP
  INBARI = 0
  INBARP = 0
  CALL FAITOU (IREP, 77, .TRUE., TRIM (CLFILENAME), 'UNKNOWN', &
             & .TRUE., .TRUE., 2_JPIM, INBARP, INBARI, CLNOMC)
  IDATEF = [1990,  2, 15, 12,  0,   1,  0, 24,   1, 0, 0]
  CALL FANDAR (IREP, 77, IDATEF)
ENDBLOCK

BLOCK
  INTEGER (KIND=JPIM) :: INGRIB, INARG1, INARG2, INARG3, INARG4, INARG5
  CALL FAVEUR (IREP, 77, INGRIB, INARG1, INARG2, INARG3, INARG4, INARG5)
  INGRIB = 123_JPIM
  CALL FAGOTE (IREP, 77, INGRIB, INARG1, INARG2, INARG3, INARG4, INARG5)
ENDBLOCK

BLOCK
  JFLDG = 1
  DO JFLDL = 1, KFIELDL
    IF (ITO (JFLDL) == MYPROC) THEN
      CALL FAIENO (IREP, 77, CDPREF (JFLDL), KNIVAU (JFLDL), CDSUFF (JFLDL), &
                 & ZFLDG (:, JFLDG), .FALSE.)
      JFLDG = JFLDG + 1
    ENDIF
  ENDDO
ENDBLOCK

CALL FAIRME (IREP, 77, 'KEEP')

999 CONTINUE

IF (LHOOK) CALL DR_HOOK ('WFA',1,ZHOOK_HANDLE)

END SUBROUTINE

END PROGRAM

